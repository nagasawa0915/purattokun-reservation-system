<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚·ãƒ³ãƒ—ãƒ«Spineçµ±åˆãƒ†ã‚¹ãƒˆ - ã·ã‚‰ã£ã¨ãã‚“</title>
    <style>
        /* ãƒªã‚»ãƒƒãƒˆ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* èƒŒæ™¯ã‚³ãƒ³ãƒ†ãƒŠ */
        .background-container {
            position: relative;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            overflow: hidden;
        }
        
        /* èƒŒæ™¯ç”»åƒ */
        .background-image {
            width: 100%;
            height: auto;
            display: block;
        }
        
        /* é›²ã®å…±é€šã‚¹ã‚¿ã‚¤ãƒ« */
        .cloud {
            position: absolute;
            opacity: 0.7;
            pointer-events: none;
        }
        
        /* å„é›²ã®ä½ç½® */
        .cloud1 { left: -5%; top: 10%; width: 8%; animation: moveCloud1 25s linear infinite; }
        .cloud2 { left: -5%; top: 15%; width: 8%; animation: moveCloud2 30s linear infinite; }
        .cloud3 { left: -5%; top: 8%; width: 8%; animation: moveCloud3 35s linear infinite; }
        
        /* é›²ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        @keyframes moveCloud1 { from { left: -10%; } to { left: 110%; } }
        @keyframes moveCloud2 { from { left: -10%; } to { left: 110%; } }
        @keyframes moveCloud3 { from { left: -10%; } to { left: 110%; } }
        
        /* ã·ã‚‰ã£ã¨ãã‚“Canvas */
        #purattokun-canvas {
            position: absolute;
            left: 18%;
            top: 65%;    /* 49% â†’ 65% ã«å¤‰æ›´ï¼ˆç™½ã„æ ã®ä¸‹ã«é…ç½®ï¼‰ */
            transform: translate(-50%, -50%);
            width: 16%;  /* èƒŒæ™¯ç”»åƒã®16%ã®å¹… */
            height: 16%; /* èƒŒæ™¯ç”»åƒã®16%ã®é«˜ã• */
            pointer-events: auto;
        }
        
        .info {
            margin: 20px;
            padding: 20px;
            background: #f0f0f0;
            border-radius: 8px;
        }
        
        .status {
            margin-top: 10px;
            padding: 10px;
            background: #e0e0e0;
            border-radius: 4px;
            font-family: monospace;
        }
        
        /* ã‚¬ã‚¿ãƒ³ãƒ†ã‚¹ãƒˆç”¨ã‚µãƒ¼ãƒ“ã‚¹ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */
        .services {
            padding: 80px 0;
            background: #fff;
            position: relative;
            overflow: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        .services h2 {
            text-align: center;
            font-size: 2.2rem;
            margin-bottom: 3rem;
            color: #333;
        }
        
        .service-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
        }
        
        .service-card {
            background: #fff;
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            text-align: center;
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            opacity: 0;
            transform: translateY(20px) scale(0.95);
        }
        
        .service-card.animate {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        
        .service-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        .service-card h3 {
            color: #333;
            margin-bottom: 1rem;
            font-size: 1.3rem;
        }
        
        .service-card p {
            color: #666;
            line-height: 1.6;
        }
        
        /* Heroæ§‹é€ ãƒ†ã‚¹ãƒˆç”¨CSSï¼ˆç¾åœ¨ã®ã‚µã‚¤ãƒˆã¨åŒã˜ï¼‰ */
        .hero {
            position: relative;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
            padding: 120px 20px 40px;
            overflow: hidden;
        }
        
        .hero::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 107, 107, 0.1) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
            z-index: 0;
        }
        
        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hero-content {
            position: absolute;
            z-index: 20;
            max-width: 280px;
            background: rgba(255, 255, 255, 0.6);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
            backdrop-filter: blur(8px);
            left: 40px;
            top: 130px;
        }
        
        .hero-title {
            font-size: 2rem;
            color: #333;
            margin-bottom: 0.8rem;
            line-height: 1.2;
            font-weight: 600;
        }
        
        .series-text {
            display: block;
            font-size: 0.9em;
            margin-top: 0.2rem;
        }
        
        .hero-subtitle {
            font-size: 1rem;
            color: #666;
            margin-bottom: 1.5rem;
        }
        
        .cta-button {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1rem;
            border-radius: 50px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .cta-button:hover {
            background: #ff5252;
        }
    </style>
</head>
<body>
    <div class="info">
        <h1>ã‚·ãƒ³ãƒ—ãƒ«Spineçµ±åˆãƒ†ã‚¹ãƒˆ + Heroæ§‹é€ </h1>
        <p>ã‚·ãƒ³ãƒ—ãƒ«ã‚µãƒ³ãƒ—ãƒ«ã«.heroæ§‹é€ ã‚’è¿½åŠ ã—ã¦ã‚¬ã‚¿ãƒ³ã‚’å†ç¾ãƒ†ã‚¹ãƒˆ</p>
        <div class="status" id="status">åˆæœŸåŒ–ä¸­...</div>
    </div>
    
    <!-- Heroæ§‹é€ ãƒ†ã‚¹ãƒˆ -->
    <section class="hero">
        <!-- èƒŒæ™¯ã‚³ãƒ³ãƒ†ãƒŠ -->
        <div class="background-container">
            <img src="assets/images/ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼TOP.png" alt="èƒŒæ™¯" class="background-image">
            <img src="assets/images/kumo1.png" alt="é›²1" class="cloud cloud1">
            <img src="assets/images/kumo2.png" alt="é›²2" class="cloud cloud2">
            <img src="assets/images/kumo3.png" alt="é›²3" class="cloud cloud3">
            <canvas id="purattokun-canvas"></canvas>
        </div>
        
        <!-- UIè¦ç´ ï¼ˆç¾åœ¨ã®ã‚µã‚¤ãƒˆã¨åŒã˜ï¼‰ -->
        <header class="hero-content">
            <h1 class="hero-title">ã·ã‚‰ã£ã¨ãã‚“<br><span class="series-text">ã‚·ãƒªãƒ¼ã‚º</span></h1>
            <p class="hero-subtitle">ã‚ãªãŸã®ãƒ“ã‚¸ãƒã‚¹ã‚’ã‚µãƒãƒ¼ãƒˆ</p>
            <button class="cta-button" type="button">è©³ã—ãè¦‹ã‚‹</button>
        </header>
    </section>
    
    <!-- ã‚¬ã‚¿ãƒ³ãƒ†ã‚¹ãƒˆç”¨ã‚µãƒ¼ãƒ“ã‚¹ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
    <section class="services">
        <div class="container">
            <h2>ã‚¬ã‚¿ãƒ³ãƒ†ã‚¹ãƒˆ - ã‚µãƒ¼ãƒ“ã‚¹å†…å®¹</h2>
            <div class="service-grid">
                <div class="service-card">
                    <div class="service-icon">ğŸ“…</div>
                    <h3>ã‚µãƒ¼ãƒ“ã‚¹1</h3>
                    <p>ã“ã‚Œã¯ã‚¬ã‚¿ãƒ³ãƒ†ã‚¹ãƒˆç”¨ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚«ãƒ¼ãƒ‰1ã§ã™ã€‚</p>
                </div>
                <div class="service-card">
                    <div class="service-icon">ğŸ’°</div>
                    <h3>ã‚µãƒ¼ãƒ“ã‚¹2</h3>
                    <p>ã“ã‚Œã¯ã‚¬ã‚¿ãƒ³ãƒ†ã‚¹ãƒˆç”¨ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚«ãƒ¼ãƒ‰2ã§ã™ã€‚</p>
                </div>
                <div class="service-card">
                    <div class="service-icon">ğŸ“</div>
                    <h3>ã‚µãƒ¼ãƒ“ã‚¹3</h3>
                    <p>ã“ã‚Œã¯ã‚¬ã‚¿ãƒ³ãƒ†ã‚¹ãƒˆç”¨ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚«ãƒ¼ãƒ‰3ã§ã™ã€‚</p>
                </div>
                <div class="service-card">
                    <div class="service-icon">ğŸ±</div>
                    <h3>ã‚µãƒ¼ãƒ“ã‚¹4</h3>
                    <p>ã“ã‚Œã¯ã‚¬ã‚¿ãƒ³ãƒ†ã‚¹ãƒˆç”¨ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚«ãƒ¼ãƒ‰4ã§ã™ã€‚</p>
                </div>
            </div>
        </div>
    </section>
    
    <!-- Spine WebGL Runtime -->
    <script src="https://unpkg.com/@esotericsoftware/spine-webgl@4.1.*/dist/iife/spine-webgl.js"></script>
    
    <!-- æœ€å°é™ã®Spineçµ±åˆ -->
    <script>
        const status = document.getElementById('status');
        
        // SpineåˆæœŸåŒ–ã‚’å¾…ã¤
        function waitForSpine() {
            if (typeof spine !== 'undefined') {
                status.textContent = 'âœ… Spineèª­ã¿è¾¼ã¿å®Œäº†';
                initSpineCharacter();
            } else {
                status.textContent = 'â³ Spineèª­ã¿è¾¼ã¿ä¸­...';
                setTimeout(waitForSpine, 100);
            }
        }
        
        // Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼åˆæœŸåŒ–
        async function initSpineCharacter() {
            try {
                const canvas = document.getElementById('purattokun-canvas');
                const gl = canvas.getContext('webgl', { alpha: true });
                
                if (!gl) {
                    throw new Error('WebGLã‚µãƒãƒ¼ãƒˆãªã—');
                }
                
                // Canvasã‚µã‚¤ã‚ºè¨­å®šï¼ˆãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œï¼‰
                const updateCanvasSize = () => {
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                    console.log('Canvaså®Ÿã‚µã‚¤ã‚º:', canvas.width + 'x' + canvas.height);
                };
                updateCanvasSize();
                
                // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºæ™‚ã«Canvasã‚µã‚¤ã‚ºã‚‚æ›´æ–°
                window.addEventListener('resize', updateCanvasSize);
                
                status.textContent = 'ğŸ“ Spineãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ä¸­...';
                
                // ã‚¢ã‚»ãƒƒãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ï¼ˆãƒ‘ã‚¹ä¿®æ­£ï¼‰
                const basePath = 'assets/spine/characters/purattokun/';
                const assetManager = new spine.AssetManager(gl, basePath);
                assetManager.loadTextureAtlas('purattokun.atlas');
                assetManager.loadJson('purattokun.json');
                
                // ã‚¢ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿å®Œäº†å¾…ã¡ï¼ˆãƒ‡ãƒãƒƒã‚°ä»˜ãï¼‰
                await new Promise((resolve, reject) => {
                    let checkCount = 0;
                    const maxChecks = 100; // 10ç§’ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
                    
                    const checkAssets = () => {
                        checkCount++;
                        
                        if (assetManager.isLoadingComplete()) {
                            console.log('âœ… ã‚¢ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿å®Œäº†');
                            resolve();
                        } else if (checkCount > maxChecks) {
                            const errors = assetManager.getErrors();
                            console.error('âŒ èª­ã¿è¾¼ã¿ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ:', errors);
                            reject(new Error('ã‚¢ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: ' + JSON.stringify(errors)));
                        } else {
                            if (checkCount % 10 === 0) {
                                console.log(`â³ èª­ã¿è¾¼ã¿ä¸­... (${checkCount}/100)`);
                            }
                            setTimeout(checkAssets, 100);
                        }
                    };
                    checkAssets();
                });
                
                status.textContent = 'ğŸ¬ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹...';
                
                // Atlaså–å¾—
                const atlas = assetManager.get('purattokun.atlas');
                const atlasLoader = new spine.AtlasAttachmentLoader(atlas);
                
                // SkeletonDataèª­ã¿è¾¼ã¿
                const skeletonJson = new spine.SkeletonJson(atlasLoader);
                const skeletonData = skeletonJson.readSkeletonData(assetManager.get('purattokun.json'));
                
                // Skeletonä½œæˆ
                const skeleton = new spine.Skeleton(skeletonData);
                skeleton.x = 0;  // å›ºå®šå€¤ 0
                skeleton.y = 0;  // å›ºå®šå€¤ 0
                skeleton.scaleX = skeleton.scaleY = 0.3;  // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’å°ã•ã
                
                console.log('ğŸ“Š Skeletonæƒ…å ±:', {
                    x: skeleton.x,
                    y: skeleton.y,
                    scale: skeleton.scaleX,
                    animations: skeleton.data.animations.map(a => a.name)
                });
                
                // AnimationState
                const animationStateData = new spine.AnimationStateData(skeleton.data);
                const animationState = new spine.AnimationState(animationStateData);
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
                if (skeleton.data.findAnimation('taiki')) {
                    animationState.setAnimation(0, 'taiki', true);
                    console.log('âœ… ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š: taiki');
                } else if (skeleton.data.animations.length > 0) {
                    const animName = skeleton.data.animations[0].name;
                    animationState.setAnimation(0, animName, true);
                    console.log('âœ… ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š:', animName);
                } else {
                    console.warn('âš ï¸ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                }
                
                // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼
                const shader = spine.Shader.newTwoColoredTextured(gl);
                const renderer = new spine.SceneRenderer(canvas, gl);
                
                // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—
                let lastTime = Date.now() / 1000;
                let frameCount = 0;
                
                function render() {
                    const now = Date.now() / 1000;
                    const delta = now - lastTime;
                    lastTime = now;
                    
                    // æ›´æ–°
                    animationState.update(delta);
                    animationState.apply(skeleton);
                    skeleton.updateWorldTransform();
                    
                    // æç”»
                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    
                    // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆè¨­å®š
                    gl.viewport(0, 0, canvas.width, canvas.height);
                    
                    renderer.begin();
                    renderer.drawSkeleton(skeleton, true);
                    renderer.end();
                    
                    frameCount++;
                    if (frameCount === 1) {
                        console.log('ğŸ¬ æœ€åˆã®ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å®Œäº†');
                    }
                    if (frameCount % 60 === 0) {
                        console.log(`ğŸ“¹ ${frameCount}ãƒ•ãƒ¬ãƒ¼ãƒ æç”»æ¸ˆã¿`);
                    }
                    
                    requestAnimationFrame(render);
                }
                
                render();
                status.textContent = 'âœ… Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼å‹•ä½œä¸­';
                
            } catch (error) {
                status.textContent = 'âŒ ã‚¨ãƒ©ãƒ¼: ' + error.message;
                console.error('SpineåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
        
        // é–‹å§‹
        waitForSpine();
        
        // ã‚¬ã‚¿ãƒ³ãƒ†ã‚¹ãƒˆç”¨IntersectionObserver
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -50px 0px'
        };
        
        const animationObserver = new IntersectionObserver(function(entries) {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const cards = document.querySelectorAll('.service-card');
                    const index = Array.from(cards).indexOf(entry.target);
                    
                    console.log(`ğŸ” [GATAN TEST] ã‚µãƒ¼ãƒ“ã‚¹ã‚«ãƒ¼ãƒ‰${index + 1}ãŒç”»é¢ã«å…¥ã‚Šã¾ã—ãŸ`);
                    
                    // èƒŒæ™¯ç”»åƒã¨Canvasã®æ¸¬å®šï¼ˆBEFOREï¼‰
                    const backgroundImage = document.querySelector('.background-image');
                    const purattokuCanvas = document.querySelector('#purattokun-canvas');
                    
                    let beforeBgRect = null;
                    let beforeCanvasRect = null;
                    
                    if (backgroundImage) {
                        beforeBgRect = backgroundImage.getBoundingClientRect();
                        console.log(`ğŸ“ [BEFORE] èƒŒæ™¯ç”»åƒ:`, {
                            width: beforeBgRect.width,
                            height: beforeBgRect.height,
                            left: beforeBgRect.left,
                            top: beforeBgRect.top
                        });
                    }
                    
                    if (purattokuCanvas) {
                        beforeCanvasRect = purattokuCanvas.getBoundingClientRect();
                        console.log(`ğŸ“ [BEFORE] ã·ã‚‰ã£ã¨ãã‚“:`, {
                            width: beforeCanvasRect.width,
                            height: beforeCanvasRect.height,
                            left: beforeCanvasRect.left,
                            top: beforeCanvasRect.top
                        });
                    }
                    
                    setTimeout(() => {
                        entry.target.classList.add('animate');
                        console.log(`ğŸ¬ [GATAN TEST] ã‚µãƒ¼ãƒ“ã‚¹ã‚«ãƒ¼ãƒ‰${index + 1}ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹`);
                        
                        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¾Œã®æ¸¬å®š
                        setTimeout(() => {
                            if (backgroundImage && beforeBgRect) {
                                const afterBgRect = backgroundImage.getBoundingClientRect();
                                console.log(`ğŸ“ [AFTER] èƒŒæ™¯ç”»åƒ:`, {
                                    width: afterBgRect.width,
                                    height: afterBgRect.height,
                                    left: afterBgRect.left,
                                    top: afterBgRect.top,
                                    changeX: afterBgRect.left - beforeBgRect.left,
                                    changeY: afterBgRect.top - beforeBgRect.top,
                                    changeW: afterBgRect.width - beforeBgRect.width,
                                    changeH: afterBgRect.height - beforeBgRect.height
                                });
                            }
                            
                            if (purattokuCanvas && beforeCanvasRect) {
                                const afterCanvasRect = purattokuCanvas.getBoundingClientRect();
                                console.log(`ğŸ“ [AFTER] ã·ã‚‰ã£ã¨ãã‚“:`, {
                                    width: afterCanvasRect.width,
                                    height: afterCanvasRect.height,
                                    left: afterCanvasRect.left,
                                    top: afterCanvasRect.top,
                                    changeX: afterCanvasRect.left - beforeCanvasRect.left,
                                    changeY: afterCanvasRect.top - beforeCanvasRect.top,
                                    changeW: afterCanvasRect.width - beforeCanvasRect.width,
                                    changeH: afterCanvasRect.height - beforeCanvasRect.height
                                });
                                
                                // ç›¸é–¢åˆ†æ
                                if (beforeBgRect) {
                                    const bgChangeY = afterBgRect ? afterBgRect.top - beforeBgRect.top : 0;
                                    const canvasChangeY = afterCanvasRect.top - beforeCanvasRect.top;
                                    const difference = canvasChangeY - bgChangeY;
                                    const isOutOfSync = Math.abs(difference) >= 2;
                                    
                                    console.log(`ğŸ“Š [GATAN ANALYSIS] ã‚µãƒ¼ãƒ“ã‚¹ã‚«ãƒ¼ãƒ‰${index + 1} - ã‚·ãƒ³ãƒ—ãƒ«æ§‹é€ ã§ã®ç›¸é–¢:`, {
                                        backgroundChangeY: bgChangeY,
                                        canvasChangeY: canvasChangeY,
                                        difference: difference,
                                        syncStatus: isOutOfSync ? 'âŒã‚ºãƒ¬' : 'âœ…åŒæœŸ',
                                        note: 'ã‚·ãƒ³ãƒ—ãƒ«ã‚µãƒ³ãƒ—ãƒ«ã§ã®ã‚¬ã‚¿ãƒ³ãƒ†ã‚¹ãƒˆçµæœ'
                                    });
                                }
                            }
                        }, 100);
                        
                    }, index * 150);
                }
            });
        }, observerOptions);
        
        // ã‚µãƒ¼ãƒ“ã‚¹ã‚«ãƒ¼ãƒ‰ã‚’ç›£è¦–å¯¾è±¡ã«è¿½åŠ 
        document.querySelectorAll('.service-card').forEach(card => {
            animationObserver.observe(card);
        });
    </script>
</body>
</html>