<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ElementObserver × PureBoundingBox 統合テスト</title>
    <style>
        body {
            background: #f0f0f0;
            font-family: Arial, sans-serif;
            padding: 20px;
            margin: 0;
            touch-action: none;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .test-area {
            position: relative;
            width: 800px;
            height: 500px;
            background: #e8f4f8;
            border: 2px solid #007cba;
            margin: 20px auto;
            border-radius: 10px;
            touch-action: none;
        }
        .layout-anchor {
            position: absolute;
            background: rgba(255, 107, 107, 0.3);
            border: 2px solid #ff6b6b;
            border-radius: 8px;
            transform: translate(-50%, -50%);
            touch-action: none;
        }
        .interactive {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            font-weight: bold;
            cursor: pointer;
            transform: translate(var(--tx, 0), var(--ty, 0));
            touch-action: none;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        button {
            background: #007cba;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #005a8a;
        }
        .log {
            background: #f8f8f8;
            border: 1px solid #ddd;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            font-size: 12px;
        }
        .success { color: #28a745; }
        .error { color: #dc3545; }
        .warning { color: #ffc107; }
        .info { color: #007cba; }
        .debug { color: #6f42c1; }
        /* Spine Canvas のスタイル */
        .spine-canvas {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }
        .status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            margin: 0 5px;
        }
        .status.active {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.inactive {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .instructions {
            background: #e3f2fd;
            border: 1px solid #90caf9;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .instructions h3 {
            margin-top: 0;
            color: #1976d2;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>🌊 ElementObserver × PureBoundingBox 統合テスト</h1>
        
        <div class="instructions">
            <h3>📝 統合テスト内容</h3>
            <ol>
                <li><strong>親要素サイズ0問題の解決確認</strong> - commitToPercent()の安定実行</li>
                <li><strong>座標スワップ安全性チェック</strong> - 事前チェック機能</li>
                <li><strong>リアルタイム監視</strong> - 親要素変化の即座検出</li>
                <li><strong>BB外クリック選択解除</strong> - 従来機能の完全保持</li>
                <li><strong>ログ出力最適化</strong> - ElementObserver統合による詳細監視</li>
            </ol>
            <p><strong>🎯 期待結果</strong>：「親要素サイズが0のため、コミット処理をスキップ」エラーの完全解決</p>
        </div>
        
        <div class="controls">
            <button onclick="initializeElementObserver()">🌊 ElementObserver初期化</button>
            <button onclick="renderSpineCharacterInBB()">🎮 Spine自動表示</button>
            <button onclick="startBoundingBoxTest()">BB選択開始</button>
            <button onclick="testSafetyCheck()">🔍 安全性チェック</button>
            <button onclick="testParentResize()">📐 親要素リサイズテスト</button>
            <button onclick="showDebugInfo()">🛠️ デバッグ情報</button>
            <button onclick="diagnoseSpineState()">🔍 Spine読み込み診断</button>
            <button onclick="clearLog()">Log Clear</button>
        </div>
        
        <div>
            状態: 
            <span id="observer-status" class="status inactive">ElementObserver Inactive</span>
            <span id="bb-status" class="status inactive">BB Inactive</span>
            <span id="parent-status" class="status inactive">Parent Monitoring Inactive</span>
        </div>
        
        <!-- 🎯 メインテストエリア -->
        <div class="test-area" id="test-area">
            <div class="layout-anchor" id="test-target" style="left: 30%; top: 40%; width: 120px; height: 80px;">
                <div class="interactive">
                    <span>Test Element<br>🌊 Observer統合テスト</span>
                </div>
            </div>
        </div>
        
        <div id="log" class="log"></div>
        
        <!-- 🔍 Spine診断結果表示エリア -->
        <div id="spine-diagnosis-result" style="display: none; background: #f8f9fa; border: 2px solid #007cba; padding: 15px; border-radius: 8px; margin: 20px 0;">
            <!-- 診断結果がここに表示されます -->
        </div>
    </div>

    <!-- 🎮 Spine WebGLライブラリ（PureSpineLoader実行に必須） -->
    <script src="assets/js/libs/spine-webgl.js"></script>
    
    <!-- 🌊 ElementObserver マイクロモジュール -->
    <script src="micromodules/element-observer/ElementObserverCore.js"></script>
    <script src="micromodules/element-observer/ElementObserver.js"></script>
    
    <!-- 🎯 PureBoundingBox マイクロモジュール群 -->
    <script src="micromodules/bounding-box/PureBoundingBoxCore.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxBounds.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxUI.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxEvents.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBox.js"></script>
    
    <!-- 🎮 PureSpineLoader マイクロモジュール -->
    <script src="micromodules/spine-loader/PureSpineLoader.js"></script>
    
    <script>
        const logElement = document.getElementById('log');
        const observerStatusElement = document.getElementById('observer-status');
        const bbStatusElement = document.getElementById('bb-status');
        const parentStatusElement = document.getElementById('parent-status');
        
        let elementObserver = null;
        let currentBoundingBox = null;
        let parentUnobserve = null;
        let spineLoader = null;
        let currentSkeleton = null;
        let currentCanvas = null;
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const className = type;
            const logLine = `[${timestamp}] ${message}\n`;
            
            const span = document.createElement('span');
            span.className = className;
            span.textContent = logLine;
            logElement.appendChild(span);
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        function clearLog() {
            logElement.innerHTML = '';
        }
        
        function updateStatus(observerActive, bbActive, parentMonitoring) {
            observerStatusElement.textContent = observerActive ? 'ElementObserver Active' : 'ElementObserver Inactive';
            observerStatusElement.className = `status ${observerActive ? 'active' : 'inactive'}`;
            
            bbStatusElement.textContent = bbActive ? 'BB Active' : 'BB Inactive';
            bbStatusElement.className = `status ${bbActive ? 'active' : 'inactive'}`;
            
            parentStatusElement.textContent = parentMonitoring ? 'Parent Monitoring Active' : 'Parent Monitoring Inactive';
            parentStatusElement.className = `status ${parentMonitoring ? 'active' : 'inactive'}`;
        }
        
        // 🌊 ElementObserver初期化
        function initializeElementObserver() {
            log('=== ElementObserver初期化開始 ===', 'success');
            
            try {
                // ElementObserver作成
                elementObserver = new ElementObserver();
                
                const targetElement = document.getElementById('test-target');
                if (!targetElement) {
                    throw new Error('テスト要素が見つかりません');
                }
                
                // 親要素サイズ監視開始
                parentUnobserve = elementObserver.observeParentSize(targetElement, (parentRect, isValid) => {
                    log('📡 親要素変化通知:', 'debug');
                    log(`  サイズ: ${parentRect ? `${parentRect.width}x${parentRect.height}` : 'null'}`, 'debug');
                    log(`  有効: ${isValid}`, isValid ? 'success' : 'warning');
                    
                    updateStatus(true, currentBoundingBox?.core?.uiState?.visible || false, isValid);
                });
                
                log('✅ ElementObserver初期化完了', 'success');
                log('📐 親要素サイズ監視開始', 'info');
                
                updateStatus(true, false, true);
                
            } catch (error) {
                log(`❌ ElementObserver初期化エラー: ${error.message}`, 'error');
                updateStatus(false, false, false);
            }
        }
        
        // 🎯 BB選択開始テスト（ElementObserver統合版）
        async function startBoundingBoxTest() {
            log('=== BB選択開始テスト（ElementObserver統合版） ===', 'success');
            
            try {
                // ElementObserver事前チェック
                if (!elementObserver) {
                    log('⚠️ ElementObserver未初期化 - 自動初期化します', 'warning');
                    initializeElementObserver();
                    await new Promise(resolve => setTimeout(resolve, 100)); // 初期化待機
                }
                
                const targetElement = document.getElementById('test-target');
                if (!targetElement) {
                    throw new Error('テスト要素が見つかりません');
                }
                
                // 🔍 座標スワップ安全性チェック
                const safetyCheck = elementObserver.isSafeForCoordinateSwap(targetElement);
                log('🔍 座標スワップ安全性チェック:', 'debug');
                log(`  安全: ${safetyCheck.safe}`, safetyCheck.safe ? 'success' : 'warning');
                log(`  親要素: ${safetyCheck.parentSize}`, 'debug');
                log(`  対象要素: ${safetyCheck.targetSize}`, 'debug');
                if (safetyCheck.reason) {
                    log(`  理由: ${safetyCheck.reason}`, 'warning');
                }
                
                // 既存のBBがある場合はクリーンアップ
                if (currentBoundingBox) {
                    currentBoundingBox.cleanup();
                    currentBoundingBox = null;
                }
                
                // PureBoundingBoxインスタンス作成
                currentBoundingBox = new PureBoundingBox({
                    targetElement: targetElement,
                    nodeId: 'test-element-bb-observer'
                });
                
                log('🔧 PureBoundingBox作成完了（ElementObserver統合準備済み）');
                
                // 🌊 ElementObserverのcommitToPercent統合
                if (currentBoundingBox.core && elementObserver) {
                    // オリジナルcommitToPercentをバックアップ
                    currentBoundingBox.core._originalCommitToPercent = currentBoundingBox.core.commitToPercent;
                    
                    // ElementObserver統合版commitToPercentに置き換え
                    currentBoundingBox.core.commitToPercent = function() {
                        log('🌊 ElementObserver統合版commitToPercent開始', 'debug');
                        
                        // 安全性チェック
                        const safetyResult = elementObserver.isSafeForCoordinateSwap(targetElement);
                        if (!safetyResult.safe) {
                            log(`⚠️ 座標スワップが安全でないため処理をスキップ: ${safetyResult.reason}`, 'warning');
                            return false;
                        }
                        
                        // 安定した親要素矩形を取得
                        const stableParentRect = elementObserver.getStableParentRect(targetElement);
                        if (!stableParentRect) {
                            log('❌ 安定した親要素矩形を取得できません', 'error');
                            return false;
                        }
                        
                        log(`📐 安定親要素矩形取得: ${stableParentRect.width}x${stableParentRect.height}`, 'success');
                        
                        // オリジナル処理実行（ただし親要素矩形は安定版を使用）
                        // 注意: この統合は概念実証。実際の統合では親要素矩形の注入が必要
                        return this._originalCommitToPercent.call(this);
                    };
                    
                    log('🔧 commitToPercent統合完了', 'success');
                }
                
                // BB実行開始
                const result = await currentBoundingBox.execute({ visible: true });
                
                if (result.success) {
                    log('✅ BB実行成功（ElementObserver統合版）', 'success');
                    log(`  nodeId: ${result.nodeId}`, 'debug');
                    log(`  bounds: ${JSON.stringify(result.bounds)}`, 'debug');
                    updateStatus(true, true, true);
                    
                    // BB選択解除イベントリスナー
                    document.addEventListener('boundingBoxDeselected', onBoundingBoxDeselected);
                    log('📡 boundingBoxDeselectedイベントリスナー登録完了');
                    
                } else {
                    throw new Error(result.error || '不明なエラー');
                }
                
            } catch (error) {
                log(`❌ BB選択開始エラー: ${error.message}`, 'error');
                updateStatus(elementObserver ? true : false, false, false);
            }
        }
        
        // BB選択解除イベントハンドラー
        function onBoundingBoxDeselected(event) {
            log('=== BB選択解除イベント受信（ElementObserver統合版） ===', 'info');
            log(`  nodeId: ${event.detail.nodeId}`, 'debug');
            log(`  finalPosition: ${JSON.stringify(event.detail.finalPosition)}`, 'debug');
            log(`  timestamp: ${event.detail.timestamp}`, 'debug');
            
            updateStatus(elementObserver ? true : false, false, true);
            log('✅ BB選択解除イベント処理完了（ElementObserver統合版）', 'success');
        }
        
        // 🔍 安全性チェックテスト
        function testSafetyCheck() {
            if (!elementObserver) {
                log('⚠️ ElementObserver未初期化', 'warning');
                return;
            }
            
            const targetElement = document.getElementById('test-target');
            const result = elementObserver.isSafeForCoordinateSwap(targetElement);
            
            log('=== 座標スワップ安全性チェックテスト ===', 'debug');
            log(`安全: ${result.safe}`, result.safe ? 'success' : 'warning');
            log(`親要素有効: ${result.parentValid}`, result.parentValid ? 'success' : 'warning');
            log(`対象要素有効: ${result.targetValid}`, result.targetValid ? 'success' : 'warning');
            log(`親要素サイズ: ${result.parentSize}`, 'debug');
            log(`対象要素サイズ: ${result.targetSize}`, 'debug');
            if (result.reason) {
                log(`理由: ${result.reason}`, 'warning');
            }
        }
        
        // 📐 親要素リサイズテスト
        function testParentResize() {
            log('=== 親要素リサイズテスト ===', 'debug');
            
            const testArea = document.getElementById('test-area');
            const originalWidth = testArea.style.width;
            
            // リサイズ実行
            testArea.style.width = '600px';
            log('📐 親要素リサイズ実行: 800px → 600px', 'info');
            
            // 2秒後に元に戻す
            setTimeout(() => {
                testArea.style.width = originalWidth;
                log('📐 親要素リサイズ復旧: 600px → 800px', 'info');
            }, 2000);
        }
        
        // 🛠️ デバッグ情報表示
        function showDebugInfo() {
            if (!elementObserver) {
                log('⚠️ ElementObserver未初期化', 'warning');
                return;
            }
            
            const debugInfo = elementObserver.getDebugInfo();
            const targetElement = document.getElementById('test-target');
            const bbStatus = elementObserver.getBoundingBoxIntegrationStatus(targetElement);
            
            log('=== デバッグ情報 ===', 'debug');
            log(`ElementObserver: ${JSON.stringify(debugInfo, null, 2)}`, 'debug');
            log(`BB統合状況: ${JSON.stringify(bbStatus, null, 2)}`, 'debug');
        }

        // 🔍 Spine読み込み状態診断（手動実行版）
        function diagnoseSpineState() {
            log('=== 🔍 Spine読み込み状態診断（手動実行） ===', 'success');
            log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'debug');
            
            // 基本的なSpine定義チェック
            const spineExists = typeof spine !== 'undefined';
            log(`・spine定義: ${typeof spine}`, spineExists ? 'success' : 'error');
            
            // PureSpineLoaderと同じ検証条件を使用
            let spineValidationResult = false;
            let validationDetails = [];
            
            if (spineExists) {
                // window.spine も同時にチェック
                log(`・window.spine定義: ${typeof window.spine}`, typeof window.spine !== 'undefined' ? 'success' : 'info');
                
                // 必須クラスの存在確認（PureSpineLoaderと同じ条件）
                const requiredClasses = [
                    { name: 'AssetManager', path: 'spine.AssetManager' },
                    { name: 'SkeletonRenderer', path: 'spine.SkeletonRenderer' },
                    { name: 'PolygonBatcher', path: 'spine.PolygonBatcher' },
                    { name: 'Skeleton', path: 'spine.Skeleton' },
                    { name: 'AnimationState', path: 'spine.AnimationState' },
                    { name: 'AtlasAttachmentLoader', path: 'spine.AtlasAttachmentLoader' }
                ];
                
                let allClassesPresent = true;
                
                requiredClasses.forEach(cls => {
                    const exists = eval(`typeof ${cls.path}`) !== 'undefined';
                    log(`・${cls.name}: ${eval(`typeof ${cls.path}`)}`, exists ? 'success' : 'error');
                    validationDetails.push(`${cls.name}: ${exists ? '✅' : '❌'}`);
                    if (!exists) allClassesPresent = false;
                });
                
                // 追加の重要クラスチェック
                const additionalClasses = [
                    { name: 'SkeletonJson', path: 'spine.SkeletonJson' },
                    { name: 'AnimationStateData', path: 'spine.AnimationStateData' }
                ];
                
                log('', 'debug'); // 空行
                log('📦 追加Spineクラスチェック:', 'info');
                
                additionalClasses.forEach(cls => {
                    const exists = eval(`typeof ${cls.path}`) !== 'undefined';
                    log(`・${cls.name}: ${eval(`typeof ${cls.path}`)}`, exists ? 'success' : 'error');
                    if (!exists) allClassesPresent = false;
                });
                
                spineValidationResult = allClassesPresent;
                
                if (!allClassesPresent) {
                    log('❌ 必須Spineクラスが不足しています', 'error');
                    log('💡 解決策: spine-webgl.jsの完全な読み込みを確認してください', 'info');
                }
                
            } else {
                log('❌ spine オブジェクトが未定義です', 'error');
                log('💡 解決策: Spine WebGLライブラリが正しく読み込まれているか確認してください', 'info');
                validationDetails.push('spine: ❌');
            }
            
            log('', 'debug'); // 空行
            log('🌐 WebGL対応チェック:', 'info');
            
            // WebGL対応チェック
            const testCanvas = document.createElement('canvas');
            const webglContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
            const webglSupported = !!webglContext;
            
            log(`・WebGL対応: ${webglSupported}`, webglSupported ? 'success' : 'error');
            
            if (webglContext) {
                try {
                    const version = webglContext.getParameter(webglContext.VERSION);
                    const renderer = webglContext.getParameter(webglContext.RENDERER);
                    const vendor = webglContext.getParameter(webglContext.VENDOR);
                    
                    log(`  WebGLバージョン: ${version}`, 'debug');
                    log(`  レンダラー: ${renderer}`, 'debug');
                    log(`  ベンダー: ${vendor}`, 'debug');
                } catch (e) {
                    log(`  WebGL情報取得エラー: ${e.message}`, 'warning');
                }
                
                // WebGLコンテキスト破棄
                const loseContext = webglContext.getExtension('WEBGL_lose_context');
                if (loseContext) {
                    loseContext.loseContext();
                }
            } else {
                log('❌ WebGLがサポートされていません', 'error');
                log('💡 解決策: WebGL対応ブラウザを使用してください', 'info');
            }
            
            log('', 'debug'); // 空行
            log('🎮 PureSpineLoaderチェック:', 'info');
            
            // PureSpineLoaderチェック
            const loaderExists = typeof PureSpineLoader !== 'undefined';
            log(`・PureSpineLoader: ${typeof PureSpineLoader}`, loaderExists ? 'success' : 'error');
            
            if (!loaderExists) {
                log('❌ PureSpineLoaderが読み込まれていません', 'error');
                log('💡 解決策: PureSpineLoader.jsの読み込みを確認してください', 'info');
            }
            
            log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'debug');
            
            // PureSpineLoaderと同じ総合判定ロジック
            const allOk = spineExists && spineValidationResult && webglSupported && loaderExists;
            
            if (allOk) {
                log('✅ 診断結果: Spine WebGLシステム準備完了', 'success');
                log('🎯 「🎮 Spine自動表示」ボタンでSpine表示をテストできます', 'info');
            } else {
                log('❌ 診断結果: Spine WebGLシステムに問題があります', 'error');
                log('🔧 上記のエラー項目を修正してから再試行してください', 'warning');
            }
            
            // 診断結果をページ上に表示
            const resultDiv = document.getElementById('spine-diagnosis-result');
            if (resultDiv) {
                resultDiv.innerHTML = `
                    <h4>🔍 Spine診断結果 (${new Date().toLocaleTimeString()})</h4>
                    <p><strong>Spine定義:</strong> ${spineExists ? '✅' : '❌'}</p>
                    <p><strong>必須クラス:</strong> ${spineValidationResult ? '✅' : '❌'}</p>
                    <p><strong>WebGL対応:</strong> ${webglSupported ? '✅' : '❌'}</p>
                    <p><strong>PureSpineLoader:</strong> ${loaderExists ? '✅' : '❌'}</p>
                    <p><strong>総合判定:</strong> ${allOk ? '🎯 準備完了' : '🔧 修正必要'}</p>
                    <p><strong>検証詳細:</strong> ${validationDetails.join(', ')}</p>
                `;
                resultDiv.style.display = 'block';
            }
            
            log('📋 診断完了', 'info');
        }
        
        // オリジナルのconsoleをラップ
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;
        
        console.log = function(...args) {
            originalLog.apply(console, args);
            if (!args.join(' ').includes('👁️') || args.join(' ').includes('ElementObserver') || args.join(' ').includes('BB')) {
                log(args.join(' '), 'info');
            }
        };
        
        console.error = function(...args) {
            originalError.apply(console, args);
            log(args.join(' '), 'error');
        };
        
        console.warn = function(...args) {
            originalWarn.apply(console, args);
            log(args.join(' '), 'warning');
        };
        
        // 🎮 Spine キャラクター表示関数（BB内Canvas統合版）
        async function renderSpineCharacterInBB() {
            log('=== Spine キャラクター表示開始（BB内Canvas統合版） ===', 'success');
            
            try {
                // 📋 解決策1: BB要素内の既存Canvas検索・作成
                const testTarget = document.getElementById('test-target');
                if (!testTarget) {
                    throw new Error('test-target 要素が見つかりません');
                }
                
                log('🎯 BB内Canvas準備開始', 'info');
                
                // 既存のSpineがある場合はクリーンアップ
                if (currentCanvas && currentCanvas.parentNode) {
                    currentCanvas.parentNode.removeChild(currentCanvas);
                    currentCanvas = null;
                }
                if (currentSkeleton) {
                    currentSkeleton = null;
                }
                
                // BB要素内に既存のCanvasがないか確認
                let existingCanvas = testTarget.querySelector('canvas');
                if (existingCanvas) {
                    log('♻️ 既存Canvas発見 - 削除して新規作成', 'info');
                    existingCanvas.remove();
                }
                
                // 📋 解決策2: Spine読み込み状態の診断（必須クラスチェック）
                log('🔍 Spine読み込み状態診断開始:', 'info');
                log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', 'debug');
                
                const spineExists = typeof spine !== 'undefined';
                log(`・spine定義: ${typeof spine}`, spineExists ? 'success' : 'error');
                
                let spineValidationResult = false;
                if (spineExists) {
                    // 必須クラスの存在確認
                    const requiredClasses = [
                        { name: 'AssetManager', path: 'spine.AssetManager' },
                        { name: 'SkeletonRenderer', path: 'spine.SkeletonRenderer' },
                        { name: 'PolygonBatcher', path: 'spine.PolygonBatcher' },
                        { name: 'Skeleton', path: 'spine.Skeleton' },
                        { name: 'AnimationState', path: 'spine.AnimationState' },
                        { name: 'AtlasAttachmentLoader', path: 'spine.AtlasAttachmentLoader' },
                        { name: 'SkeletonJson', path: 'spine.SkeletonJson' },
                        { name: 'AnimationStateData', path: 'spine.AnimationStateData' }
                    ];
                    
                    let allClassesPresent = true;
                    requiredClasses.forEach(cls => {
                        const exists = eval(`typeof ${cls.path}`) !== 'undefined';
                        log(`・${cls.name}: ${eval(`typeof ${cls.path}`)}`, exists ? 'success' : 'error');
                        if (!exists) allClassesPresent = false;
                    });
                    
                    spineValidationResult = allClassesPresent;
                    
                    if (!allClassesPresent) {
                        throw new Error('必須Spineクラスが不足しています');
                    }
                } else {
                    throw new Error('spine オブジェクトが未定義です');
                }
                
                // WebGL対応チェック
                const testCanvas = document.createElement('canvas');
                const webglContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
                const webglSupported = !!webglContext;
                log(`・WebGL対応: ${webglSupported}`, webglSupported ? 'success' : 'error');
                
                if (!webglSupported) {
                    throw new Error('WebGLがサポートされていません');
                }
                
                // PureSpineLoaderチェック
                const loaderExists = typeof PureSpineLoader !== 'undefined';
                log(`・PureSpineLoader: ${typeof PureSpineLoader}`, loaderExists ? 'success' : 'error');
                
                if (!loaderExists) {
                    throw new Error('PureSpineLoader が読み込まれていません');
                }
                
                log('✅ Spine WebGLシステム準備完了', 'success');
                
                // Spineファイル設定
                const spineConfig = {
                    basePath: '/assets/spine/characters/purattokun/',
                    atlasPath: '/assets/spine/characters/purattokun/purattokun.atlas',
                    jsonPath: '/assets/spine/characters/purattokun/purattokun.json',
                    scale: 1.0
                };
                
                // PureSpineLoaderインスタンス作成
                spineLoader = new PureSpineLoader(spineConfig);
                
                log('📁 Spineファイル読み込み開始:', 'info');
                log(`  JSON: ${spineConfig.jsonPath}`, 'debug');
                log(`  Atlas: ${spineConfig.atlasPath}`, 'debug');
                
                // Spine読み込み実行
                const result = await spineLoader.execute();
                
                if (!result.loaded) {
                    throw new Error(result.error || 'Spine読み込みに失敗しました');
                }
                
                log('✅ Spineデータ読み込み完了', 'success');
                log(`  Atlas: ${result.atlas ? '✅' : '❌'}`, 'debug');
                log(`  SkeletonData: ${result.skeletonData ? '✅' : '❌'}`, 'debug');
                
                // 📋 解決策3: BB要素内にCanvasを作成（位置固定）
                currentCanvas = document.createElement('canvas');
                
                // BB要素のサイズに合わせてCanvas設定
                const targetRect = testTarget.getBoundingClientRect();
                currentCanvas.width = targetRect.width || 120;  // test-targetのwidth
                currentCanvas.height = targetRect.height || 80; // test-targetのheight
                
                log(`📐 Canvas サイズ設定: ${currentCanvas.width}x${currentCanvas.height}`, 'debug');
                
                // Canvasスタイル設定（BB内配置）
                currentCanvas.className = 'spine-canvas';
                currentCanvas.style.position = 'absolute';
                currentCanvas.style.top = '0';
                currentCanvas.style.left = '0';
                currentCanvas.style.width = '100%';
                currentCanvas.style.height = '100%';
                currentCanvas.style.pointerEvents = 'none';
                currentCanvas.style.zIndex = '5';  // BB内表示用
                
                // test-target要素内に追加（重要：test-area ではなく test-target 内）
                testTarget.appendChild(currentCanvas);
                
                log('✅ Canvas をBB要素内に配置完了', 'success');
                
                // WebGLコンテキスト作成
                const gl = currentCanvas.getContext('webgl') || currentCanvas.getContext('experimental-webgl');
                if (!gl) {
                    throw new Error('WebGLコンテキストの作成に失敗しました');
                }
                
                log('🎯 WebGLコンテキスト作成完了', 'success');
                
                // SpineWebGL初期化
                const mvp = new spine.Matrix4();
                const shader = spine.Shader.newTwoColoredTextured(gl);
                const batcher = new spine.PolygonBatcher(gl);
                const skeletonRenderer = new spine.SkeletonRenderer(gl);
                const assetManager = new spine.AssetManager(gl);
                
                // アセット読み込み
                assetManager.loadTextureAtlas(spineConfig.atlasPath);
                assetManager.loadText(spineConfig.jsonPath);
                
                log('📦 SpineWebGL AssetManager初期化完了', 'debug');
                
                // アセット読み込み完了を待機
                const assetsLoaded = await new Promise((resolve) => {
                    const checkAssets = () => {
                        if (assetManager.isLoadingComplete()) {
                            resolve(true);
                        } else {
                            setTimeout(checkAssets, 50);
                        }
                    };
                    checkAssets();
                });
                
                if (!assetsLoaded) {
                    throw new Error('SpineWebGL アセット読み込みに失敗しました');
                }
                
                log('✅ SpineWebGL アセット読み込み完了', 'success');
                
                // 📋 解決策4: Skeleton作成の安全性確保
                const atlas = assetManager.get(spineConfig.atlasPath);
                if (!atlas) {
                    throw new Error('Atlasの取得に失敗しました');
                }
                
                const atlasLoader = new spine.AtlasAttachmentLoader(atlas);
                if (!atlasLoader) {
                    throw new Error('AtlasAttachmentLoaderの作成に失敗しました');
                }
                
                const skeletonJson = new spine.SkeletonJson(atlasLoader);
                if (!skeletonJson) {
                    throw new Error('SkeletonJsonの作成に失敗しました');
                }
                
                const skeletonDataText = assetManager.get(spineConfig.jsonPath);
                if (!skeletonDataText) {
                    throw new Error('SkeletonDataテキストの取得に失敗しました');
                }
                
                const skeletonData = skeletonJson.readSkeletonData(skeletonDataText);
                if (!skeletonData) {
                    throw new Error('SkeletonDataの作成に失敗しました');
                }
                
                // Skeleton作成（nullチェック強化）
                currentSkeleton = new spine.Skeleton(skeletonData);
                if (!currentSkeleton) {
                    throw new Error('Skeletonの作成に失敗しました');
                }
                
                const animationStateData = new spine.AnimationStateData(skeletonData);
                if (!animationStateData) {
                    throw new Error('AnimationStateDataの作成に失敗しました');
                }
                
                const animationState = new spine.AnimationState(animationStateData);
                if (!animationState) {
                    throw new Error('AnimationStateの作成に失敗しました');
                }
                
                // BB要素サイズに合わせた初期位置設定
                currentSkeleton.x = currentCanvas.width / 2;  // Canvas中央X
                currentSkeleton.y = currentCanvas.height / 2; // Canvas中央Y
                currentSkeleton.scaleX = 0.3;  // BB内表示に適したスケール
                currentSkeleton.scaleY = 0.3;
                
                log('🎯 Skeleton初期化完了:', 'success');
                log(`  位置: (${currentSkeleton.x}, ${currentSkeleton.y})`, 'debug');
                log(`  スケール: ${currentSkeleton.scaleX}`, 'debug');
                
                // アニメーション設定
                animationState.setAnimation(0, 'taiki', true);
                log('🎬 アニメーション設定: taiki (ループ)', 'success');
                
                // 📋 解決策5: 描画ループの安全性確保
                let lastFrameTime = Date.now() / 1000;
                const renderLoop = () => {
                    try {
                        // 必須オブジェクトのnullチェック
                        if (!currentSkeleton) {
                            log('❌ renderLoop: Skeleton が null です', 'error');
                            return; // ループ停止
                        }
                        
                        if (!animationState) {
                            log('❌ renderLoop: AnimationState が null です', 'error');
                            return; // ループ停止
                        }
                        
                        if (!gl || gl.isContextLost()) {
                            log('❌ renderLoop: WebGLコンテキストが無効です', 'error');
                            return; // ループ停止
                        }
                        
                        const now = Date.now() / 1000;
                        const deltaTime = now - lastFrameTime;
                        lastFrameTime = now;
                        
                        // アニメーション更新（安全性チェック付き）
                        animationState.update(deltaTime);
                        animationState.apply(currentSkeleton); // ここで skeleton null エラーが発生していた
                        currentSkeleton.updateWorldTransform();
                        
                        // 画面クリア
                        gl.clearColor(0, 0, 0, 0); // 透明背景
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        
                        // 描画設定
                        mvp.ortho2d(0, 0, currentCanvas.width, currentCanvas.height);
                        gl.viewport(0, 0, currentCanvas.width, currentCanvas.height);
                        
                        // Skeleton描画
                        shader.bind();
                        shader.setUniformi(spine.Shader.SAMPLER, 0);
                        shader.setUniform4x4f(spine.Shader.MVP_MATRIX, mvp.values);
                        
                        batcher.begin(shader);
                        skeletonRenderer.draw(batcher, currentSkeleton);
                        batcher.end();
                        
                        shader.unbind();
                        
                        // 次フレーム予約
                        requestAnimationFrame(renderLoop);
                        
                    } catch (renderError) {
                        log(`❌ renderLoop エラー: ${renderError.message}`, 'error');
                        console.error('RenderLoop詳細エラー:', renderError);
                        // エラー時はループを停止
                    }
                };
                
                // 描画ループ開始
                renderLoop();
                
                log('✅ Spine WebGL描画ループ開始', 'success');
                log('🎮 ぷらっとくんがBB要素内に表示されているはずです', 'success');
                log('🔧 BB編集時：キャラクターがBBと一緒に移動します', 'info');
                
            } catch (error) {
                log(`❌ Spine キャラクター表示エラー: ${error.message}`, 'error');
                console.error('Spine表示エラー詳細:', error);
                
                // エラー時のクリーンアップ
                if (currentCanvas && currentCanvas.parentNode) {
                    currentCanvas.parentNode.removeChild(currentCanvas);
                    currentCanvas = null;
                }
                currentSkeleton = null;
            }
        }
        
        // ページ読み込み時
        window.addEventListener('load', async () => {
            log('🌐 ElementObserver×PureBoundingBox統合テストページ読み込み完了');
            log('');
            log('🎯 統合テスト目標:');
            log('  1. 親要素サイズ0問題の完全解決');
            log('  2. 座標スワップ安全性の事前チェック');
            log('  3. リアルタイム要素監視との連携');
            log('  4. commitToPercent()の安定実行');
            log('  5. BB外クリック選択解除の完全保持');
            log('  6. 🆕 Spine自動読み込み・BB統合表示');
            log('');
            log('🚀 自動初期化開始...');
            
            // 自動初期化シーケンス
            try {
                // ElementObserver初期化
                initializeElementObserver();
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Spine自動表示
                await renderSpineCharacterInBB();
                
                log('✅ 自動初期化完了 - テスト準備OK', 'success');
                log('▶️ 手動テスト: 「BB選択開始」でBB編集モード開始', 'info');
                
            } catch (error) {
                log(`⚠️ 自動初期化でエラー: ${error.message}`, 'warning');
                log('▶️ 手動操作で各機能をテストしてください', 'info');
            }
        });
        
        // クリーンアップ
        window.addEventListener('beforeunload', () => {
            // Spine関連のクリーンアップ
            if (currentCanvas && currentCanvas.parentNode) {
                currentCanvas.parentNode.removeChild(currentCanvas);
            }
            if (spineLoader) {
                spineLoader.cleanup();
            }
            
            // 既存のクリーンアップ
            if (currentBoundingBox) {
                currentBoundingBox.cleanup();
            }
            if (parentUnobserve) {
                parentUnobserve();
            }
            if (elementObserver) {
                elementObserver.cleanup();
            }
        });
    </script>
</body>
</html>