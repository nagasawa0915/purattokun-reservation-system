<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ElementObserver Phase 2統合テスト - 高度座標系統合</title>
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            margin: 0;
            touch-action: none;
            color: white;
        }
        .test-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 15px;
            max-width: 1400px;
            margin: 0 auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .test-area {
            position: relative;
            width: 1000px;
            height: 600px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.3);
            margin: 20px auto;
            border-radius: 15px;
            touch-action: none;
            overflow: hidden;
        }
        .layout-anchor {
            position: absolute;
            background: rgba(255, 107, 107, 0.4);
            border: 2px solid #ff6b6b;
            border-radius: 10px;
            transform: translate(-50%, -50%);
            touch-action: none;
            transition: all 0.2s ease;
        }
        .interactive {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transform: translate(var(--tx, 0), var(--ty, 0)) scale(var(--scale, 1)) rotate(var(--rotation, 0deg));
            touch-action: none;
        }
        .canvas-element {
            border: 2px solid #4ecdc4;
            border-radius: 8px;
            background: rgba(78, 205, 196, 0.2);
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .control-group h3 {
            margin: 0 0 10px 0;
            color: #feca57;
            font-size: 16px;
        }
        button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 15px;
            margin: 3px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        button.primary {
            background: rgba(78, 205, 196, 0.3);
            border-color: #4ecdc4;
        }
        button.secondary {
            background: rgba(255, 107, 107, 0.3);
            border-color: #ff6b6b;
        }
        .coordinate-display {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        .coord-system {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 11px;
        }
        .coord-system h4 {
            margin: 0 0 5px 0;
            color: #feca57;
            font-size: 12px;
        }
        .coord-value {
            color: #4ecdc4;
            font-family: monospace;
        }
        .log {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 15px;
            margin: 20px 0;
            border-radius: 10px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            font-size: 12px;
        }
        .success { color: #26de81; }
        .error { color: #fc5c65; }
        .warning { color: #fed330; }
        .info { color: #45aaf2; }
        .debug { color: #a55eea; }
        .status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 11px;
            margin: 0 5px;
            font-weight: bold;
        }
        .status.active {
            background: rgba(38, 222, 129, 0.3);
            color: #26de81;
            border: 1px solid #26de81;
        }
        .status.inactive {
            background: rgba(252, 92, 101, 0.3);
            color: #fc5c65;
            border: 1px solid #fc5c65;
        }
        .instructions {
            background: rgba(69, 170, 242, 0.2);
            border: 1px solid #45aaf2;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        .instructions h3 {
            margin-top: 0;
            color: #45aaf2;
        }
        .phase-indicator {
            background: linear-gradient(45deg, #667eea, #764ba2);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        .phase-indicator h1 {
            margin: 0;
            font-size: 24px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="phase-indicator">
            <h1>🚀 ElementObserver Phase 2統合テスト</h1>
            <p>高度座標系統合システム - 5つの座標系完全同期テスト</p>
        </div>
        
        <div class="instructions">
            <h3>📝 Phase 2統合テスト項目</h3>
            <ol>
                <li><strong>5座標系統合初期化</strong> - DOM・Transform・WebGL・Skeleton・Canvas座標の統合管理</li>
                <li><strong>統一座標API</strong> - `setUnifiedPosition()`による全座標系自動同期</li>
                <li><strong>座標系間変換</strong> - DOM⟷WebGL・%⟷px変換の双方向対応</li>
                <li><strong>レスポンシブWebGL</strong> - CSS表示サイズとWebGL描画バッファの分離管理</li>
                <li><strong>PureBoundingBox高度統合</strong> - Phase 2機能による次世代BB制御</li>
                <li><strong>リアルタイム同期</strong> - 全座標系の120fps同期・変化監視</li>
            </ol>
            <p><strong>🎯 期待結果</strong>：全座標系が完全同期し、1つの変更が自動的に全座標系に反映される</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3>🚀 Phase 2初期化</h3>
                <button class="primary" onclick="initializePhase2()">Phase 2高度初期化</button>
                <button onclick="createTestElements()">テスト要素作成</button>
                <button onclick="showPhase2Status()">Phase 2状態確認</button>
            </div>
            
            <div class="control-group">
                <h3>🎯 統一座標API</h3>
                <button onclick="testUnifiedPosition()">統一座標テスト</button>
                <button onclick="testCoordinateConversion()">座標変換テスト</button>
                <button onclick="animateCoordinates()">座標アニメーション</button>
            </div>
            
            <div class="control-group">
                <h3>🌐 WebGL統合</h3>
                <button onclick="testWebGLSync()">WebGL同期テスト</button>
                <button onclick="testSkeletonSync()">Skeleton同期</button>
                <button onclick="testCanvasMatrix()">Canvas Matrix</button>
            </div>
            
            <div class="control-group">
                <h3>📱 レスポンシブテスト</h3>
                <button onclick="testResponsiveCanvas()">レスポンシブCanvas</button>
                <button onclick="testDPRChange()">DPR変化テスト</button>
                <button onclick="testBreakpoints()">ブレークポイント</button>
            </div>
            
            <div class="control-group">
                <h3>🎮 BB高度統合</h3>
                <button onclick="startAdvancedBoundingBox()">Phase 2 BB開始</button>
                <button onclick="testAdvancedCommit()">高度コミット</button>
                <button onclick="testBBSync()">BB座標同期</button>
            </div>
            
            <div class="control-group">
                <h3>📊 パフォーマンス測定</h3>
                <button class="primary" onclick="startPerformanceMonitoring()">測定開始</button>
                <button onclick="measureSetUnifiedPosition()">setUnifiedPosition測定</button>
                <button onclick="measureFPS()">FPS測定</button>
                <button class="secondary" onclick="stopPerformanceMonitoring()">測定停止</button>
            </div>
            
            <div class="control-group">
                <h3>⚡ Phase 3-A最適化</h3>
                <button class="primary" onclick="enableOptimizations()">最適化ON</button>
                <button onclick="disableOptimizations()">最適化OFF</button>
                <button onclick="comparePerformance()">最適化効果比較</button>
                <button onclick="showOptimizationStats()">最適化統計</button>
            </div>
            
            <div class="control-group">
                <h3>🛠️ デバッグ・制御</h3>
                <button onclick="showCoordinateSystems()">全座標系表示</button>
                <button onclick="showAdvancedDebugInfo()">詳細デバッグ</button>
                <button onclick="clearLog()">ログクリア</button>
            </div>
        </div>
        
        <div>
            Phase 2状態: 
            <span id="phase2-status" class="status inactive">Phase 2 Inactive</span>
            <span id="transform-status" class="status inactive">Transform Inactive</span>
            <span id="webgl-status" class="status inactive">WebGL Inactive</span>
            <span id="responsive-status" class="status inactive">Responsive Inactive</span>
            <span id="sync-status" class="status inactive">Sync Inactive</span>
        </div>
        
        <div style="margin-top: 10px;">
            📊 パフォーマンス: 
            <span id="performance-status" class="status inactive">Monitoring Inactive</span>
            <span id="fps-display" class="status inactive">FPS: --</span>
            <span id="memory-status" class="status inactive">Memory: --</span>
        </div>
        
        <!-- 5座標系リアルタイム表示 -->
        <div class="coordinate-display" id="coordinate-display">
            <div class="coord-system">
                <h4>📐 DOM座標系</h4>
                <div class="coord-value" id="dom-coords">未初期化</div>
            </div>
            <div class="coord-system">
                <h4>🎯 Transform座標系</h4>
                <div class="coord-value" id="transform-coords">未初期化</div>
            </div>
            <div class="coord-system">
                <h4>🌐 WebGL座標系</h4>
                <div class="coord-value" id="webgl-coords">未初期化</div>
            </div>
            <div class="coord-system">
                <h4>🎮 Skeleton座標系</h4>
                <div class="coord-value" id="skeleton-coords">未初期化</div>
            </div>
            <div class="coord-system">
                <h4>📱 Canvas座標系</h4>
                <div class="coord-value" id="canvas-coords">未初期化</div>
            </div>
        </div>
        
        <!-- 🎯 メインテストエリア -->
        <div class="test-area" id="test-area">
            <!-- テスト要素は動的に作成 -->
        </div>
        
        <div id="log" class="log"></div>
    </div>

    <!-- 🚀 ElementObserver Phase 2 マイクロモジュール群 -->
    <!-- Phase 1基本機能 -->
    <script src="micromodules/element-observer/ElementObserverCore.js"></script>
    <script src="micromodules/element-observer/ElementObserver.js"></script>
    
    <!-- Phase 2高度機能 -->
    <script src="micromodules/element-observer/ElementObserverTransform.js"></script>
    <script src="micromodules/element-observer/ElementObserverWebGL.js"></script>
    <script src="micromodules/element-observer/ElementObserverResponsive.js"></script>
    <script src="micromodules/element-observer/ElementObserverAdvanced.js"></script>
    
    <!-- 🎯 PureBoundingBox マイクロモジュール群 -->
    <script src="micromodules/bounding-box/PureBoundingBoxCore.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxBounds.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxUI.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxEvents.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBox.js"></script>
    
    <!-- ✨ Phase 2統合テストシステム -->
    <script>
        // グローバル変数
        let elementObserverAdvanced = null;
        let currentBoundingBox = null;
        let testElements = {};
        let animationId = null;
        let coordinateUpdateInterval = null;
        
        // パフォーマンス測定システム
        let performanceMonitoring = {
            isActive: false,
            fpsMonitoring: false,
            fpsFrameCount: 0,
            fpsStartTime: null,
            currentFPS: 0,
            measurementData: [],
            fpsAnimationId: null
        };
        
        // Phase 3-A最適化制御システム
        let phase3AOptimization = {
            enabled: false,
            comparisonData: {
                optimizedResults: [],
                unoptimizedResults: []
            },
            currentMode: 'unoptimized'
        };
        
        const logElement = document.getElementById('log');
        const statusElements = {
            phase2: document.getElementById('phase2-status'),
            transform: document.getElementById('transform-status'),
            webgl: document.getElementById('webgl-status'),
            responsive: document.getElementById('responsive-status'),
            sync: document.getElementById('sync-status'),
            performance: document.getElementById('performance-status'),
            fps: document.getElementById('fps-display'),
            memory: document.getElementById('memory-status')
        };
        
        // ログ関数
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const className = type;
            const logLine = `[${timestamp}] ${message}\n`;
            
            const span = document.createElement('span');
            span.className = className;
            span.textContent = logLine;
            logElement.appendChild(span);
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        function clearLog() {
            logElement.innerHTML = '';
        }
        
        // ステータス更新
        function updateStatus(elementName, isActive) {
            const element = statusElements[elementName];
            if (element) {
                element.textContent = isActive ? 
                    elementName.charAt(0).toUpperCase() + elementName.slice(1) + ' Active' : 
                    elementName.charAt(0).toUpperCase() + elementName.slice(1) + ' Inactive';
                element.className = `status ${isActive ? 'active' : 'inactive'}`;
            }
        }
        
        // テスト要素作成
        function createTestElements() {
            log('=== テスト要素作成開始 ===', 'success');
            
            const testArea = document.getElementById('test-area');
            
            // Layout Anchor + Interactive Layer作成
            const layoutAnchor = document.createElement('div');
            layoutAnchor.id = 'test-layout-anchor';
            layoutAnchor.className = 'layout-anchor';
            layoutAnchor.style.left = '40%';
            layoutAnchor.style.top = '50%';
            layoutAnchor.style.width = '150px';
            layoutAnchor.style.height = '100px';
            
            const interactive = document.createElement('div');
            interactive.className = 'interactive';
            
            // Canvas要素作成（WebGL用）
            const canvas = document.createElement('canvas');
            canvas.id = 'test-canvas';
            canvas.className = 'canvas-element';
            canvas.width = 120;
            canvas.height = 80;
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            
            // Canvas内容設定
            const ctx = canvas.getContext('2d');
            if (ctx) {
                // 簡易描画（WebGLの代替）
                ctx.fillStyle = 'rgba(78, 205, 196, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Test Canvas', canvas.width/2, canvas.height/2);
            }
            
            interactive.appendChild(canvas);
            layoutAnchor.appendChild(interactive);
            testArea.appendChild(layoutAnchor);
            
            // 疑似Skeleton・Renderer作成（テスト用）
            testElements = {
                targetElement: layoutAnchor,
                canvas: canvas,
                skeleton: {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    scaleX: 1,
                    scaleY: 1,
                    updateWorldTransform: () => {},
                    getBounds: () => ({ x: 0, y: 0, width: 100, height: 80 })
                },
                renderer: {
                    camera: {
                        position: { x: canvas.width / 2, y: canvas.height / 2 },
                        zoom: 1.0,
                        setViewport: (w, h) => {}
                    },
                    canvas: canvas
                }
            };
            
            log('✅ テスト要素作成完了', 'success');
            log(`  Layout Anchor: ${layoutAnchor.id}`, 'info');
            log(`  Canvas: ${canvas.id} (${canvas.width}x${canvas.height})`, 'info');
            log('  疑似Skeleton・Renderer作成完了', 'info');
        }
        
        // 🚀 Phase 2高度初期化
        async function initializePhase2() {
            log('=== ElementObserver Phase 2高度初期化開始 ===', 'success');
            
            try {
                // テスト要素確認
                if (!testElements.targetElement) {
                    log('⚠️ テスト要素未作成 - 自動作成します', 'warning');
                    createTestElements();
                }
                
                // ElementObserverAdvanced作成
                elementObserverAdvanced = new ElementObserverAdvanced();
                
                // Phase 2高度初期化
                const initialized = await elementObserverAdvanced.initializeAdvanced(
                    testElements.targetElement,
                    testElements.canvas,
                    testElements.skeleton,
                    testElements.renderer,
                    {
                        cssWidth: '25%',
                        cssHeight: '25%',
                        bufferWidth: 512,
                        bufferHeight: 512,
                        quality: 'high'
                    }
                );
                
                if (initialized) {
                    // 統合変化監視開始
                    elementObserverAdvanced.onIntegrationChange((event) => {
                        log(`🔄 統合変化検出: ${event.type}`, 'debug');
                        updateCoordinateDisplay();
                    });
                    
                    // リアルタイム座標表示開始
                    startCoordinateDisplay();
                    
                    // ステータス更新
                    updateStatus('phase2', true);
                    updateStatus('transform', !!elementObserverAdvanced.transform);
                    updateStatus('webgl', !!elementObserverAdvanced.webgl);
                    updateStatus('responsive', !!elementObserverAdvanced.responsive);
                    updateStatus('sync', true);
                    
                    log('✅ ElementObserver Phase 2初期化完了', 'success');
                    log('🎯 5座標系統合システム作動開始', 'success');
                    
                } else {
                    throw new Error('Phase 2初期化失敗');
                }
                
            } catch (error) {
                log(`❌ Phase 2初期化エラー: ${error.message}`, 'error');
                updateStatus('phase2', false);
            }
        }
        
        // 統一座標テスト
        function testUnifiedPosition() {
            if (!elementObserverAdvanced || !elementObserverAdvanced.integrationState.initialized) {
                log('⚠️ Phase 2未初期化', 'warning');
                return;
            }
            
            log('=== 統一座標APIテスト開始 ===', 'success');
            
            const testPositions = [
                { x: 30, y: 40, unit: '%', name: '左上' },
                { x: 70, y: 40, unit: '%', name: '右上' },
                { x: 70, y: 70, unit: '%', name: '右下' },
                { x: 30, y: 70, unit: '%', name: '左下' },
                { x: 50, y: 50, unit: '%', name: '中央' }
            ];
            
            let index = 0;
            const moveNext = () => {
                if (index >= testPositions.length) {
                    log('✅ 統一座標APIテスト完了', 'success');
                    return;
                }
                
                const pos = testPositions[index];
                log(`🎯 統一座標設定: ${pos.name} (${pos.x}${pos.unit}, ${pos.y}${pos.unit})`, 'info');
                
                const success = elementObserverAdvanced.setUnifiedPosition(pos.x, pos.y, pos.unit);
                if (success) {
                    log(`✅ ${pos.name}移動完了 - 全座標系同期確認`, 'success');
                } else {
                    log(`❌ ${pos.name}移動失敗`, 'error');
                }
                
                index++;
                setTimeout(moveNext, 1500);
            };
            
            moveNext();
        }
        
        // 座標変換テスト
        function testCoordinateConversion() {
            if (!elementObserverAdvanced || !elementObserverAdvanced.integrationState.initialized) {
                log('⚠️ Phase 2未初期化', 'warning');
                return;
            }
            
            log('=== 座標系間変換テスト開始 ===', 'success');
            
            const testCoords = { x: 50, y: 60, unit: '%' };
            
            // DOM → WebGL
            const webglCoords = elementObserverAdvanced.convertBetweenCoordinateSystems(
                'dom', 'webgl', testCoords
            );
            log(`DOM→WebGL変換: (${testCoords.x}%, ${testCoords.y}%) → (${webglCoords.x.toFixed(1)}, ${webglCoords.y.toFixed(1)})`, 'info');
            
            // WebGL → DOM
            const domCoords = elementObserverAdvanced.convertBetweenCoordinateSystems(
                'webgl', 'dom', webglCoords
            );
            log(`WebGL→DOM変換: (${webglCoords.x.toFixed(1)}, ${webglCoords.y.toFixed(1)}) → (${domCoords.x.toFixed(1)}%, ${domCoords.y.toFixed(1)}%)`, 'info');
            
            // % → px
            const pixelCoords = elementObserverAdvanced.convertBetweenCoordinateSystems(
                'percent', 'pixel', testCoords
            );
            log(`%→px変換: (${testCoords.x}%, ${testCoords.y}%) → (${pixelCoords.x.toFixed(1)}px, ${pixelCoords.y.toFixed(1)}px)`, 'info');
            
            // px → %
            const percentCoords = elementObserverAdvanced.convertBetweenCoordinateSystems(
                'pixel', 'percent', pixelCoords
            );
            log(`px→%変換: (${pixelCoords.x.toFixed(1)}px, ${pixelCoords.y.toFixed(1)}px) → (${percentCoords.x.toFixed(1)}%, ${percentCoords.y.toFixed(1)}%)`, 'info');
            
            log('✅ 座標系間変換テスト完了', 'success');
        }
        
        // 座標アニメーション
        function animateCoordinates() {
            if (!elementObserverAdvanced || !elementObserverAdvanced.integrationState.initialized) {
                log('⚠️ Phase 2未初期化', 'warning');
                return;
            }
            
            log('=== 座標アニメーション開始 ===', 'success');
            
            let startTime = performance.now();
            const duration = 5000; // 5秒
            const centerX = 50, centerY = 50;
            const radiusX = 20, radiusY = 15;
            
            const animate = (currentTime) => {
                const elapsed = currentTime - startTime;
                const progress = (elapsed % duration) / duration;
                const angle = progress * 2 * Math.PI;
                
                const x = centerX + Math.cos(angle) * radiusX;
                const y = centerY + Math.sin(angle) * radiusY;
                
                elementObserverAdvanced.setUnifiedPosition(x, y, '%');
                
                if (elapsed < duration) {
                    animationId = requestAnimationFrame(animate);
                } else {
                    log('✅ 座標アニメーション完了', 'success');
                    animationId = null;
                }
            };
            
            animationId = requestAnimationFrame(animate);
        }
        
        // WebGL同期テスト
        function testWebGLSync() {
            if (!elementObserverAdvanced?.webgl) {
                log('⚠️ WebGL未初期化', 'warning');
                return;
            }
            
            log('=== WebGL同期テスト開始 ===', 'success');
            
            // Skeleton位置を直接変更
            const skeleton = elementObserverAdvanced.webgl.skeleton;
            const oldX = skeleton.x;
            const oldY = skeleton.y;
            
            skeleton.x = 300;
            skeleton.y = 200;
            skeleton.updateWorldTransform();
            
            log(`Skeleton位置変更: (${oldX}, ${oldY}) → (${skeleton.x}, ${skeleton.y})`, 'info');
            
            // WebGL→DOM座標逆算
            const domCoords = elementObserverAdvanced.webgl.webGLToDOM(skeleton.x, skeleton.y, {
                coordinateType: 'percent'
            });
            
            log(`WebGL→DOM逆算: (${skeleton.x}, ${skeleton.y}) → (${domCoords.x.toFixed(1)}%, ${domCoords.y.toFixed(1)}%)`, 'info');
            
            // 統一座標で同期
            elementObserverAdvanced.setUnifiedPosition(domCoords.x, domCoords.y, '%');
            
            log('✅ WebGL同期テスト完了', 'success');
        }
        
        // レスポンシブCanvasテスト
        function testResponsiveCanvas() {
            if (!elementObserverAdvanced?.responsive) {
                log('⚠️ Responsive未初期化', 'warning');
                return;
            }
            
            log('=== レスポンシブCanvasテスト開始 ===', 'success');
            
            const responsive = elementObserverAdvanced.responsive;
            const currentConfig = responsive.getState();
            
            log('現在の設定:', 'info');
            log(`  CSS表示サイズ: ${currentConfig.actualSizes.css.width}x${currentConfig.actualSizes.css.height}`, 'info');
            log(`  描画バッファ: ${currentConfig.actualSizes.buffer.width}x${currentConfig.actualSizes.buffer.height}`, 'info');
            log(`  スケール比率: ${currentConfig.actualSizes.scaleRatio.x.toFixed(2)}x${currentConfig.actualSizes.scaleRatio.y.toFixed(2)}`, 'info');
            
            // 設定変更テスト
            responsive.updateConfig({
                cssSize: {
                    width: '30%',
                    height: '30%'
                },
                bufferSize: {
                    quality: 'ultra'
                }
            });
            
            setTimeout(() => {
                const newConfig = responsive.getState();
                log('設定変更後:', 'success');
                log(`  CSS表示サイズ: ${newConfig.actualSizes.css.width}x${newConfig.actualSizes.css.height}`, 'info');
                log(`  描画バッファ: ${newConfig.actualSizes.buffer.width}x${newConfig.actualSizes.buffer.height}`, 'info');
                log(`  品質: ${newConfig.config.bufferSize.quality}`, 'info');
                
                log('✅ レスポンシブCanvasテスト完了', 'success');
            }, 1000);
        }
        
        // Phase 2 BB開始
        async function startAdvancedBoundingBox() {
            if (!elementObserverAdvanced || !elementObserverAdvanced.integrationState.initialized) {
                log('⚠️ Phase 2未初期化', 'warning');
                return;
            }
            
            log('=== Phase 2高度BB開始 ===', 'success');
            
            try {
                // 既存のBBクリーンアップ
                if (currentBoundingBox) {
                    currentBoundingBox.cleanup();
                    currentBoundingBox = null;
                }
                
                // PureBoundingBox作成
                currentBoundingBox = new PureBoundingBox({
                    targetElement: testElements.targetElement,
                    nodeId: 'phase2-advanced-bb'
                });
                
                // Phase 2高度統合
                const integrated = elementObserverAdvanced.integratePureBoundingBox(currentBoundingBox);
                if (!integrated) {
                    throw new Error('PureBoundingBox統合失敗');
                }
                
                // BB実行開始
                const result = await currentBoundingBox.execute({ visible: true });
                
                if (result.success) {
                    log('✅ Phase 2高度BB開始成功', 'success');
                    log(`  nodeId: ${result.nodeId}`, 'info');
                    log('  🚀 Phase 2統合機能適用済み', 'success');
                    
                    // BB選択解除イベント監視
                    document.addEventListener('boundingBoxDeselected', onAdvancedBoundingBoxDeselected);
                    
                } else {
                    throw new Error(result.error || '不明なエラー');
                }
                
            } catch (error) {
                log(`❌ Phase 2高度BB開始エラー: ${error.message}`, 'error');
            }
        }
        
        // Phase 2 BB選択解除イベント
        function onAdvancedBoundingBoxDeselected(event) {
            log('=== Phase 2高度BB選択解除イベント ===', 'info');
            log(`  nodeId: ${event.detail.nodeId}`, 'info');
            log(`  finalPosition: ${JSON.stringify(event.detail.finalPosition)}`, 'info');
            log('  🌊 Phase 2高度コミット処理実行済み', 'success');
            
            updateCoordinateDisplay();
        }
        
        // Phase 2状態表示
        function showPhase2Status() {
            if (!elementObserverAdvanced) {
                log('⚠️ ElementObserverAdvanced未作成', 'warning');
                return;
            }
            
            const debugInfo = elementObserverAdvanced.getAdvancedDebugInfo();
            
            log('=== Phase 2詳細状態 ===', 'info');
            log(`初期化: ${debugInfo.phase2Integration.initialized}`, 'info');
            log(`アクティブモジュール: [${debugInfo.phase2Integration.activeModules.join(', ')}]`, 'info');
            log(`座標系数: ${debugInfo.phase2Integration.coordinateSystemsActive}`, 'info');
            log(`最終同期: ${debugInfo.phase2Integration.syncAge.toFixed(1)}ms前`, 'info');
            
            if (debugInfo.modules.transform) {
                log('Transform: ✅ アクティブ', 'success');
            }
            if (debugInfo.modules.webgl) {
                log('WebGL: ✅ アクティブ', 'success');
            }
            if (debugInfo.modules.responsive) {
                log('Responsive: ✅ アクティブ', 'success');
            }
        }
        
        // 全座標系表示
        function showCoordinateSystems() {
            if (!elementObserverAdvanced || !elementObserverAdvanced.integrationState.initialized) {
                log('⚠️ Phase 2未初期化', 'warning');
                return;
            }
            
            const coords = elementObserverAdvanced.coordinateSystems;
            
            log('=== 全座標系現在値 ===', 'success');
            log(`📐 DOM: (${coords.dom.x}${coords.dom.unit}, ${coords.dom.y}${coords.dom.unit})`, 'info');
            log(`🎯 Transform: tx=${coords.transform.tx}px, ty=${coords.transform.ty}px`, 'info');
            log(`🌐 WebGL: (${coords.webgl.x.toFixed(1)}, ${coords.webgl.y.toFixed(1)})`, 'info');
            log(`🎮 Skeleton: (${coords.skeleton.x.toFixed(1)}, ${coords.skeleton.y.toFixed(1)})`, 'info');
            log(`📱 Canvas: ${coords.canvas.displayWidth}x${coords.canvas.displayHeight} (表示) / ${coords.canvas.bufferWidth}x${coords.canvas.bufferHeight} (バッファ)`, 'info');
        }
        
        // リアルタイム座標表示
        function startCoordinateDisplay() {
            if (coordinateUpdateInterval) {
                clearInterval(coordinateUpdateInterval);
            }
            
            coordinateUpdateInterval = setInterval(() => {
                updateCoordinateDisplay();
            }, 100); // 10fps更新
            
            log('📊 リアルタイム座標表示開始', 'info');
        }
        
        function updateCoordinateDisplay() {
            if (!elementObserverAdvanced || !elementObserverAdvanced.integrationState.initialized) {
                return;
            }
            
            const coords = elementObserverAdvanced.coordinateSystems;
            
            document.getElementById('dom-coords').textContent = 
                `${coords.dom.x}${coords.dom.unit}, ${coords.dom.y}${coords.dom.unit}`;
                
            document.getElementById('transform-coords').textContent = 
                `tx: ${coords.transform.tx.toFixed(1)}px\nty: ${coords.transform.ty.toFixed(1)}px\nscale: ${coords.transform.scale}`;
                
            document.getElementById('webgl-coords').textContent = 
                `${coords.webgl.x.toFixed(1)}, ${coords.webgl.y.toFixed(1)}\ncamera: ${coords.webgl.camera.x.toFixed(1)}, ${coords.webgl.camera.y.toFixed(1)}`;
                
            document.getElementById('skeleton-coords').textContent = 
                `${coords.skeleton.x.toFixed(1)}, ${coords.skeleton.y.toFixed(1)}\nscale: ${coords.skeleton.scaleX}, ${coords.skeleton.scaleY}`;
                
            document.getElementById('canvas-coords').textContent = 
                `${coords.canvas.displayWidth}x${coords.canvas.displayHeight}\n${coords.canvas.bufferWidth}x${coords.canvas.bufferHeight}`;
        }
        
        // 詳細デバッグ情報
        function showAdvancedDebugInfo() {
            if (!elementObserverAdvanced) {
                log('⚠️ ElementObserverAdvanced未作成', 'warning');
                return;
            }
            
            const debugInfo = elementObserverAdvanced.getAdvancedDebugInfo();
            
            log('=== Phase 2詳細デバッグ情報 ===', 'debug');
            log(`Phase 2統合: ${JSON.stringify(debugInfo.phase2Integration, null, 2)}`, 'debug');
            log(`座標系: ${JSON.stringify(debugInfo.coordinateSystems, null, 2)}`, 'debug');
            
            if (debugInfo.modules.transform) {
                log(`Transform詳細: ${JSON.stringify(debugInfo.modules.transform, null, 2)}`, 'debug');
            }
            if (debugInfo.modules.webgl) {
                log(`WebGL詳細: ${JSON.stringify(debugInfo.modules.webgl, null, 2)}`, 'debug');
            }
            if (debugInfo.modules.responsive) {
                log(`Responsive詳細: ${JSON.stringify(debugInfo.modules.responsive, null, 2)}`, 'debug');
            }
        }
        
        // 📊 パフォーマンス測定システム
        
        // パフォーマンス測定開始
        function startPerformanceMonitoring() {
            if (performanceMonitoring.isActive) {
                log('⚠️ パフォーマンス測定は既に開始されています', 'warning');
                return;
            }
            
            log('=== パフォーマンス測定開始 ===', 'success');
            performanceMonitoring.isActive = true;
            performanceMonitoring.measurementData = [];
            
            updatePerformanceStatus('performance', true);
            
            // メモリ測定開始（ブラウザ対応時）
            startMemoryMonitoring();
            
            log('✅ パフォーマンス測定システム開始', 'success');
            log('  📊 setUnifiedPosition時間測定準備完了', 'info');
            log('  🎯 FPS測定準備完了', 'info');
            log('  💾 メモリ監視準備完了', 'info');
        }
        
        // パフォーマンス測定停止
        function stopPerformanceMonitoring() {
            if (!performanceMonitoring.isActive) {
                log('⚠️ パフォーマンス測定は開始されていません', 'warning');
                return;
            }
            
            log('=== パフォーマンス測定停止 ===', 'info');
            
            // 測定データの統計レポート
            generatePerformanceReport();
            
            // FPS測定停止
            if (performanceMonitoring.fpsMonitoring) {
                stopFPSMeasurement();
            }
            
            performanceMonitoring.isActive = false;
            performanceMonitoring.measurementData = [];
            
            updatePerformanceStatus('performance', false);
            updatePerformanceStatus('fps', false);
            updatePerformanceStatus('memory', false);
            
            log('✅ パフォーマンス測定システム停止', 'success');
        }
        
        // setUnifiedPosition実行時間測定
        function measureSetUnifiedPosition() {
            if (!performanceMonitoring.isActive) {
                log('⚠️ 先にパフォーマンス測定を開始してください', 'warning');
                return;
            }
            
            if (!elementObserverAdvanced || !elementObserverAdvanced.integrationState.initialized) {
                log('⚠️ Phase 2未初期化', 'warning');
                return;
            }
            
            log('=== setUnifiedPosition実行時間測定開始 ===', 'success');
            
            const testCases = [
                { x: 20, y: 30, unit: '%', name: 'テストケース1' },
                { x: 60, y: 40, unit: '%', name: 'テストケース2' },
                { x: 80, y: 70, unit: '%', name: 'テストケース3' },
                { x: 40, y: 80, unit: '%', name: 'テストケース4' },
                { x: 50, y: 50, unit: '%', name: 'テストケース5 (中央)' }
            ];
            
            let caseIndex = 0;
            
            const runNextTest = () => {
                if (caseIndex >= testCases.length) {
                    // すべてのテスト完了、統計表示
                    displaySetUnifiedPositionStats();
                    return;
                }
                
                const testCase = testCases[caseIndex];
                const iterations = 10; // 10回測定して平均を取る
                let measurements = [];
                
                // 1つのテストケースを10回実行
                for (let i = 0; i < iterations; i++) {
                    const startTime = performance.now();
                    
                    try {
                        elementObserverAdvanced.setUnifiedPosition(testCase.x, testCase.y, testCase.unit);
                        const endTime = performance.now();
                        const duration = endTime - startTime;
                        measurements.push(duration);
                    } catch (error) {
                        log(`❌ ${testCase.name} 実行エラー: ${error.message}`, 'error');
                        continue;
                    }
                }
                
                // 統計計算
                if (measurements.length > 0) {
                    const stats = calculateStatistics(measurements);
                    const measurementRecord = {
                        testCase: testCase.name,
                        position: `${testCase.x}${testCase.unit}, ${testCase.y}${testCase.unit}`,
                        ...stats,
                        timestamp: performance.now()
                    };
                    
                    performanceMonitoring.measurementData.push(measurementRecord);
                    
                    log(`📊 ${testCase.name}: ${stats.average.toFixed(3)}ms (平均) ±${stats.stddev.toFixed(3)}ms`, 'info');
                    log(`  最小: ${stats.min.toFixed(3)}ms, 最大: ${stats.max.toFixed(3)}ms`, 'debug');
                }
                
                caseIndex++;
                // 次のテストケースへ（少し間を開ける）
                setTimeout(runNextTest, 100);
            };
            
            runNextTest();
        }
        
        // FPS測定開始
        function measureFPS() {
            if (!performanceMonitoring.isActive) {
                log('⚠️ 先にパフォーマンス測定を開始してください', 'warning');
                return;
            }
            
            if (performanceMonitoring.fpsMonitoring) {
                log('⚠️ FPS測定は既に開始されています', 'warning');
                return;
            }
            
            log('=== FPS測定開始 ===', 'success');
            performanceMonitoring.fpsMonitoring = true;
            performanceMonitoring.fpsFrameCount = 0;
            performanceMonitoring.fpsStartTime = performance.now();
            
            updatePerformanceStatus('fps', true);
            
            const fpsLoop = () => {
                if (!performanceMonitoring.fpsMonitoring) return;
                
                performanceMonitoring.fpsFrameCount++;
                const currentTime = performance.now();
                const elapsed = currentTime - performanceMonitoring.fpsStartTime;
                
                // 1秒ごとにFPS更新
                if (elapsed >= 1000) {
                    performanceMonitoring.currentFPS = Math.round(performanceMonitoring.fpsFrameCount * 1000 / elapsed);
                    updateFPSDisplay(performanceMonitoring.currentFPS);
                    
                    // リセット
                    performanceMonitoring.fpsFrameCount = 0;
                    performanceMonitoring.fpsStartTime = currentTime;
                }
                
                performanceMonitoring.fpsAnimationId = requestAnimationFrame(fpsLoop);
            };
            
            performanceMonitoring.fpsAnimationId = requestAnimationFrame(fpsLoop);
            log('📈 リアルタイムFPS測定開始', 'info');
        }
        
        // FPS測定停止
        function stopFPSMeasurement() {
            if (!performanceMonitoring.fpsMonitoring) return;
            
            performanceMonitoring.fpsMonitoring = false;
            if (performanceMonitoring.fpsAnimationId) {
                cancelAnimationFrame(performanceMonitoring.fpsAnimationId);
                performanceMonitoring.fpsAnimationId = null;
            }
            
            log(`📈 FPS測定停止 - 最終FPS: ${performanceMonitoring.currentFPS}`, 'info');
            updatePerformanceStatus('fps', false);
        }
        
        // メモリ監視開始
        function startMemoryMonitoring() {
            if (!performance.memory) {
                log('⚠️ このブラウザはメモリ測定に対応していません', 'warning');
                updatePerformanceStatus('memory', false, 'N/A');
                return;
            }
            
            const updateMemory = () => {
                if (!performanceMonitoring.isActive) return;
                
                try {
                    const memInfo = performance.memory;
                    const usedMB = Math.round(memInfo.usedJSHeapSize / 1024 / 1024);
                    const totalMB = Math.round(memInfo.totalJSHeapSize / 1024 / 1024);
                    const limitMB = Math.round(memInfo.jsHeapSizeLimit / 1024 / 1024);
                    
                    updatePerformanceStatus('memory', true, `${usedMB}/${totalMB}MB`);
                    
                    setTimeout(updateMemory, 2000); // 2秒ごと更新
                } catch (error) {
                    log(`⚠️ メモリ情報取得エラー: ${error.message}`, 'warning');
                }
            };
            
            updateMemory();
            log('💾 メモリ監視開始', 'info');
        }
        
        // パフォーマンスステータス更新
        function updatePerformanceStatus(type, isActive, displayValue = '') {
            const element = statusElements[type];
            if (!element) return;
            
            if (type === 'performance') {
                element.textContent = isActive ? 'Monitoring Active' : 'Monitoring Inactive';
            } else if (type === 'fps') {
                element.textContent = isActive ? `FPS: ${performanceMonitoring.currentFPS}` : 'FPS: --';
            } else if (type === 'memory') {
                element.textContent = displayValue ? `Memory: ${displayValue}` : 'Memory: --';
            }
            
            element.className = `status ${isActive ? 'active' : 'inactive'}`;
        }
        
        // FPS表示更新
        function updateFPSDisplay(fps) {
            const element = statusElements.fps;
            if (element) {
                element.textContent = `FPS: ${fps}`;
            }
        }
        
        // 統計計算ユーティリティ
        function calculateStatistics(values) {
            if (values.length === 0) return { min: 0, max: 0, average: 0, stddev: 0 };
            
            const min = Math.min(...values);
            const max = Math.max(...values);
            const sum = values.reduce((a, b) => a + b, 0);
            const average = sum / values.length;
            
            const variance = values.reduce((acc, val) => acc + Math.pow(val - average, 2), 0) / values.length;
            const stddev = Math.sqrt(variance);
            
            return { min, max, average, stddev };
        }
        
        // setUnifiedPosition統計表示
        function displaySetUnifiedPositionStats() {
            if (performanceMonitoring.measurementData.length === 0) {
                log('⚠️ 測定データなし', 'warning');
                return;
            }
            
            log('=== setUnifiedPosition実行時間統計 ===', 'success');
            
            // 全体統計
            const allMeasurements = performanceMonitoring.measurementData.map(record => record.average);
            const overallStats = calculateStatistics(allMeasurements);
            
            log(`📊 全体統計 (${performanceMonitoring.measurementData.length}ケース):`, 'info');
            log(`  平均実行時間: ${overallStats.average.toFixed(3)}ms`, 'info');
            log(`  標準偏差: ${overallStats.stddev.toFixed(3)}ms`, 'info');
            log(`  最速: ${overallStats.min.toFixed(3)}ms`, 'info');
            log(`  最遅: ${overallStats.max.toFixed(3)}ms`, 'info');
            
            log('📋 詳細データ:', 'debug');
            performanceMonitoring.measurementData.forEach((record, index) => {
                log(`  ${index + 1}. ${record.testCase}: ${record.average.toFixed(3)}ms (${record.position})`, 'debug');
            });
        }
        
        // パフォーマンスレポート生成
        function generatePerformanceReport() {
            log('=== パフォーマンス測定レポート ===', 'success');
            
            if (performanceMonitoring.measurementData.length > 0) {
                displaySetUnifiedPositionStats();
            } else {
                log('setUnifiedPosition測定データなし', 'info');
            }
            
            if (performanceMonitoring.fpsMonitoring) {
                log(`最終FPS: ${performanceMonitoring.currentFPS}`, 'info');
            }
            
            // ブラウザ情報
            log('🌐 実行環境情報:', 'info');
            log(`  UserAgent: ${navigator.userAgent}`, 'debug');
            log(`  画面解像度: ${screen.width}x${screen.height}`, 'info');
            log(`  DPR: ${window.devicePixelRatio}`, 'info');
            
            if (performance.memory) {
                const memInfo = performance.memory;
                log(`  JSヒープサイズ: ${Math.round(memInfo.usedJSHeapSize / 1024 / 1024)}MB使用 / ${Math.round(memInfo.totalJSHeapSize / 1024 / 1024)}MB確保`, 'info');
            }
            
            log('✅ パフォーマンス測定レポート生成完了', 'success');
        }
        
        // ⚡ Phase 3-A最適化制御機能
        
        // 最適化機能を有効化
        function enableOptimizations() {
            if (!elementObserverAdvanced || !elementObserverAdvanced.integrationState.initialized) {
                log('⚠️ ElementObserverAdvanced未初期化', 'warning');
                return;
            }
            
            log('=== Phase 3-A最適化機能有効化 ===', 'success');
            
            // 最適化設定を有効化
            elementObserverAdvanced.setPerformanceOptimization({
                enabled: true,
                batchCoordinateUpdates: true,
                skipRedundantCalculations: true,
                minUpdateInterval: 8  // 120fps対応
            });
            
            phase3AOptimization.enabled = true;
            phase3AOptimization.currentMode = 'optimized';
            
            log('✅ 最適化機能有効化完了', 'success');
            log('  🚀 バッチ座標更新: ON', 'info');
            log('  ⚡ 冗長計算スキップ: ON', 'info');
            log('  🎯 120fps対応モード: ON', 'info');
        }
        
        // 最適化機能を無効化
        function disableOptimizations() {
            if (!elementObserverAdvanced || !elementObserverAdvanced.integrationState.initialized) {
                log('⚠️ ElementObserverAdvanced未初期化', 'warning');
                return;
            }
            
            log('=== Phase 3-A最適化機能無効化 ===', 'info');
            
            // 最適化設定を無効化
            elementObserverAdvanced.setPerformanceOptimization({
                enabled: false,
                batchCoordinateUpdates: false,
                skipRedundantCalculations: false,
                minUpdateInterval: 16  // 60fps標準
            });
            
            phase3AOptimization.enabled = false;
            phase3AOptimization.currentMode = 'unoptimized';
            
            log('✅ 最適化機能無効化完了', 'info');
            log('  📦 バッチ座標更新: OFF', 'info');
            log('  🔄 冗長計算スキップ: OFF', 'info');
            log('  📺 60fps標準モード: ON', 'info');
        }
        
        // 最適化効果の比較テスト
        function comparePerformance() {
            if (!elementObserverAdvanced || !elementObserverAdvanced.integrationState.initialized) {
                log('⚠️ ElementObserverAdvanced未初期化', 'warning');
                return;
            }
            
            log('=== Phase 3-A最適化効果比較テスト開始 ===', 'success');
            
            // 比較データをクリア
            phase3AOptimization.comparisonData.optimizedResults = [];
            phase3AOptimization.comparisonData.unoptimizedResults = [];
            
            // テストケース定義
            const testCases = [
                { x: 20, y: 30, label: '軽負荷テスト' },
                { x: 60, y: 40, label: '中負荷テスト' },
                { x: 80, y: 70, label: '高負荷テスト' }
            ];
            
            let currentTest = 0;
            
            function runComparisonTest() {
                if (currentTest >= testCases.length) {
                    // すべてのテスト完了、結果表示
                    displayComparisonResults();
                    return;
                }
                
                const testCase = testCases[currentTest];
                const iterations = 20; // 20回測定
                
                // 最適化OFF版測定
                disableOptimizations();
                setTimeout(() => {
                    log(`📊 ${testCase.label}: 最適化OFF測定開始 (${iterations}回)`, 'info');
                    
                    let unoptimizedTimes = [];
                    for (let i = 0; i < iterations; i++) {
                        const startTime = performance.now();
                        elementObserverAdvanced.setUnifiedPosition(testCase.x, testCase.y, '%');
                        const duration = performance.now() - startTime;
                        unoptimizedTimes.push(duration);
                    }
                    
                    // 最適化ON版測定
                    enableOptimizations();
                    setTimeout(() => {
                        log(`⚡ ${testCase.label}: 最適化ON測定開始 (${iterations}回)`, 'info');
                        
                        let optimizedTimes = [];
                        for (let i = 0; i < iterations; i++) {
                            const startTime = performance.now();
                            elementObserverAdvanced.setUnifiedPosition(testCase.x + 1, testCase.y + 1, '%');
                            const duration = performance.now() - startTime;
                            optimizedTimes.push(duration);
                        }
                        
                        // 統計計算
                        const unoptimizedStats = calculateStatistics(unoptimizedTimes);
                        const optimizedStats = calculateStatistics(optimizedTimes);
                        const improvement = ((unoptimizedStats.average - optimizedStats.average) / unoptimizedStats.average * 100);
                        
                        phase3AOptimization.comparisonData.unoptimizedResults.push({
                            label: testCase.label,
                            stats: unoptimizedStats
                        });
                        
                        phase3AOptimization.comparisonData.optimizedResults.push({
                            label: testCase.label,
                            stats: optimizedStats,
                            improvement: improvement
                        });
                        
                        log(`✅ ${testCase.label}完了: ${improvement.toFixed(1)}% 高速化`, 'success');
                        
                        currentTest++;
                        setTimeout(runComparisonTest, 100);
                        
                    }, 50);
                }, 50);
            }
            
            runComparisonTest();
        }
        
        // 比較結果表示
        function displayComparisonResults() {
            log('=== Phase 3-A最適化効果比較結果 ===', 'success');
            
            let totalImprovement = 0;
            let maxImprovement = 0;
            
            for (let i = 0; i < phase3AOptimization.comparisonData.optimizedResults.length; i++) {
                const optimized = phase3AOptimization.comparisonData.optimizedResults[i];
                const unoptimized = phase3AOptimization.comparisonData.unoptimizedResults[i];
                
                log(`📊 ${optimized.label}:`, 'info');
                log(`  最適化前: ${unoptimized.stats.average.toFixed(3)}ms ±${unoptimized.stats.stdDev.toFixed(3)}ms`, 'info');
                log(`  最適化後: ${optimized.stats.average.toFixed(3)}ms ±${optimized.stats.stdDev.toFixed(3)}ms`, 'info');
                log(`  改善率: ${optimized.improvement.toFixed(1)}% 高速化`, optimized.improvement > 0 ? 'success' : 'warning');
                
                totalImprovement += optimized.improvement;
                maxImprovement = Math.max(maxImprovement, optimized.improvement);
            }
            
            const averageImprovement = totalImprovement / phase3AOptimization.comparisonData.optimizedResults.length;
            
            log('🏆 Phase 3-A最適化効果まとめ:', 'success');
            log(`  平均改善率: ${averageImprovement.toFixed(1)}% 高速化`, 'success');
            log(`  最大改善率: ${maxImprovement.toFixed(1)}% 高速化`, 'success');
            log(`  目標達成度: ${averageImprovement >= 80 ? '✅' : '⚠️'} (目標80%高速化)`, averageImprovement >= 80 ? 'success' : 'warning');
            
            log('✅ Phase 3-A最適化効果比較完了', 'success');
        }
        
        // 最適化統計情報表示
        function showOptimizationStats() {
            if (!elementObserverAdvanced || !elementObserverAdvanced.integrationState.initialized) {
                log('⚠️ ElementObserverAdvanced未初期化', 'warning');
                return;
            }
            
            log('=== Phase 3-A最適化統計情報 ===', 'info');
            
            try {
                const stats = elementObserverAdvanced.getOptimizationStats();
                
                log('⚡ 最適化設定:', 'info');
                log(`  有効: ${stats.performanceOptimization.enabled}`, 'info');
                log(`  バッチ更新: ${stats.performanceOptimization.batchCoordinateUpdates}`, 'info');
                log(`  冗長計算スキップ: ${stats.performanceOptimization.skipRedundantCalculations}`, 'info');
                log(`  最小更新間隔: ${stats.performanceOptimization.minUpdateInterval}ms`, 'info');
                
                log('📊 座標更新情報:', 'info');
                log(`  保留中更新: ${stats.coordinateUpdateInfo.hasPending}`, 'info');
                log(`  最終更新: ${stats.coordinateUpdateInfo.timeSinceLastUpdate.toFixed(1)}ms前`, 'info');
                
                if (stats.moduleStats.transform) {
                    log('🎯 Transform統計:', 'info');
                    log(`  キャッシュ有効: ${stats.moduleStats.transform.cache.staticValid} (static), ${stats.moduleStats.transform.cache.dynamicValid} (dynamic)`, 'info');
                    log(`  保留中更新: ${stats.moduleStats.transform.pendingUpdates.count}件`, 'info');
                }
                
            } catch (error) {
                log('❌ 最適化統計取得エラー: ' + error.message, 'error');
            }
            
            log('✅ 最適化統計表示完了', 'success');
        }
        
        // オリジナルのconsoleをラップ
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;
        
        console.log = function(...args) {
            originalLog.apply(console, args);
            if (!args.join(' ').includes('👁️') || args.join(' ').includes('ElementObserver') || args.join(' ').includes('Phase 2')) {
                log(args.join(' '), 'info');
            }
        };
        
        console.error = function(...args) {
            originalError.apply(console, args);
            log(args.join(' '), 'error');
        };
        
        console.warn = function(...args) {
            originalWarn.apply(console, args);
            log(args.join(' '), 'warning');
        };
        
        // ページ読み込み時
        window.addEventListener('load', () => {
            log('🌐 ElementObserver Phase 2統合テストページ読み込み完了');
            log('');
            log('🚀 Phase 2統合テスト目標:');
            log('  1. 5座標系の完全統合・統一API動作確認');
            log('  2. DOM⟷WebGL・%⟷px座標変換の双方向確認');
            log('  3. レスポンシブWebGL・DPR対応の動作確認');
            log('  4. PureBoundingBox Phase 2統合機能確認');
            log('  5. リアルタイム120fps座標同期の確認');
            log('');
            log('▶️ 「Phase 2高度初期化」→「統一座標テスト」の順でテスト開始');
        });
        
        // クリーンアップ
        window.addEventListener('beforeunload', () => {
            // パフォーマンス測定停止
            if (performanceMonitoring.isActive) {
                stopPerformanceMonitoring();
            }
            if (performanceMonitoring.fpsAnimationId) {
                cancelAnimationFrame(performanceMonitoring.fpsAnimationId);
            }
            
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            if (coordinateUpdateInterval) {
                clearInterval(coordinateUpdateInterval);
            }
            if (currentBoundingBox) {
                currentBoundingBox.cleanup();
            }
            if (elementObserverAdvanced) {
                elementObserverAdvanced.cleanup();
            }
        });
    </script>
</body>
</html>