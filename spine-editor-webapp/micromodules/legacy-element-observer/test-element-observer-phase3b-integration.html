<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ElementObserver Phase 3-Bçµ±åˆãƒ†ã‚¹ãƒˆ - ç’°å¢ƒæºã‚Œå¸åãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Arial', sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .test-section {
            margin: 30px;
            padding: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: #f9f9f9;
        }
        
        .test-section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.5em;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }
        
        /* 6.1 èƒŒæ™¯ç”»åƒåŒæœŸãƒ†ã‚¹ãƒˆç”¨ - æœ¬ç•ªèƒŒæ™¯ç”»åƒä½¿ç”¨ */
        .background-sync-test {
            position: relative;
            width: 100%;
            height: 400px;
            background: 
                /* æœ¬ç•ªã‚µã‚¤ãƒˆã®èƒŒæ™¯ç”»åƒ */
                url('../../assets/images/ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼TOP.png'),
                /* ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ */
                linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            background-size: cover, cover;
            background-position: center center, center;
            background-repeat: no-repeat, no-repeat;
            border: 3px solid #4CAF50;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }
        
        .spine-character-mock {
            position: absolute;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #4CAF50, #2e7d32);
            border-radius: 50%;
            border: 3px solid #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        /* å®Ÿéš›ã®Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¡¨ç¤º */
        .spine-character-real {
            position: absolute;
            width: 120px;
            height: 120px;
            transition: all 0.3s ease;
            border: 2px solid rgba(76, 175, 80, 0.5);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        #nezumi-canvas {
            width: 600px;  /* å›ºå®šã‚µã‚¤ã‚ºã«æ‹¡å¤§ */
            height: 400px; /* å›ºå®šã‚µã‚¤ã‚ºã«æ‹¡å¤§ */
            border-radius: 6px;
            border: 2px solid #00ff00; /* ç·‘ã®å¢ƒç•Œç·šã§å¯è¦–åŒ– */
        }
        
        /* 6.3 ç”»åƒãƒ”ãƒ³ãƒ†ã‚¹ãƒˆç”¨ */
        .image-pin-test {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        .test-image {
            width: 200px;
            height: 150px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 10px;
            position: relative;
            border: 2px solid #333;
        }
        
        .pin-marker {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #ff4444;
            border-radius: 50%;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        /* 6.2 ãƒ†ã‚­ã‚¹ãƒˆRangeãƒ”ãƒ³ãƒ†ã‚¹ãƒˆç”¨ */
        .text-pin-test {
            font-size: 18px;
            line-height: 1.8;
            color: #333;
            padding: 20px;
            background: white;
            border-radius: 10px;
            position: relative;
        }
        
        .text-pin-marker {
            position: absolute;
            width: 15px;
            height: 15px;
            background: #4CAF50;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« */
        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .control-group {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        
        button {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            margin: 5px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        /* ãƒ­ã‚°è¡¨ç¤º */
        .log-panel {
            background: #1e1e1e;
            color: #00ff00;
            padding: 15px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            height: 200px;
            overflow-y: auto;
            margin-top: 20px;
            border: 2px solid #333;
        }
        
        .performance-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        
        .perf-metric {
            background: #f0f8ff;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            border: 1px solid #4CAF50;
        }
        
        .perf-metric .label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .perf-metric .value {
            font-size: 18px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ†ã‚¹ãƒˆç”¨ */
        @media (max-width: 768px) {
            .background-sync-test { height: 250px; }
            .image-pin-test { flex-direction: column; }
            .test-image { width: 100%; max-width: 300px; }
            .container { margin: 10px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸŒŠ ElementObserver Phase 3-Bçµ±åˆãƒ†ã‚¹ãƒˆ</h1>
            <p>ç’°å¢ƒæºã‚Œå¸åãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« - 6.1èƒŒæ™¯åŒæœŸãƒ»6.2ãƒ†ã‚­ã‚¹ãƒˆãƒ”ãƒ³ãƒ»6.3ç”»åƒãƒ”ãƒ³æ©Ÿèƒ½</p>
            <p style="margin-top: 10px; font-size: 0.9em; opacity: 0.9;">ğŸ­ <strong>nezumi</strong> PureSpineLoader v4.0çµ±åˆç‰ˆ</p>
        </div>
        
        <!-- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¡¨ç¤º -->
        <div class="test-section">
            <h2>ğŸ“Š Phase 3-Aé«˜é€ŸåŒ–æˆæœç¢ºèª</h2>
            <div class="performance-display">
                <div class="perf-metric">
                    <div class="label">Phase 3-Aå‡¦ç†æ™‚é–“</div>
                    <div class="value" id="phase3a-time">æ¸¬å®šä¸­...</div>
                </div>
                <div class="perf-metric">
                    <div class="label">ç’°å¢ƒè¦³æ¸¬å‡¦ç†æ™‚é–“</div>
                    <div class="value" id="env-observer-time">æ¸¬å®šä¸­...</div>
                </div>
                <div class="perf-metric">
                    <div class="label">ç·åˆå‡¦ç†æ™‚é–“</div>
                    <div class="value" id="total-time">æ¸¬å®šä¸­...</div>
                </div>
                <div class="perf-metric">
                    <div class="label">ç›£è¦–å¯¾è±¡æ•°</div>
                    <div class="value" id="observer-count">0</div>
                </div>
            </div>
        </div>
        
        <!-- 6.1 èƒŒæ™¯ç”»åƒåŒæœŸãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <h2>ğŸ¯ 6.1 èƒŒæ™¯ç”»åƒSpineåŒæœŸãƒ†ã‚¹ãƒˆ</h2>
            <div class="control-panel">
                <div class="control-group">
                    <label>èƒŒæ™¯ä½ç½®åˆ¶å¾¡:</label>
                    <button onclick="resizeBackground(0.8)">ç¸®å°</button>
                    <button onclick="resizeBackground(1.2)">æ‹¡å¤§</button>
                    <button onclick="moveBackground('left')">â†ç§»å‹•</button>
                    <button onclick="moveBackground('right')">ç§»å‹•â†’</button>
                </div>
                <div class="control-group">
                    <label>åŒæœŸåˆ¶å¾¡:</label>
                    <button onclick="startBackgroundSync()">åŒæœŸé–‹å§‹</button>
                    <button onclick="stopBackgroundSync()">åŒæœŸåœæ­¢</button>
                    <button onclick="testAnchorPoints()">ã‚¢ãƒ³ã‚«ãƒ¼ãƒ†ã‚¹ãƒˆ</button>
                </div>
            </div>
            <div class="background-sync-test" id="background-test">
                <!-- å®Ÿéš›ã®Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ï¼šnezumi -->
                <div class="spine-character-real" id="spine-char" style="left: 50%; top: 20%; transform: translate(-50%, 0); width: 620px; height: 420px;">
                    <canvas id="nezumi-canvas"></canvas>
                </div>
            </div>
        </div>
        
        <!-- 6.2 ãƒ†ã‚­ã‚¹ãƒˆRangeãƒ”ãƒ³ãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <h2>ğŸ“ 6.2 ãƒ†ã‚­ã‚¹ãƒˆRangeãƒ”ãƒ³æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</h2>
            <div class="control-panel">
                <div class="control-group">
                    <label>ãƒ†ã‚­ã‚¹ãƒˆãƒ”ãƒ³åˆ¶å¾¡:</label>
                    <button onclick="startTextRangePin()">Rangeãƒ”ãƒ³é–‹å§‹</button>
                    <button onclick="stopTextRangePin()">ãƒ”ãƒ³åœæ­¢</button>
                    <button onclick="changeTextContent()">ãƒ†ã‚­ã‚¹ãƒˆå¤‰æ›´</button>
                    <button onclick="addLineBreaks()">æ”¹è¡Œè¿½åŠ </button>
                </div>
                <div class="control-group">
                    <label>Rangeæˆ¦ç•¥:</label>
                    <button onclick="switchStrategy('range')">Range API</button>
                    <button onclick="switchStrategy('span')">SpanæŒ¿å…¥</button>
                    <button onclick="switchStrategy('element')">Elementç›£è¦–</button>
                </div>
            </div>
            <div class="text-pin-test" id="text-test">
                <p>ã“ã®æ–‡ç« ã¯<strong>ãƒ†ã‚­ã‚¹ãƒˆRangeãƒ”ãƒ³æ©Ÿèƒ½</strong>ã®ãƒ†ã‚¹ãƒˆã§ã™ã€‚æ–‡ç« ã®æœ«å°¾ã«Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒè¿½å¾“ã—ã¾ã™ã€‚<span id="text-target">â†ã“ã“ã«è¿½å¾“</span></p>
                <p>ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œã«ã‚ˆã‚Šã€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºå¤‰æ›´ã‚„æ”¹è¡Œå¤‰åŒ–ã«ã‚‚å¯¾å¿œã—ã¾ã™ã€‚</p>
            </div>
        </div>
        
        <!-- 6.3 ç”»åƒãƒ”ãƒ³æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ -->
        <div class="test-section">
            <h2>ğŸ–¼ï¸ 6.3 ç”»åƒãƒ”ãƒ³æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</h2>
            <div class="control-panel">
                <div class="control-group">
                    <label>ç”»åƒãƒ”ãƒ³åˆ¶å¾¡:</label>
                    <button onclick="startImagePin('tl')">å·¦ä¸Šãƒ”ãƒ³</button>
                    <button onclick="startImagePin('tr')">å³ä¸Šãƒ”ãƒ³</button>
                    <button onclick="startImagePin('bl')">å·¦ä¸‹ãƒ”ãƒ³</button>
                    <button onclick="startImagePin('br')">å³ä¸‹ãƒ”ãƒ³</button>
                    <button onclick="startImagePin('center')">ä¸­å¤®ãƒ”ãƒ³</button>
                </div>
                <div class="control-group">
                    <label>ç”»åƒåˆ¶å¾¡:</label>
                    <button onclick="resizeImage(0.8)">ç¸®å°</button>
                    <button onclick="resizeImage(1.2)">æ‹¡å¤§</button>
                    <button onclick="stopImagePin()">ãƒ”ãƒ³åœæ­¢</button>
                </div>
            </div>
            <div class="image-pin-test">
                <div class="test-image" id="test-image-1">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-weight: bold;">ç”»åƒ1</div>
                </div>
                <div class="test-image" id="test-image-2">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-weight: bold;">ç”»åƒ2</div>
                </div>
            </div>
        </div>
        
        <!-- ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚° -->
        <div class="test-section">
            <h2>ğŸ” ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ãƒ»ç’°å¢ƒç›£è¦–</h2>
            <div class="control-panel">
                <div class="control-group">
                    <button onclick="clearLog()">ãƒ­ã‚°ã‚¯ãƒªã‚¢</button>
                    <button onclick="exportLog()">ãƒ­ã‚°å‡ºåŠ›</button>
                    <button onclick="testDPRChange()">DPRå¤‰åŒ–ãƒ†ã‚¹ãƒˆ</button>
                    <button onclick="testWindowResize()">ãƒªã‚µã‚¤ã‚ºãƒ†ã‚¹ãƒˆ</button>
                </div>
                <div class="control-group">
                    <label>nezumiãƒ‡ãƒãƒƒã‚°:</label>
                    <button onclick="debugNezumiInfo()">nezumiçŠ¶æ…‹ç¢ºèª</button>
                    <button onclick="testPurattokuAnimations()">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ</button>
                </div>
            </div>
            <div class="log-panel" id="log-panel"></div>
        </div>
    </div>

    <!-- Spine WebGLèª­ã¿è¾¼ã¿ -->
    <script src="../../assets/js/libs/spine-webgl.js"></script>
    
    <!-- PureSpineLoader v4.0 æ­£å¼ç‰ˆ -->
    <script src="../spine-loader/PureSpineLoader.js"></script>
    
    <!-- ElementObserver Phase 3-Bçµ±åˆã‚·ã‚¹ãƒ†ãƒ èª­ã¿è¾¼ã¿ -->
    <script src="ElementObserverCore.js"></script>
    <script src="ElementObserver.js"></script>
    <script src="ElementObserverAdvanced.js"></script>
    
    <script>
        // ğŸŒŠ Phase 3-Bçµ±åˆãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ 
        class Phase3BIntegrationTest {
            constructor() {
                this.observer = null;
                this.activeObservations = new Map();
                this.performanceMetrics = {
                    phase3aTime: 0,
                    envObserverTime: 0,
                    totalTime: 0
                };
                this.logElement = document.getElementById('log-panel');
                
                // Spine WebGLé–¢é€£
                this.spineApp = null;
                this.nezumiSkeleton = null;
                this.animationState = null;
                this.canvas = null;
                
                this.init();
            }
            
            async init() {
                this.log('ğŸŒŠ ElementObserver Phase 3-Bçµ±åˆãƒ†ã‚¹ãƒˆé–‹å§‹');
                
                try {
                    // Spine WebGLåˆæœŸåŒ–ï¼ˆnezumiï¼‰
                    await this.initializeSpineSystem();
                    
                    // ElementObserverAdvancedåˆæœŸåŒ–
                    this.observer = new ElementObserverAdvanced();
                    this.log('âœ… ElementObserverAdvancedåˆæœŸåŒ–å®Œäº†');
                    
                    // Phase 3-Aæ€§èƒ½ç¢ºèª
                    await this.measurePhase3APerformance();
                    
                    // ç’°å¢ƒç›£è¦–ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–
                    this.setupEnvironmentMonitoring();
                    
                    this.log('ğŸ¯ Phase 3-Bçµ±åˆãƒ†ã‚¹ãƒˆæº–å‚™å®Œäº†');
                    this.updatePerformanceDisplay();
                    
                } catch (error) {
                    this.log(`âŒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            }
            
            async initializeSpineSystem() {
                try {
                    this.log('ğŸŒŸ nezumi SpineåˆæœŸåŒ–é–‹å§‹');
                    
                    // SpineWebGLç’°å¢ƒç¢ºèª
                    this.log('ğŸ” SpineWebGLç’°å¢ƒãƒã‚§ãƒƒã‚¯...');
                    console.log('window.spine:', typeof window.spine);
                    if (window.spine) {
                        console.log('åˆ©ç”¨å¯èƒ½ãªSpineã‚¯ãƒ©ã‚¹:', Object.keys(window.spine));
                        console.log('AssetManager:', typeof window.spine.AssetManager);
                        console.log('SkeletonJson:', typeof window.spine.SkeletonJson);
                        console.log('AtlasAttachmentLoader:', typeof window.spine.AtlasAttachmentLoader);
                    }
                    
                    this.canvas = document.getElementById('nezumi-canvas');
                    if (!this.canvas) {
                        throw new Error('CanvasãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    }
                    
                    // Canvasæƒ…å ±ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›
                    this.log('ğŸ¨ Canvasæƒ…å ±:', {
                        width: this.canvas.width,
                        height: this.canvas.height,
                        clientWidth: this.canvas.clientWidth,
                        clientHeight: this.canvas.clientHeight,
                        style: this.canvas.style.cssText
                    });
                    
                    // Spine WebGLåˆ©ç”¨å¯èƒ½ãƒã‚§ãƒƒã‚¯
                    if (typeof spine === 'undefined') {
                        this.log('âš ï¸ Spine WebGLãŒåˆ©ç”¨ä¸å¯ - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è¡¨ç¤º', 'warning');
                        this.createFallbackPurattokun();
                        return;
                    }
                    
                    // Spine WebGLã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆ
                    const config = {
                        alpha: true,
                        premultipliedAlpha: false,
                        preserveDrawingBuffer: true
                    };
                    
                    this.spineApp = new spine.SpineCanvas(this.canvas, config);
                    
                    // ã‚«ãƒ¡ãƒ©ä½ç½®è¨­å®šï¼ˆãƒãƒ‹ãƒ¥ã‚¢ãƒ«æ¨å¥¨ï¼‰
                    if (this.spineApp.renderer && this.spineApp.renderer.camera) {
                        this.spineApp.renderer.camera.position.x = 0;
                        this.spineApp.renderer.camera.position.y = 0;
                        this.spineApp.renderer.camera.setViewport(this.canvas.width, this.canvas.height);
                        this.spineApp.renderer.camera.update();
                        this.log('ğŸ“ ã‚«ãƒ¡ãƒ©è¨­å®šå®Œäº†: position(0,0)');
                    }
                    
                    // ğŸ¯ PureSpineLoader v4.0ã‚’ä½¿ç”¨ã—ãŸã·ã‚‰ã£ã¨ãã‚“èª­ã¿è¾¼ã¿ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
                    this.log('ğŸ”„ PureSpineLoader v4.0ã§ã·ã‚‰ã£ã¨ãã‚“èª­ã¿è¾¼ã¿é–‹å§‹ï¼ˆè¡¨ç¤ºãƒ†ã‚¹ãƒˆï¼‰...');
                    
                    // ğŸ“Š è©³ç´°ç’°å¢ƒãƒ‡ãƒãƒƒã‚°
                    this.log('ğŸ” ç’°å¢ƒç¢ºèªé–‹å§‹ ---------');
                    this.log('ğŸŒ window.spine:', typeof window.spine);
                    this.log('ğŸ§ª PureSpineLoader:', typeof window.PureSpineLoader);
                    
                    if (window.spine) {
                        this.log('ğŸ“¦ åˆ©ç”¨å¯èƒ½ãªSpineã‚¯ãƒ©ã‚¹ä¸€è¦§:', Object.keys(window.spine));
                        
                        // å€‹åˆ¥ã‚¯ãƒ©ã‚¹ç¢ºèªï¼ˆä¿®æ­£ã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ãƒã‚§ãƒƒã‚¯ï¼‰
                        const requiredClasses = [
                            'AssetManager', 'SkeletonJson', 'AtlasAttachmentLoader', 
                            'PolygonBatcher', 'SkeletonRenderer', 'Skeleton', 'AnimationState'
                        ];
                        
                        requiredClasses.forEach(className => {
                            const classExists = !!window.spine[className];
                            this.log(`ğŸ”§ ${className}:`, classExists ? 'âœ…' : 'âŒ');
                        });
                    }
                    this.log('ğŸ” ç’°å¢ƒç¢ºèªçµ‚äº† ---------');
                    
                    // ã¾ãšPureSpineLoaderã®çµ„ã¿è¾¼ã¿ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ
                    this.log('ğŸ§ª PureSpineLoaderçµ„ã¿è¾¼ã¿ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ...');
                    try {
                        const testResult = await PureSpineLoader.test();
                        this.log('ğŸ“‹ çµ„ã¿è¾¼ã¿ãƒ†ã‚¹ãƒˆçµæœ:', JSON.stringify(testResult, null, 2));
                        if (!testResult.success) {
                            throw new Error(`çµ„ã¿è¾¼ã¿ãƒ†ã‚¹ãƒˆå¤±æ•—: ${testResult.error}`);
                        }
                    } catch (testError) {
                        this.log(`âš ï¸ çµ„ã¿è¾¼ã¿ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: ${testError.message}`, 'warning');
                        this.log('ğŸ“Š ã‚¨ãƒ©ãƒ¼è©³ç´°:', testError);
                    }
                    
                    this.log('ğŸ¯ PureSpineLoaderã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆä¸­...');
                    const spineLoader = new PureSpineLoader({
                        basePath: '/assets/spine/characters/purattokun/',
                        atlasPath: '/assets/spine/characters/purattokun/purattokun.atlas',
                        jsonPath: '/assets/spine/characters/purattokun/purattokun.json',
                        scale: 1.0
                    });
                    this.log('âœ… PureSpineLoaderã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆå®Œäº†');
                    
                    this.log('âš™ï¸ PureSpineLoaderè¨­å®šç¢ºèª:', spineLoader.getOutput());
                    
                    // ğŸ” ãƒãƒ‹ãƒ¥ã‚¢ãƒ«æ¨å¥¨ãƒ‡ãƒãƒƒã‚°æ‰‹é †å®Ÿè¡Œ
                    this.log('ğŸ” ãƒãƒ‹ãƒ¥ã‚¢ãƒ«æ¨å¥¨ãƒ‡ãƒãƒƒã‚°é–‹å§‹ -----------');
                    
                    // 1. è¨­å®šç¢ºèª
                    this.log('1ï¸âƒ£ Configç¢ºèª:', spineLoader.getOutput().config);
                    
                    // 2. ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèª
                    this.log('2ï¸âƒ£ ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèªä¸­...');
                    try {
                        const atlasResponse = await fetch('/assets/spine/characters/purattokun/purattokun.atlas');
                        this.log('ğŸ“„ Atlasãƒ•ã‚¡ã‚¤ãƒ«:', atlasResponse.ok ? 'âœ… å­˜åœ¨' : 'âŒ ä¸åœ¨');
                        
                        const jsonResponse = await fetch('/assets/spine/characters/purattokun/purattokun.json');
                        this.log('ğŸ“„ JSONãƒ•ã‚¡ã‚¤ãƒ«:', jsonResponse.ok ? 'âœ… å­˜åœ¨' : 'âŒ ä¸åœ¨');
                        
                        const pngResponse = await fetch('/assets/spine/characters/purattokun/purattokun.png');
                        this.log('ğŸ–¼ï¸ PNGãƒ•ã‚¡ã‚¤ãƒ«:', pngResponse.ok ? 'âœ… å­˜åœ¨' : 'âŒ ä¸åœ¨');
                    } catch (fetchError) {
                        this.log('âš ï¸ ãƒ•ã‚¡ã‚¤ãƒ«ç¢ºèªã‚¨ãƒ©ãƒ¼:', fetchError.message);
                    }
                    
                    // 3. Spineãƒ©ã‚¤ãƒ–ãƒ©ãƒªç¢ºèª
                    this.log('3ï¸âƒ£ Spineãƒ©ã‚¤ãƒ–ãƒ©ãƒªè©³ç´°ç¢ºèª:');
                    this.log('   typeof window.spine:', typeof window.spine);
                    this.log('   AssetManager:', typeof spine?.AssetManager);
                    this.log('   SkeletonRenderer:', typeof spine?.SkeletonRenderer);  
                    this.log('   PolygonBatcher:', typeof spine?.PolygonBatcher);
                    
                    this.log('ğŸ” ãƒãƒ‹ãƒ¥ã‚¢ãƒ«æ¨å¥¨ãƒ‡ãƒãƒƒã‚°çµ‚äº† -----------');
                    
                    this.log('âš¡ PureSpineLoader.execute()å®Ÿè¡Œé–‹å§‹...');
                    const loadResult = await spineLoader.execute();
                    this.log('âš¡ PureSpineLoader.execute()å®Ÿè¡Œå®Œäº†');
                    
                    // è©³ç´°ãªãƒ­ã‚°å‡ºåŠ›
                    this.log('ğŸ” PureSpineLoaderå®Ÿè¡Œçµæœ:', {
                        loaded: loadResult.loaded,
                        loading: loadResult.loading, 
                        error: loadResult.error,
                        config: loadResult.config
                    });
                    
                    if (!loadResult.loaded) {
                        this.log(`âŒ ã·ã‚‰ã£ã¨ãã‚“èª­ã¿è¾¼ã¿å¤±æ•—è©³ç´°: ${loadResult.error}`, 'error');
                        throw new Error(`ã·ã‚‰ã£ã¨ãã‚“èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${loadResult.error}`);
                    }
                    
                    this.log('âœ… ã·ã‚‰ã£ã¨ãã‚“èª­ã¿è¾¼ã¿æˆåŠŸ!', loadResult.spineData);
                    
                    // èª­ã¿è¾¼ã¿å®Œäº†å¾Œã¯ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    spineLoader.cleanup();
                    
                    // ğŸ¯ PureSpineLoaderã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¦nezumiä½œæˆ
                    const { skeletonData, atlas } = loadResult.spineData;
                    
                    // ãƒãƒ‹ãƒ¥ã‚¢ãƒ«é€šã‚Šã®æ­£ã—ã„åº§æ¨™è¨­å®š
                    this.nezumiSkeleton = new spine.Skeleton(skeletonData);
                    this.nezumiSkeleton.x = 0;    // Spineåº§æ¨™ç³»ã®åŸºæº–ç‚¹
                    this.nezumiSkeleton.y = 0;    // Spineåº§æ¨™ç³»ã®åŸºæº–ç‚¹ï¼ˆåœ°é¢ãƒ¬ãƒ™ãƒ«ï¼‰
                    this.nezumiSkeleton.setToSetupPose();
                    this.nezumiSkeleton.updateWorldTransform();
                    
                    this.log('ğŸ“ nezumiåº§æ¨™è¨­å®šå®Œäº†: x=0, y=0 (ãƒãƒ‹ãƒ¥ã‚¢ãƒ«æ¨å¥¨)');
                    
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çŠ¶æ…‹åˆæœŸåŒ–
                    this.animationState = new spine.AnimationState(new spine.AnimationStateData(skeletonData));
                    this.animationState.setAnimation(0, 'taiki', true);
                    
                    this.log('ğŸ¬ nezumiã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹: taiki');
                    
                    // æç”»ãƒ«ãƒ¼ãƒ—é–‹å§‹
                    this.startRenderLoop();
                    
                    this.log('âœ… nezumi SpineåˆæœŸåŒ–å®Œäº†', 'success');
                    
                } catch (error) {
                    this.log(`âŒ SpineåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    this.log('ğŸ”„ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è¡¨ç¤ºã«åˆ‡ã‚Šæ›¿ãˆ', 'warning');
                    this.createFallbackPurattokun();
                }
            }
            
            createFallbackPurattokun() {
                // SpineåˆæœŸåŒ–å¤±æ•—æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è¡¨ç¤ºï¼ˆéè¡¨ç¤ºåŒ–ï¼‰
                const spineContainer = document.getElementById('spine-char');
                if (spineContainer) {
                    spineContainer.innerHTML = `
                        <div style="display: none;">
                            <!-- ã‚ªãƒ¬ãƒ³ã‚¸ã®ä¸¸ã‚¢ã‚¤ã‚³ãƒ³ã‚’éè¡¨ç¤ºåŒ– -->
                        </div>
                    `;
                    this.log('ğŸš« ã‚ªãƒ¬ãƒ³ã‚¸ä¸¸ã‚¢ã‚¤ã‚³ãƒ³ã‚’éè¡¨ç¤ºåŒ–', 'info');
                }
                
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç‰ˆnezumiåˆ¶å¾¡ï¼ˆéè¡¨ç¤ºç‰ˆï¼‰
                this.nezumiSkeleton = {
                    isFallback: true,
                    element: null,
                    x: 0, y: 0, scaleX: 1, scaleY: 1
                };
                
                this.log('âœ… ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†å®Œäº†ï¼ˆéè¡¨ç¤ºï¼‰', 'info');
            }
            
            startRenderLoop() {
                const render = (time) => {
                    if (!this.spineApp || !this.nezumiSkeleton || !this.animationState) return;
                    
                    try {
                        // ğŸ¨ ã‚·ãƒ³ãƒ—ãƒ«ãªæç”»æ–¹æ³•ï¼ˆSpineCanvasã®åŸºæœ¬APIï¼‰
                        
                        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
                        this.animationState.update(0.016); // 60fps
                        this.animationState.apply(this.nezumiSkeleton);
                        
                        // ãƒãƒ‹ãƒ¥ã‚¢ãƒ«æ¨å¥¨åº§æ¨™è¨­å®š
                        this.nezumiSkeleton.x = 0;    // Spineåº§æ¨™ç³»ã®åŸºæº–ç‚¹
                        this.nezumiSkeleton.y = 0;    // Spineåº§æ¨™ç³»ã®åŸºæº–ç‚¹ï¼ˆåœ°é¢ãƒ¬ãƒ™ãƒ«ï¼‰
                        this.nezumiSkeleton.scaleX = 0.5;  // è¦‹ã‚„ã™ã„ã‚µã‚¤ã‚º
                        this.nezumiSkeleton.scaleY = 0.5;
                        
                        this.nezumiSkeleton.updateWorldTransform();
                        
                        // æœ€ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ãªæç”»ï¼ˆSpineCanvasã®æ¨™æº–æ–¹å¼ï¼‰
                        this.spineApp.render(this.nezumiSkeleton);
                        
                        // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ï¼ˆ5ç§’ãŠãï¼‰
                        if (Math.floor(time / 1000) % 5 === 0 && time % 100 < 16) {
                            this.log(`ğŸ¯ æç”»å®Ÿè¡Œ: skeleton.x=${this.nezumiSkeleton.x}, y=${this.nezumiSkeleton.y}, scale=${this.nezumiSkeleton.scaleX}`);
                        }
                        
                    } catch (error) {
                        // ã‚¨ãƒ©ãƒ¼è©³ç´°ã‚’è¡¨ç¤ºï¼ˆAPIå•é¡Œç‰¹å®šç”¨ï¼‰
                        this.log(`âŒ æç”»ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                        this.log('ğŸ” SpineAppåˆ©ç”¨å¯èƒ½ãƒ¡ã‚½ãƒƒãƒ‰:', Object.getOwnPropertyNames(this.spineApp));
                    }
                    
                    requestAnimationFrame(render);
                };
                
                requestAnimationFrame(render);
            }
            
            async measurePhase3APerformance() {
                this.log('ğŸ“Š Phase 3-Aæ€§èƒ½æ¸¬å®šé–‹å§‹');
                
                const testElement = document.getElementById('background-test');
                const iterations = 1000;
                
                const startTime = performance.now();
                
                for (let i = 0; i < iterations; i++) {
                    // Phase 3-Aã®setUnifiedPosition()å‘¼ã³å‡ºã—
                    if (this.observer.setUnifiedPosition) {
                        await this.observer.setUnifiedPosition(testElement, {
                            x: Math.random() * 100,
                            y: Math.random() * 100,
                            mode: 'dom'
                        });
                    }
                }
                
                const endTime = performance.now();
                const totalTime = endTime - startTime;
                const avgTime = totalTime / iterations;
                
                this.performanceMetrics.phase3aTime = avgTime;
                this.log(`ğŸš€ Phase 3-Aå¹³å‡å‡¦ç†æ™‚é–“: ${avgTime.toFixed(4)}ms`);
                
                // ç›®æ¨™0.01msç¢ºèª
                if (avgTime <= 0.01) {
                    this.log('âœ… Phase 3-Aç›®æ¨™æ€§èƒ½é”æˆ (â‰¤0.01ms)', 'success');
                } else if (avgTime <= 0.1) {
                    this.log('âš ï¸ Phase 3-Aæ€§èƒ½ã‚„ã‚„åŠ£åŒ– (â‰¤0.1ms)', 'warning');
                } else {
                    this.log('âŒ Phase 3-Aæ€§èƒ½å¤§å¹…åŠ£åŒ– (>0.1ms)', 'error');
                }
            }
            
            setupEnvironmentMonitoring() {
                // ç’°å¢ƒå¤‰åŒ–ã®ç›£è¦–
                window.addEventListener('resize', () => {
                    this.log('ğŸ”„ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºæ¤œå‡º');
                    this.measureEnvironmentObserverTime();
                });
                
                // DPRå¤‰åŒ–ã®ç›£è¦–
                this.monitorDPRChanges();
                
                this.log('ğŸ” ç’°å¢ƒç›£è¦–ã‚·ã‚¹ãƒ†ãƒ é–‹å§‹');
            }
            
            async measureEnvironmentObserverTime() {
                const startTime = performance.now();
                
                // ç’°å¢ƒè¦³æ¸¬å‡¦ç†å®Ÿè¡Œ
                if (this.observer.handleEnvironmentChange) {
                    await this.observer.handleEnvironmentChange();
                }
                
                const endTime = performance.now();
                this.performanceMetrics.envObserverTime = endTime - startTime;
                this.performanceMetrics.totalTime = this.performanceMetrics.phase3aTime + this.performanceMetrics.envObserverTime;
                
                this.updatePerformanceDisplay();
            }
            
            monitorDPRChanges() {
                let lastDPR = window.devicePixelRatio || 1;
                
                setInterval(() => {
                    const currentDPR = window.devicePixelRatio || 1;
                    if (Math.abs(currentDPR - lastDPR) > 0.1) {
                        this.log(`ğŸ“ DPRå¤‰åŒ–æ¤œå‡º: ${lastDPR} â†’ ${currentDPR}`);
                        lastDPR = currentDPR;
                        this.measureEnvironmentObserverTime();
                    }
                }, 1000);
            }
            
            updatePerformanceDisplay() {
                document.getElementById('phase3a-time').textContent = 
                    `${this.performanceMetrics.phase3aTime.toFixed(4)}ms`;
                document.getElementById('env-observer-time').textContent = 
                    `${this.performanceMetrics.envObserverTime.toFixed(4)}ms`;
                document.getElementById('total-time').textContent = 
                    `${this.performanceMetrics.totalTime.toFixed(4)}ms`;
                document.getElementById('observer-count').textContent = 
                    this.activeObservations.size;
            }
            
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const color = {
                    'info': '#00ff00',
                    'success': '#00ff88', 
                    'warning': '#ffaa00',
                    'error': '#ff4444'
                }[type] || '#00ff00';
                
                const logEntry = document.createElement('div');
                logEntry.style.color = color;
                logEntry.innerHTML = `[${timestamp}] ${message}`;
                
                this.logElement.appendChild(logEntry);
                this.logElement.scrollTop = this.logElement.scrollHeight;
            }
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ãƒ»é–¢æ•°å®šç¾©
        let integrationTest;
        let backgroundSyncActive = false;
        let textRangePinActive = false;
        let imagePinActive = false;
        let currentStrategy = 'range';
        
        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            integrationTest = new Phase3BIntegrationTest();
        });
        
        // 6.1 èƒŒæ™¯ç”»åƒåŒæœŸæ©Ÿèƒ½ï¼ˆnezuminçµ±åˆç‰ˆï¼‰
        async function startBackgroundSync() {
            if (!integrationTest.observer) return;
            
            const backgroundElement = document.getElementById('background-test');
            const spineElement = document.getElementById('spine-char');
            
            try {
                integrationTest.log('ğŸ¯ 6.1èƒŒæ™¯ç”»åƒåŒæœŸé–‹å§‹ï¼ˆnezuminï¼‰');
                
                // ã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§nezumiã®ä½ç½®ã‚’ç›´æ¥åˆ¶å¾¡
                const customCallback = (backgroundRect, anchor) => {
                    if (integrationTest.nezumiSkeleton) {
                        // èƒŒæ™¯è¦ç´ ã®å¤‰åŒ–ã‚’nezumiã®ä½ç½®ã«åæ˜ 
                        const anchorPosition = calculateAnchorPosition(backgroundRect, anchor);
                        updatePurattokuPosition(anchorPosition.x, anchorPosition.y);
                        integrationTest.log(`ğŸ˜º nezuminä½ç½®æ›´æ–°: ${anchorPosition.x.toFixed(1)}px, ${anchorPosition.y.toFixed(1)}px`);
                    }
                };
                
                const unobserve = integrationTest.observer.observeBackgroundSync(backgroundElement, spineElement, {
                    anchor: 'center',
                    mode: 'dom',
                    responsive: true,
                    customCallback: customCallback
                });
                
                integrationTest.activeObservations.set('background-sync', unobserve);
                backgroundSyncActive = true;
                integrationTest.log('âœ… èƒŒæ™¯ç”»åƒåŒæœŸã‚¢ã‚¯ãƒ†ã‚£ãƒ–ï¼ˆnezuminçµ±åˆï¼‰', 'success');
                integrationTest.updatePerformanceDisplay();
                
            } catch (error) {
                integrationTest.log(`âŒ èƒŒæ™¯åŒæœŸã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
        
        // ã‚¢ãƒ³ã‚«ãƒ¼ä½ç½®è¨ˆç®—
        function calculateAnchorPosition(rect, anchor) {
            const positions = {
                'tl': { x: rect.left, y: rect.top },
                'tr': { x: rect.right, y: rect.top },
                'bl': { x: rect.left, y: rect.bottom },
                'br': { x: rect.right, y: rect.bottom },
                'center': { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 }
            };
            return positions[anchor] || positions.center;
        }
        
        // nezumiã®ä½ç½®ã‚’ç›´æ¥æ›´æ–°
        function updatePurattokuPosition(x, y) {
            if (!integrationTest.nezumiSkeleton) return;
            
            // DOMè¦ç´ ã®ä½ç½®ã‚‚åŒæœŸ
            const spineElement = document.getElementById('spine-char');
            if (spineElement) {
                spineElement.style.left = `${x}px`;
                spineElement.style.top = `${y}px`;
                spineElement.style.transform = 'translate(-50%, -50%)';
            }
            
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç‰ˆnezumiã®å ´åˆã®è¿½åŠ å‡¦ç†
            if (integrationTest.nezumiSkeleton.isFallback) {
                integrationTest.nezumiSkeleton.x = x;
                integrationTest.nezumiSkeleton.y = y;
                integrationTest.log(`ğŸ˜º ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯nezuminä½ç½®: ${x.toFixed(1)}px, ${y.toFixed(1)}px`);
            }
        }
        
        function stopBackgroundSync() {
            const unobserve = integrationTest.activeObservations.get('background-sync');
            if (unobserve) {
                unobserve();
                integrationTest.activeObservations.delete('background-sync');
                backgroundSyncActive = false;
                integrationTest.log('â¹ï¸ èƒŒæ™¯ç”»åƒåŒæœŸåœæ­¢');
                integrationTest.updatePerformanceDisplay();
            }
        }
        
        function resizeBackground(scale) {
            const background = document.getElementById('background-test');
            const currentWidth = background.offsetWidth;
            const newWidth = currentWidth * scale;
            background.style.width = `${newWidth}px`;
            integrationTest.log(`ğŸ“ èƒŒæ™¯ã‚µã‚¤ã‚ºå¤‰æ›´: ${currentWidth}px â†’ ${newWidth}px`);
        }
        
        function moveBackground(direction) {
            const background = document.getElementById('background-test');
            const currentMargin = parseInt(getComputedStyle(background).marginLeft) || 0;
            const offset = direction === 'left' ? -20 : 20;
            background.style.marginLeft = `${currentMargin + offset}px`;
            integrationTest.log(`â†”ï¸ èƒŒæ™¯ä½ç½®ç§»å‹•: ${direction} ${Math.abs(offset)}px`);
        }
        
        function testAnchorPoints() {
            const anchors = ['tl', 'tr', 'bl', 'br', 'center'];
            let index = 0;
            
            const testNext = () => {
                if (index >= anchors.length) {
                    integrationTest.log('ğŸ¯ nezumiã‚¢ãƒ³ã‚«ãƒ¼ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                    return;
                }
                
                const anchor = anchors[index];
                integrationTest.log(`ğŸ“ nezumiã‚¢ãƒ³ã‚«ãƒ¼ãƒ†ã‚¹ãƒˆ: ${anchor}`);
                
                // èƒŒæ™¯è¦ç´ ã®rectã‚’å–å¾—
                const backgroundElement = document.getElementById('background-test');
                const backgroundRect = backgroundElement.getBoundingClientRect();
                
                // ã‚¢ãƒ³ã‚«ãƒ¼ä½ç½®è¨ˆç®—ã—ã¦nezuminæ›´æ–°
                const anchorPosition = calculateAnchorPosition(backgroundRect, anchor);
                updatePurattokuPosition(anchorPosition.x, anchorPosition.y);
                
                // nezumiã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¤‰æ›´
                if (integrationTest.animationState) {
                    const animations = ['taiki', 'click', 'syutugen'];
                    const randomAnim = animations[index % animations.length];
                    integrationTest.animationState.setAnimation(0, randomAnim, anchor === 'center');
                    integrationTest.log(`ğŸ˜º nezumiã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³: ${randomAnim}`);
                }
                
                index++;
                setTimeout(testNext, 1500);
            };
            
            testNext();
        }
        
        // 6.2 ãƒ†ã‚­ã‚¹ãƒˆRangeãƒ”ãƒ³æ©Ÿèƒ½ï¼ˆnezuminçµ±åˆç‰ˆï¼‰
        async function startTextRangePin() {
            if (!integrationTest.observer) return;
            
            const targetSpan = document.getElementById('text-target');
            
            try {
                integrationTest.log(`ğŸ“ 6.2ãƒ†ã‚­ã‚¹ãƒˆRangeãƒ”ãƒ³é–‹å§‹ï¼ˆnezuminãƒ»æˆ¦ç•¥: ${currentStrategy}ï¼‰`);
                
                // ã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§nezumiã‚’ãƒ†ã‚­ã‚¹ãƒˆæœ«å°¾ã«è¿½å¾“
                const customCallback = (textRect, anchor, offset) => {
                    if (integrationTest.nezumiSkeleton) {
                        const pinPosition = {
                            x: textRect.right + (offset?.x || 10),
                            y: textRect.top + (offset?.y || -10)
                        };
                        
                        // å°ã•ã„nezumiã«ã—ã¦ãƒ†ã‚­ã‚¹ãƒˆæ¨ªã«è¡¨ç¤º
                        updatePurattokuForTextPin(pinPosition.x, pinPosition.y);
                        integrationTest.log(`ğŸ“ğŸ˜º nezumin ãƒ†ã‚­ã‚¹ãƒˆãƒ”ãƒ³ä½ç½®: ${pinPosition.x.toFixed(1)}px, ${pinPosition.y.toFixed(1)}px`);
                    }
                };
                
                const unobserve = integrationTest.observer.observeTextRangePin(targetSpan, {
                    strategy: currentStrategy,
                    anchor: 'tr',
                    mode: 'dom',
                    offset: { x: 10, y: -10 },
                    customCallback: customCallback
                });
                
                integrationTest.activeObservations.set('text-pin', unobserve);
                textRangePinActive = true;
                integrationTest.log('âœ… ãƒ†ã‚­ã‚¹ãƒˆRangeãƒ”ãƒ³ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ï¼ˆnezuminçµ±åˆï¼‰', 'success');
                integrationTest.updatePerformanceDisplay();
                
            } catch (error) {
                integrationTest.log(`âŒ ãƒ†ã‚­ã‚¹ãƒˆãƒ”ãƒ³ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
        
        // ãƒ†ã‚­ã‚¹ãƒˆãƒ”ãƒ³ç”¨nezuminä½ç½®æ›´æ–°
        function updatePurattokuForTextPin(x, y) {
            if (!integrationTest.nezumiSkeleton) return;
            
            // DOMè¦ç´ ä½ç½®æ›´æ–°ï¼ˆå°ã•ãè¡¨ç¤ºï¼‰
            const spineElement = document.getElementById('spine-char');
            if (spineElement) {
                spineElement.style.left = `${x}px`;
                spineElement.style.top = `${y}px`;
                spineElement.style.width = '80px';  // å°ã•ã
                spineElement.style.height = '80px';
                spineElement.style.transform = 'translate(-50%, -50%)';
            }
            
            // nezumiã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã€Œæ³¨ç›®ã€ç³»ã«
            if (integrationTest.animationState) {
                integrationTest.animationState.setAnimation(0, 'click', false);
            }
        }
        
        function stopTextRangePin() {
            const unobserve = integrationTest.activeObservations.get('text-pin');
            if (unobserve) {
                unobserve();
                integrationTest.activeObservations.delete('text-pin');
                textRangePinActive = false;
                integrationTest.log('â¹ï¸ ãƒ†ã‚­ã‚¹ãƒˆRangeãƒ”ãƒ³åœæ­¢');
                integrationTest.updatePerformanceDisplay();
            }
        }
        
        function changeTextContent() {
            const textTest = document.getElementById('text-test');
            const newTexts = [
                'ã“ã‚Œã¯å¤‰æ›´ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã§ã™ã€‚<strong>æ–°ã—ã„å†…å®¹</strong>ã§æœ«å°¾è¿½å¾“ã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚<span id="text-target">â†æ–°ã—ã„ä½ç½®</span>',
                'é•·ã„ãƒ†ã‚­ã‚¹ãƒˆã§ã®å‹•ä½œç¢ºèªã§ã™ã€‚æ–‡ç« ãŒè¤‡æ•°è¡Œã«ã‚ãŸã‚‹å ´åˆã®å‹•ä½œã‚’ç¢ºèªã—ã€ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œã‚‚å«ã‚ã¦ç·åˆçš„ã«ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚<span id="text-target">â†é•·æ–‡æœ«å°¾</span>',
                'ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ†ã‚¹ãƒˆã€‚<span id="text-target">â†çŸ­æ–‡</span>'
            ];
            
            const randomText = newTexts[Math.floor(Math.random() * newTexts.length)];
            textTest.innerHTML = `<p>${randomText}</p>`;
            integrationTest.log('ğŸ“ ãƒ†ã‚­ã‚¹ãƒˆå†…å®¹å¤‰æ›´');
        }
        
        function addLineBreaks() {
            const textTest = document.getElementById('text-test');
            textTest.innerHTML += '<p>è¿½åŠ ã•ã‚ŒãŸæ®µè½ã§ã™ã€‚<br>æ”¹è¡Œã‚’å«ã‚“ã§ã„ã¾ã™ã€‚<span id="text-target">â†è¿½åŠ æœ«å°¾</span></p>';
            integrationTest.log('ğŸ“ æ”¹è¡Œãƒ»æ®µè½è¿½åŠ ');
        }
        
        function switchStrategy(strategy) {
            currentStrategy = strategy;
            integrationTest.log(`ğŸ”„ Rangeæˆ¦ç•¥åˆ‡ã‚Šæ›¿ãˆ: ${strategy}`);
            
            if (textRangePinActive) {
                stopTextRangePin();
                setTimeout(() => startTextRangePin(), 100);
            }
        }
        
        // 6.3 ç”»åƒãƒ”ãƒ³æ©Ÿèƒ½
        async function startImagePin(anchor) {
            if (!integrationTest.observer) return;
            
            const imageElement = document.getElementById('test-image-1');
            
            try {
                integrationTest.log(`ğŸ–¼ï¸ 6.3ç”»åƒãƒ”ãƒ³é–‹å§‹ (ã‚¢ãƒ³ã‚«ãƒ¼: ${anchor})`);
                
                const unobserve = integrationTest.observer.observeImagePin(imageElement, {
                    anchor: anchor,
                    mode: 'dom',
                    offset: { x: 5, y: 5 }
                });
                
                integrationTest.activeObservations.set('image-pin', unobserve);
                imagePinActive = true;
                integrationTest.log('âœ… ç”»åƒãƒ”ãƒ³ã‚¢ã‚¯ãƒ†ã‚£ãƒ–', 'success');
                
                // ãƒ”ãƒ³ãƒãƒ¼ã‚«ãƒ¼è¡¨ç¤º
                showPinMarker(imageElement, anchor);
                integrationTest.updatePerformanceDisplay();
                
            } catch (error) {
                integrationTest.log(`âŒ ç”»åƒãƒ”ãƒ³ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
        
        function stopImagePin() {
            const unobserve = integrationTest.activeObservations.get('image-pin');
            if (unobserve) {
                unobserve();
                integrationTest.activeObservations.delete('image-pin');
                imagePinActive = false;
                integrationTest.log('â¹ï¸ ç”»åƒãƒ”ãƒ³åœæ­¢');
                
                // ãƒ”ãƒ³ãƒãƒ¼ã‚«ãƒ¼é™¤å»
                document.querySelectorAll('.pin-marker').forEach(marker => marker.remove());
                integrationTest.updatePerformanceDisplay();
            }
        }
        
        function showPinMarker(imageElement, anchor) {
            // æ—¢å­˜ãƒãƒ¼ã‚«ãƒ¼é™¤å»
            document.querySelectorAll('.pin-marker').forEach(marker => marker.remove());
            
            const marker = document.createElement('div');
            marker.className = 'pin-marker';
            
            const positions = {
                'tl': { left: '0%', top: '0%' },
                'tr': { left: '100%', top: '0%' },
                'bl': { left: '0%', top: '100%' },
                'br': { left: '100%', top: '100%' },
                'center': { left: '50%', top: '50%' }
            };
            
            Object.assign(marker.style, positions[anchor]);
            imageElement.appendChild(marker);
        }
        
        function resizeImage(scale) {
            const image = document.getElementById('test-image-1');
            const currentWidth = image.offsetWidth;
            const newWidth = currentWidth * scale;
            image.style.width = `${newWidth}px`;
            image.style.height = `${newWidth * 0.75}px`; // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ç¶­æŒ
            integrationTest.log(`ğŸ“ ç”»åƒã‚µã‚¤ã‚ºå¤‰æ›´: ${currentWidth}px â†’ ${newWidth}px`);
        }
        
        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£æ©Ÿèƒ½
        function clearLog() {
            integrationTest.logElement.innerHTML = '';
            integrationTest.log('ğŸ§¹ ãƒ­ã‚°ã‚¯ãƒªã‚¢');
        }
        
        function exportLog() {
            const logContent = integrationTest.logElement.innerText;
            const blob = new Blob([logContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `phase3b-test-log-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            integrationTest.log('ğŸ’¾ ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›');
        }
        
        function testDPRChange() {
            integrationTest.log('ğŸ“ DPRå¤‰åŒ–ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³');
            // DPRå¤‰åŒ–ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå®Ÿéš›ã®å¤‰åŒ–ã§ã¯ãªã„ãŒã€ã‚·ã‚¹ãƒ†ãƒ ã®åå¿œã‚’ãƒ†ã‚¹ãƒˆï¼‰
            if (integrationTest.observer.handleDPRChange) {
                integrationTest.observer.handleDPRChange(window.devicePixelRatio * 1.5);
            }
            integrationTest.measureEnvironmentObserverTime();
        }
        
        function testWindowResize() {
            integrationTest.log('ğŸ”„ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³');
            window.dispatchEvent(new Event('resize'));
        }
        
        // nezuminå°‚ç”¨ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½
        function debugPurattokuInfo() {
            if (integrationTest.nezumiSkeleton) {
                if (integrationTest.nezumiSkeleton.isFallback) {
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç‰ˆnezumin
                    const info = {
                        type: 'ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç‰ˆ',
                        position: {
                            x: integrationTest.nezumiSkeleton.x,
                            y: integrationTest.nezumiSkeleton.y
                        },
                        scale: {
                            x: integrationTest.nezumiSkeleton.scaleX,
                            y: integrationTest.nezumiSkeleton.scaleY
                        },
                        currentAnimation: 'CSS Animation'
                    };
                    integrationTest.log(`ğŸ˜º nezuminçŠ¶æ…‹ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰: ${JSON.stringify(info, null, 2)}`);
                    return info;
                } else if (integrationTest.animationState) {
                    // é€šå¸¸ã®Spineç‰ˆnezumin
                    const info = {
                        type: 'Spine WebGLç‰ˆ',
                        position: {
                            x: integrationTest.nezumiSkeleton.x,
                            y: integrationTest.nezumiSkeleton.y
                        },
                        scale: {
                            x: integrationTest.nezumiSkeleton.scaleX,
                            y: integrationTest.nezumiSkeleton.scaleY
                        },
                        currentAnimation: integrationTest.animationState.tracks[0]?.animation?.name || 'none'
                    };
                    integrationTest.log(`ğŸ˜º nezuminçŠ¶æ…‹ï¼ˆSpineï¼‰: ${JSON.stringify(info, null, 2)}`);
                    return info;
                }
            }
            
            integrationTest.log('âŒ nezumiãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
            return null;
        }
        
        // nezumiã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ‡ã‚Šæ›¿ãˆãƒ†ã‚¹ãƒˆ
        function testPurattokuAnimations() {
            if (!integrationTest.animationState) return;
            
            const animations = ['taiki', 'click', 'syutugen'];
            let index = 0;
            
            const playNext = () => {
                if (index >= animations.length) {
                    integrationTest.log('ğŸ˜º nezumiã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                    return;
                }
                
                const anim = animations[index];
                integrationTest.animationState.setAnimation(0, anim, anim === 'taiki');
                integrationTest.log(`ğŸ˜º nezumiã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿ: ${anim}`);
                
                index++;
                setTimeout(playNext, 2000);
            };
            
            playNext();
        }
    </script>
</body>
</html>