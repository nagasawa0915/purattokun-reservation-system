<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FileToHttpBridge Phase 1 MVP テスト</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
        }

        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .test-section h3 {
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .primary-btn {
            background: #4CAF50;
            color: white;
        }

        .primary-btn:hover {
            background: #45a049;
        }

        .secondary-btn {
            background: #2196F3;
            color: white;
        }

        .secondary-btn:hover {
            background: #1976D2;
        }

        .danger-btn {
            background: #f44336;
            color: white;
        }

        .danger-btn:hover {
            background: #d32f2f;
        }

        .log-container {
            background: #1e1e1e;
            color: #00ff00;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin: 10px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .stats-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #2196F3;
        }

        .stats-card h4 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .stats-value {
            font-size: 24px;
            font-weight: bold;
            color: #2196F3;
        }

        .spine-canvas {
            border: 2px solid #ddd;
            border-radius: 5px;
            background: #fff;
            margin: 10px 0;
        }

        .error {
            color: #f44336;
            background: #ffebee;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .success {
            color: #4CAF50;
            background: #e8f5e8;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .file-info {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            font-family: monospace;
        }

        .debug-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="debug-toggle">
        <label>
            <input type="checkbox" id="debugMode" checked> デバッグモード
        </label>
    </div>

    <div class="header">
        <h1>🔥 FileToHttpBridge Phase 1統合 テスト</h1>
        <p>HTTPインターセプト方式 + MeshAttachment.updateRegion問題根本解決</p>
        <p>🎯 サブエージェント調査結果を完全実装したFileToHttpBridge統合版</p>
    </div>

    <!-- Phase 1: HTTPインターセプト核機能テスト -->
    <div class="test-section">
        <h3>🔥 Phase 1: HTTPインターセプト核機能テスト</h3>
        <div class="controls">
            <button class="primary-btn" onclick="selectSpineFolder()">📂 Spineフォルダ選択</button>
            <button class="secondary-btn" onclick="testBlobUrlManager()" disabled>🔗 BlobUrlManager テスト</button>
            <button class="secondary-btn" onclick="testPathGenerator()">🗂️ PathGenerator テスト</button>
            <button class="secondary-btn" onclick="testInterceptor()" disabled>🔄 HTTPインターセプトテスト</button>
            <button class="danger-btn" onclick="cleanup()">🧹 クリーンアップ</button>
        </div>
        <div id="phase1-status"></div>
    </div>

    <!-- Phase 2: FileToHttpBridge Phase 1統合変換テスト -->
    <div class="test-section">
        <h3>🔄 Phase 2: FileToHttpBridge Phase 1統合変換テスト</h3>
        <div class="controls">
            <button class="primary-btn" onclick="testConversion()" disabled id="convertBtn">⚡ Phase 1統合変換実行</button>
            <button class="secondary-btn" onclick="validateConversion()" disabled id="validateBtn">✅ HTTPインターセプト検証</button>
            <button class="secondary-btn" onclick="testMeshAttachmentFix()" disabled id="meshTestBtn">🔧 MeshAttachment問題テスト</button>
        </div>
        <div id="phase2-status"></div>
        <div id="conversion-result"></div>
    </div>

    <!-- Phase 3: StableSpineRenderer Phase 1統合テスト -->
    <div class="test-section">
        <h3>🎮 Phase 3: StableSpineRenderer Phase 1統合テスト</h3>
        <div class="controls">
            <button class="primary-btn" onclick="testSpineIntegration()" disabled id="spineBtn">🎯 Phase 1統合Spineテスト</button>
            <button class="secondary-btn" onclick="verifyMeshAttachmentFix()" disabled id="meshVerifyBtn">🔍 MeshAttachment問題解決確認</button>
        </div>
        <canvas id="spine-canvas" class="spine-canvas" width="400" height="400"></canvas>
        <div id="phase3-status"></div>
    </div>

    <!-- 🔍 成功・失敗パターン比較診断 -->
    <div class="test-section">
        <h3>🔍 成功・失敗パターン比較診断</h3>
        <div class="controls">
            <button class="primary-btn" onclick="runStepByStepDiagnosis()">🔍 段階的診断実行</button>
            <button class="secondary-btn" onclick="showDetailedLogs()">📋 詳細ログ表示</button>
            <button class="secondary-btn" onclick="diagnosticStep = 0; document.getElementById('comparison-result').innerHTML = '';">🔄 診断リセット</button>
        </div>
        <div class="comparison-canvases">
            <div style="display: inline-block; margin: 10px;">
                <h4>✅ 成功パターン (createForCharacter)</h4>
                <canvas id="comparison-success-canvas" class="spine-canvas" width="200" height="200"></canvas>
            </div>
            <div style="display: inline-block; margin: 10px;">
                <h4>❌ 失敗パターン (FileToHttpBridge)</h4>
                <canvas id="comparison-failure-canvas" class="spine-canvas" width="200" height="200"></canvas>
            </div>
        </div>
        <div id="comparison-result"></div>
    </div>

    <!-- 統計情報表示 -->
    <div class="test-section">
        <h3>📊 統計情報・デバッグ情報</h3>
        <div class="controls">
            <button class="secondary-btn" onclick="updateStats()">🔄 統計更新</button>
            <button class="secondary-btn" onclick="clearLogs()">🗑️ ログクリア</button>
        </div>
        <div class="stats-grid" id="stats-grid"></div>
        <div class="log-container" id="log-container"></div>
    </div>

    <!-- 依存ライブラリ読み込み -->
    <!-- Spine WebGL CDN（必須） -->
    <script src="https://unpkg.com/@esotericsoftware/spine-webgl@4.1.24/dist/iife/spine-webgl.js"></script>
    
    <!-- FileToHttpBridge モジュール -->
    <script src="micromodules/bridge/BlobUrlManager.js"></script>
    <script src="micromodules/bridge/PathGenerator.js"></script>
    <script src="micromodules/bridge/FileToHttpBridge.js"></script>
    
    <!-- StableSpineRenderer -->
    <script src="../micromodules/spine-renderer/StableSpineRenderer.js"></script>

    <script>
        // グローバル変数
        let bridge = null;
        let selectedFiles = null;
        let conversionResult = null;
        let spineRenderer = null;
        let debugMode = true;

        // 初期化
        document.addEventListener('DOMContentLoaded', function() {
            initializeBridge();
            updateStats();
            log('🚀 FileToHttpBridge テストページ初期化完了', 'info');
            
            // デフォルトファイル自動選択（開発用）
            loadDefaultSpineFiles();
            
            // デバッグモード切り替え
            document.getElementById('debugMode').addEventListener('change', function(e) {
                debugMode = e.target.checked;
                if (bridge) {
                    bridge.config.debug = debugMode;
                }
                log(`🔧 デバッグモード: ${debugMode ? '有効' : '無効'}`, 'info');
            });
        });

        // Bridge初期化
        function initializeBridge() {
            try {
                bridge = new FileToHttpBridge({
                    debug: debugMode,
                    tempBasePath: '/temp/spine/',
                    logCallback: (message) => log(message, 'bridge')
                });
                
                showStatus('phase1', '✅ FileToHttpBridge初期化完了', 'success');
                log('🌉 FileToHttpBridge初期化成功', 'success');
            } catch (error) {
                showStatus('phase1', `❌ Bridge初期化エラー: ${error.message}`, 'error');
                log(`❌ Bridge初期化失敗: ${error.message}`, 'error');
            }
        }

        // デフォルトSpineファイル読み込み（開発用）
        async function loadDefaultSpineFiles() {
            try {
                log('📂 デフォルトSpineファイル読み込み開始', 'info');
                
                const basePath = '../assets/spine/characters/nezumi/';
                const fileNames = {
                    atlas: 'nezumi.atlas',
                    json: 'nezumi.json',
                    texture: 'nezumi.png'
                };
                
                // HTTPでファイル取得してFileオブジェクトに変換
                const fileHandles = {};
                console.log("🚨 fileHandles構築開始 - undefined URL問題の原因調査");
                
                for (const [type, fileName] of Object.entries(fileNames)) {
                    try {
                        console.log(`🔄 ${type}ファイル読み込み開始: ${fileName}`);
                        const response = await fetch(basePath + fileName);
                        if (!response.ok) {
                            throw new Error(`${fileName}: ${response.status} ${response.statusText}`);
                        }
                        const arrayBuffer = await response.arrayBuffer();
                        const blob = new Blob([arrayBuffer]);
                        
                        // FileSystemFileHandle風のオブジェクト作成
                        fileHandles[type] = {
                            name: fileName,
                            getFile: async () => new File([blob], fileName, { 
                                type: type === 'texture' ? 'image/png' : 'text/plain' 
                            })
                        };
                        console.log(`✅ ${type}ファイル読み込み成功: ${fileName}`);
                    } catch (error) {
                        console.error(`❌ ${type}ファイル読み込み失敗: ${fileName} - ${error.message}`);
                        log(`⚠️ ${fileName}読み込み失敗: ${error.message}`, 'warning');
                        // 🚨 失敗時のキーが設定されない = undefinedの原因
                    }
                }
                
                // 🚨 fileHandles構築結果の詳細チェック
                console.log("🚨 fileHandles構築結果詳細:");
                console.log(`  📋 atlas: ${fileHandles.atlas ? 'OK' : 'MISSING'}`);
                console.log(`  📋 json: ${fileHandles.json ? 'OK' : 'MISSING'}`);
                console.log(`  📋 texture: ${fileHandles.texture ? 'OK' : 'MISSING'}`);
                
                const missingTypes = [];
                if (!fileHandles.atlas) missingTypes.push('atlas');
                if (!fileHandles.json) missingTypes.push('json');
                if (!fileHandles.texture) missingTypes.push('texture');
                
                if (missingTypes.length > 0) {
                    console.error(`🚨 fileHandles欠損検出: ${missingTypes.join(', ')} - これがundefined URL問題の根本原因です`);
                    log(`❌ 必須ファイル欠損: ${missingTypes.join(', ')}`, 'error');
                } else {
                    console.log("✅ fileHandles構築完了 - 全ファイル正常");
                }
                
                // 必要ファイルがすべて読み込めた場合のみ処理続行
                if (fileHandles.atlas && fileHandles.json && fileHandles.texture) {
                    selectedFiles = fileHandles;
                    
                    // UI更新
                    document.getElementById('convertBtn').disabled = false;
                    document.querySelectorAll('button[onclick="testBlobUrlManager()"]')[0].disabled = false;
                    document.querySelectorAll('button[onclick="testInterceptor()"]')[0].disabled = false;
                    
                    // ファイル情報表示
                    let fileInfo = '<div class=\"success\">✅ デフォルトSpineファイル読み込み完了:</div>';
                    for (const [type, handle] of Object.entries(fileHandles)) {
                        fileInfo += `<div class="file-info">${type}: ${handle.name}</div>`;
                    }
                    
                    showStatus('phase1', fileInfo, 'success');
                    log(`✅ デフォルトSpineファイル読み込み完了: nezumi`, 'success');
                } else {
                    throw new Error('必要なファイルの読み込みに失敗しました');
                }
                
            } catch (error) {
                log(`❌ デフォルトファイル読み込み失敗: ${error.message}`, 'error');
                log('💡 手動で「📂 Spineフォルダ選択」を使用してください', 'info');
            }
        }

        // Spineフォルダ選択（File System Access API）
        async function selectSpineFolder() {
            try {
                log('📂 Spineフォルダ選択開始', 'info');

                if (!('showDirectoryPicker' in window)) {
                    throw new Error('File System Access APIがサポートされていません');
                }

                // ディレクトリ選択
                const dirHandle = await window.showDirectoryPicker({
                    mode: 'read',
                    startIn: 'documents'
                });

                log(`📁 選択フォルダ: ${dirHandle.name}`, 'info');

                // 必要ファイル検索
                const requiredFiles = ['atlas', 'json', 'png', 'jpg'];
                const foundFiles = {};

                for await (const [name, handle] of dirHandle.entries()) {
                    if (handle.kind === 'file') {
                        const extension = name.split('.').pop().toLowerCase();
                        
                        if (extension === 'atlas') {
                            foundFiles.atlas = handle;
                        } else if (extension === 'json') {
                            foundFiles.json = handle;
                        } else if (['png', 'jpg', 'jpeg'].includes(extension)) {
                            foundFiles.texture = handle;
                        }
                    }
                }

                // ファイル検証
                if (!foundFiles.atlas || !foundFiles.json || !foundFiles.texture) {
                    const missing = [];
                    if (!foundFiles.atlas) missing.push('atlas');
                    if (!foundFiles.json) missing.push('json');
                    if (!foundFiles.texture) missing.push('texture');
                    throw new Error(`必要なファイルが見つかりません: ${missing.join(', ')}`);
                }

                selectedFiles = foundFiles;
                
                // UI更新
                document.getElementById('convertBtn').disabled = false;
                document.querySelectorAll('button[onclick="testBlobUrlManager()"]')[0].disabled = false;
                document.querySelectorAll('button[onclick="testInterceptor()"]')[0].disabled = false;
                
                // ファイル情報表示
                let fileInfo = '<div class=\"success\">✅ Spineファイル選択完了:</div>';
                for (const [type, handle] of Object.entries(foundFiles)) {
                    fileInfo += `<div class="file-info">${type}: ${handle.name}</div>`;
                }
                
                showStatus('phase1', fileInfo, 'success');
                log(`✅ Spineファイル選択完了: ${Object.keys(foundFiles).length}件`, 'success');

            } catch (error) {
                showStatus('phase1', `❌ ファイル選択エラー: ${error.message}`, 'error');
                log(`❌ ファイル選択失敗: ${error.message}`, 'error');
            }
        }

        // BlobUrlManagerテスト
        async function testBlobUrlManager() {
            try {
                log('🔗 BlobUrlManager単体テスト開始', 'info');

                const manager = new BlobUrlManager({ debug: debugMode });
                
                // テスト用ファイル作成
                const testFile = new File(['test content'], 'test.txt', { type: 'text/plain' });
                
                // Blob URL作成テスト
                const url = manager.createBlobUrl(testFile, 'text/plain');
                log(`📎 Blob URL作成テスト成功: ${url.substring(0, 50)}...`, 'success');
                
                // メタデータ取得テスト
                const metadata = manager.getMetadata(url);
                log(`📋 メタデータ取得テスト成功: ${JSON.stringify(metadata, null, 2)}`, 'info');
                
                // URL解放テスト
                const revoked = manager.revokeBlobUrl(url);
                log(`🗑️ URL解放テスト成功: ${revoked}`, 'success');
                
                showStatus('phase1', '✅ BlobUrlManager単体テスト完了', 'success');

            } catch (error) {
                showStatus('phase1', `❌ BlobUrlManagerテストエラー: ${error.message}`, 'error');
                log(`❌ BlobUrlManagerテスト失敗: ${error.message}`, 'error');
            }
        }

        // PathGeneratorテスト
        function testPathGenerator() {
            try {
                log('🗂️ PathGenerator単体テスト開始', 'info');

                // ベースパス生成テスト
                const basePath = PathGenerator.generateBasePath('nezumi');
                log(`📁 ベースパス生成テスト: ${basePath}`, 'info');

                // ファイルパス生成テスト
                const filePath = PathGenerator.generateFilePath(basePath, 'nezumi.atlas', 'atlas');
                log(`📄 ファイルパス生成テスト: ${filePath}`, 'info');

                // パス正規化テスト
                const normalized = PathGenerator.normalizePath('//temp//spine\\nezumi\\');
                log(`🔄 パス正規化テスト: ${normalized}`, 'info');

                // 完全パスセット生成テスト
                const pathSet = PathGenerator.generateCompletePathSet('nezumi', {
                    atlas: 'nezumi.atlas',
                    json: 'nezumi.json',
                    texture: 'nezumi.png'
                });
                log(`📦 完全パスセット生成テスト: ${JSON.stringify(pathSet, null, 2)}`, 'info');

                showStatus('phase1', '✅ PathGenerator単体テスト完了', 'success');

            } catch (error) {
                showStatus('phase1', `❌ PathGeneratorテストエラー: ${error.message}`, 'error');
                log(`❌ PathGeneratorテスト失敗: ${error.message}`, 'error');
            }
        }

        // File → HTTP変換テスト
        async function testConversion() {
            try {
                if (!selectedFiles) {
                    throw new Error('Spineファイルが選択されていません');
                }

                log('⚡ File → HTTP変換テスト開始', 'info');
                showStatus('phase2', '🔄 変換処理中...', 'info');

                const characterName = 'nezumi';
                conversionResult = await bridge.convertCharacterFiles(characterName, selectedFiles);

                // 変換結果表示
                let resultHtml = '<div class=\"success\">✅ 変換完了:</div>';
                resultHtml += `<div class="file-info">キャラクター名: ${conversionResult.characterName}</div>`;
                resultHtml += `<div class="file-info">ベースパス: ${conversionResult.basePath}</div>`;
                resultHtml += `<div class="file-info">変換時間: ${conversionResult.stats.conversionTime}ms</div>`;
                resultHtml += `<div class="file-info">総ファイルサイズ: ${formatSize(conversionResult.stats.totalSize)}</div>`;
                
                resultHtml += '<h4>生成されたファイルパス:</h4>';
                for (const [type, path] of Object.entries(conversionResult.files)) {
                    resultHtml += `<div class="file-info">${type}: ${path}</div>`;
                }

                document.getElementById('conversion-result').innerHTML = resultHtml;
                showStatus('phase2', '✅ File → HTTP変換完了', 'success');

                // 次のステップ有効化
                document.getElementById('validateBtn').disabled = false;
                document.getElementById('meshTestBtn').disabled = false;
                document.getElementById('spineBtn').disabled = false;
                document.getElementById('meshVerifyBtn').disabled = false;

                log(`✅ File → HTTP変換成功: ${characterName}`, 'success');

            } catch (error) {
                showStatus('phase2', `❌ 変換エラー: ${error.message}`, 'error');
                log(`❌ 変換失敗: ${error.message}`, 'error');
            }
        }

        // 変換検証
        async function validateConversion() {
            try {
                if (!conversionResult) {
                    throw new Error('変換結果がありません');
                }

                log('✅ 変換結果検証開始', 'info');

                // Blob URL存在確認
                for (const [type, blobUrl] of Object.entries(conversionResult.blobUrls)) {
                    try {
                        const response = await fetch(blobUrl);
                        if (!response.ok) {
                            throw new Error(`${type} Blob URLアクセス失敗: ${response.status}`);
                        }
                        log(`✅ ${type} Blob URL検証成功: ${blobUrl.substring(0, 50)}...`, 'success');
                    } catch (error) {
                        throw new Error(`${type} Blob URL検証失敗: ${error.message}`);
                    }
                }

                showStatus('phase2', '✅ 変換結果検証完了 - 全てのBlob URLにアクセス可能', 'success');
                log('✅ 変換結果検証完了', 'success');

            } catch (error) {
                showStatus('phase2', `❌ 検証エラー: ${error.message}`, 'error');
                log(`❌ 検証失敗: ${error.message}`, 'error');
            }
        }

        // StableSpineRenderer統合テスト
        async function testSpineIntegration() {
            try {
                if (!conversionResult) {
                    throw new Error('変換結果がありません');
                }

                log('🎮 StableSpineRenderer統合テスト開始', 'info');
                showStatus('phase3', '🔄 Spine初期化中...', 'info');

                // 変換結果のデバッグ情報出力
                log('📋 変換結果構造確認:', 'debug');
                log(`  characterName: ${conversionResult.characterName}`, 'debug');
                log(`  basePath: ${conversionResult.basePath}`, 'debug');
                log(`  blobUrls存在: ${conversionResult.blobUrls ? 'YES' : 'NO'}`, 'debug');
                if (conversionResult.blobUrls) {
                    log(`  atlas: ${conversionResult.blobUrls.atlas ? 'YES' : 'NO'}`, 'debug');
                    log(`  json: ${conversionResult.blobUrls.json ? 'YES' : 'NO'}`, 'debug');
                    log(`  texture: ${conversionResult.blobUrls.texture ? 'YES' : 'NO'}`, 'debug');
                }

                // デバッグ: 変換結果全体をコンソール出力
                console.log("🔍 conversionResult全体:", conversionResult);
                console.log("🔍 conversionResult.blobUrls:", conversionResult.blobUrls);
                
                // 🚨 undefined URL問題を特定するため詳細デバッグ
                if (conversionResult.blobUrls) {
                    console.log("🚨 blobUrls詳細デバッグ:");
                    console.log(`  📋 atlas: ${conversionResult.blobUrls.atlas || 'UNDEFINED'}`);
                    console.log(`  📋 json: ${conversionResult.blobUrls.json || 'UNDEFINED'}`);
                    console.log(`  📋 texture: ${conversionResult.blobUrls.texture || 'UNDEFINED'}`);
                    
                    // undefined検出
                    const undefinedKeys = [];
                    if (!conversionResult.blobUrls.atlas) undefinedKeys.push('atlas');
                    if (!conversionResult.blobUrls.json) undefinedKeys.push('json');
                    if (!conversionResult.blobUrls.texture) undefinedKeys.push('texture');
                    
                    if (undefinedKeys.length > 0) {
                        console.error(`🚨 undefined Blob URL検出: ${undefinedKeys.join(', ')}`);
                        console.log("🔍 このundefinedがStableSpineRendererのfetch(undefined)の原因です");
                    }
                } else {
                    console.error("🚨 conversionResult.blobUrls自体がundefinedです");
                }

                // 🔥 修正: Canvas要素を動的に再作成して競合回避
                const canvas = document.createElement('canvas');
                canvas.width = 400;
                canvas.height = 400;
                canvas.style.border = '2px dashed rgba(255, 0, 0, 0.3)';
                canvas.style.display = 'block';
                canvas.style.margin = '0 auto';
                
                // 既存のCanvasと置き換え
                const oldCanvas = document.getElementById('spine-canvas');
                oldCanvas.parentNode.replaceChild(canvas, oldCanvas);
                canvas.id = 'spine-canvas';
                
                console.log("🎯 新しいCanvas要素作成完了");
                console.log(`Canvas情報: ${canvas.width}x${canvas.height}`);

                // StableSpineRenderer初期化
                const spineConfig = {
                    canvas: canvas, // DOM要素を直接渡す
                    character: conversionResult.characterName,
                    basePath: conversionResult.basePath,
                    blobUrls: conversionResult.blobUrls, // FileToHttpBridge Blob URL統合
                    debug: debugMode,
                    logCallback: (message) => log(`[Spine] ${message}`, 'spine')
                };
                
                console.log("🔍 spineConfig:", spineConfig);
                spineRenderer = new StableSpineRenderer(spineConfig);

                // 初期化実行
                console.log("🚀 StableSpineRenderer初期化開始...");
                await spineRenderer.initialize();
                console.log("✅ StableSpineRenderer初期化完了");

                // 🎯 重要: 初期化完了後、明示的にアニメーション開始確認
                if (!spineRenderer.isAnimationRunning) {
                    console.log("🎨 手動でアニメーション開始...");
                    const animationResult = spineRenderer.startAnimation();
                    console.log(`✅ startAnimation() 実行結果: ${animationResult}`);
                } else {
                    console.log("ℹ️ アニメーションは既に実行中です");
                }

                showStatus('phase3', '✅ StableSpineRenderer統合テスト完了 - Spine描画成功', 'success');
                log('🎉 StableSpineRenderer統合テスト完了', 'success');

            } catch (error) {
                showStatus('phase3', `❌ Spine統合エラー: ${error.message}`, 'error');
                log(`❌ Spine統合失敗: ${error.message}`, 'error');
            }
        }

        // クリーンアップ
        function cleanup() {
            try {
                log('🧹 クリーンアップ開始', 'info');

                let cleanupCount = 0;

                if (bridge) {
                    cleanupCount = bridge.cleanup();
                }

                if (spineRenderer) {
                    // StableSpineRenderer停止
                    spineRenderer = null;
                }

                conversionResult = null;

                // UI初期化
                document.getElementById('convertBtn').disabled = selectedFiles ? false : true;
                document.getElementById('validateBtn').disabled = true;
                document.getElementById('spineBtn').disabled = true;
                document.getElementById('conversion-result').innerHTML = '';

                // Canvas初期化
                const canvas = document.getElementById('spine-canvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                showStatus('phase1', `✅ クリーンアップ完了: ${cleanupCount}件`, 'success');
                log(`✅ クリーンアップ完了: ${cleanupCount}件`, 'success');

                updateStats();

            } catch (error) {
                showStatus('phase1', `❌ クリーンアップエラー: ${error.message}`, 'error');
                log(`❌ クリーンアップ失敗: ${error.message}`, 'error');
            }
        }

        // 統計情報更新
        function updateStats() {
            try {
                const stats = bridge ? bridge.getStats() : null;
                const statsGrid = document.getElementById('stats-grid');

                if (!stats) {
                    statsGrid.innerHTML = '<div class="stats-card"><h4>統計情報</h4><div class="stats-value">初期化待ち</div></div>';
                    return;
                }

                statsGrid.innerHTML = `
                    <div class="stats-card">
                        <h4>総変換回数</h4>
                        <div class="stats-value">${stats.totalConversions}</div>
                    </div>
                    <div class="stats-card">
                        <h4>成功率</h4>
                        <div class="stats-value">${stats.performance.successRate}</div>
                    </div>
                    <div class="stats-card">
                        <h4>アクティブキャラクター</h4>
                        <div class="stats-value">${stats.activeCharacters.length}</div>
                    </div>
                    <div class="stats-card">
                        <h4>Blob URL数</h4>
                        <div class="stats-value">${stats.memoryUsage.blobUrls}</div>
                    </div>
                    <div class="stats-card">
                        <h4>推定メモリ使用量</h4>
                        <div class="stats-value">${formatSize(stats.memoryUsage.estimatedSize)}</div>
                    </div>
                    <div class="stats-card">
                        <h4>稼働時間</h4>
                        <div class="stats-value">${Math.round(stats.uptime / 1000)}s</div>
                    </div>
                `;

                log('📊 統計情報更新完了', 'info');

            } catch (error) {
                log(`❌ 統計更新エラー: ${error.message}`, 'error');
            }
        }

        // ユーティリティ関数
        function showStatus(phase, message, type = 'info') {
            const element = document.getElementById(`${phase}-status`);
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : 'info';
            element.innerHTML = `<div class="${className}">${message}</div>`;
        }

        function log(message, type = 'info') {
            const logContainer = document.getElementById('log-container');
            const timestamp = new Date().toLocaleTimeString();
            const logClass = type === 'error' ? 'color: #ff6b6b;' : 
                            type === 'success' ? 'color: #4CAF50;' :
                            type === 'bridge' ? 'color: #2196F3;' :
                            type === 'spine' ? 'color: #ff9800;' : 'color: #00ff00;';
            
            logContainer.innerHTML += `<div style="${logClass}">[${timestamp}] ${message}</div>`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function clearLogs() {
            document.getElementById('log-container').innerHTML = '';
            log('🗑️ ログクリア完了', 'info');
        }

        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const units = ['B', 'KB', 'MB', 'GB'];
            const base = 1024;
            const index = Math.floor(Math.log(bytes) / Math.log(base));
            return (bytes / Math.pow(base, index)).toFixed(1) + ' ' + units[index];
        }

        // 🔥 Phase 1統合: 新しいテスト関数群
        
        // HTTPインターセプトテスト
        async function testInterceptor() {
            try {
                if (!selectedFiles) {
                    throw new Error('Spineファイルが選択されていません');
                }

                log('🔄 HTTPインターセプト機能テスト開始', 'info');

                // 変換がまだの場合は実行
                if (!conversionResult) {
                    await testConversion();
                }

                // Bridge HTTPインターセプト確認
                const stats = bridge.getStats();
                const mapping = bridge.pathToBlobMapping;
                
                log(`📊 HTTPインターセプト状況: マッピング数 ${mapping.size}`, 'info');
                
                // マッピングの詳細確認
                let mappingCount = 0;
                for (const [virtualPath, blobUrl] of mapping.entries()) {
                    log(`🗺️ [${mappingCount + 1}] ${virtualPath} → ${blobUrl.substring(0, 30)}...`, 'info');
                    mappingCount++;
                }

                // fetch インターセプトテスト
                log('🧪 fetch インターセプトテスト実行', 'info');
                const testUrls = Array.from(mapping.keys()).slice(0, 3);
                
                for (const testUrl of testUrls) {
                    try {
                        console.log(`🔄 fetchテスト: ${testUrl}`);
                        const response = await fetch(testUrl);
                        if (response.ok) {
                            log(`✅ fetchインターセプト成功: ${testUrl}`, 'success');
                        } else {
                            log(`❌ fetchインターセプト失敗: ${testUrl} (${response.status})`, 'error');
                        }
                    } catch (error) {
                        log(`❌ fetchテストエラー: ${testUrl} - ${error.message}`, 'error');
                    }
                }

                showStatus('phase1', '✅ HTTPインターセプト機能テスト完了', 'success');

            } catch (error) {
                showStatus('phase1', `❌ HTTPインターセプトテストエラー: ${error.message}`, 'error');
                log(`❌ HTTPインターセプトテスト失敗: ${error.message}`, 'error');
            }
        }

        // MeshAttachment問題解決テスト
        async function testMeshAttachmentFix() {
            try {
                if (!conversionResult) {
                    throw new Error('変換結果がありません');
                }

                log('🔧 MeshAttachment問題解決テスト開始', 'info');
                showStatus('phase2', '🔄 MeshAttachmentテスト実行中...', 'info');

                // Image作成テスト（FileToHttpBridge インターセプト経由）
                const testImageUrl = conversionResult.blobUrls.texture;
                const testImage = new Image();
                
                await new Promise((resolve, reject) => {
                    testImage.onload = () => {
                        log(`✅ Image読み込み成功: ${testImage.width}x${testImage.height}`, 'success');
                        resolve();
                    };
                    testImage.onerror = (error) => {
                        log(`❌ Image読み込み失敗`, 'error');
                        reject(error);
                    };
                    
                    console.log(`🖼️ Image.src設定テスト: nezumi.png`);
                    testImage.src = 'nezumi.png'; // FileToHttpBridge でインターセプトされるはず
                });

                // さらに詳細なマッピング確認
                const characterName = conversionResult.characterName;
                const texturePatterns = [
                    `${characterName}.png`,
                    `${characterName}.jpg`,
                    'nezumi.png',
                    'purattokun.png'
                ];

                for (const pattern of texturePatterns) {
                    const mapped = bridge.pathToBlobMapping.get(pattern);
                    if (mapped) {
                        log(`✅ テクスチャパターン確認: ${pattern} → Blob URL存在`, 'success');
                    } else {
                        log(`⚠️ テクスチャパターン未対応: ${pattern}`, 'warning');
                    }
                }

                showStatus('phase2', '✅ MeshAttachment問題解決テスト完了', 'success');

            } catch (error) {
                showStatus('phase2', `❌ MeshAttachmentテストエラー: ${error.message}`, 'error');
                log(`❌ MeshAttachmentテスト失敗: ${error.message}`, 'error');
            }
        }

        // MeshAttachment問題解決確認
        async function verifyMeshAttachmentFix() {
            try {
                if (!spineRenderer) {
                    throw new Error('StableSpineRenderer が初期化されていません');
                }

                log('🔍 MeshAttachment問題解決確認開始', 'info');
                showStatus('phase3', '🔄 MeshAttachment解決確認中...', 'info');

                // SpineRenderer の内部状態確認
                const status = spineRenderer.getStatus();
                log(`📊 SpineRenderer状態: 初期化済み=${status.initialized}, アニメーション中=${status.isAnimationRunning}`, 'info');

                // グローバルスパイン要素確認
                if (window.globalSpinePageMap) {
                    log(`🗺️ Global Spine Page Map: ${window.globalSpinePageMap.size}個のページ`, 'info');
                } else {
                    log('⚠️ Global Spine Page Map が存在しません', 'warning');
                }

                // MeshAttachment インターセプト確認
                if (window.spine && window.spine.MeshAttachment) {
                    const meshProto = window.spine.MeshAttachment.prototype;
                    if (meshProto.updateRegion.toString().includes('インターセプト')) {
                        log('✅ MeshAttachment.updateRegion インターセプトが有効です', 'success');
                    } else {
                        log('⚠️ MeshAttachment.updateRegion インターセプトが検出されません', 'warning');
                    }
                }

                // 描画エラー監視
                let renderErrors = 0;
                const originalConsoleError = console.error;
                console.error = function(...args) {
                    if (args.some(arg => typeof arg === 'string' && arg.includes('updateRegion'))) {
                        renderErrors++;
                    }
                    originalConsoleError.apply(console, args);
                };

                // 3秒間レンダリング監視
                setTimeout(() => {
                    console.error = originalConsoleError;
                    if (renderErrors === 0) {
                        log('✅ MeshAttachment.updateRegion エラー検出されず - 問題解決確認', 'success');
                        showStatus('phase3', '✅ MeshAttachment問題解決確認 - エラーなし', 'success');
                    } else {
                        log(`❌ MeshAttachment.updateRegion エラー検出: ${renderErrors}回`, 'error');
                        showStatus('phase3', `❌ MeshAttachment問題未解決 - エラー${renderErrors}回`, 'error');
                    }
                }, 3000);

                log('⏳ 3秒間のレンダリングエラー監視を開始しました...', 'info');

            } catch (error) {
                showStatus('phase3', `❌ MeshAttachment確認エラー: ${error.message}`, 'error');
                log(`❌ MeshAttachment確認失敗: ${error.message}`, 'error');
            }
        }

        // 定期統計更新
        setInterval(updateStats, 5000);

        // selectSpineFolder関数を定義（175行目で使用）
        function selectSpineFolder() {
            // フォルダ選択ダイアログを開く代わりに、デフォルトSpineファイルを読み込み
            loadDefaultSpineFiles();
        }
    </script>

    <!-- 緊急デバッグセクション -->
    <div class="test-section">
        <h3>🔬 緊急デバッグ - SpineJS内部解析</h3>
        <div class="controls">
            <button class="danger-btn" onclick="runEmergencyDebugTest()">⚡ 緊急デバッグテスト</button>
            <button class="secondary-btn" onclick="showDetailedLogs()">📋 詳細ログ表示</button>
            <button class="primary-btn" onclick="runMeshAttachmentAnalysis()">🔍 MeshAttachment詳細分析</button>
        </div>
        <div id="emergency-debug-result"></div>
    </div>

    <!-- MeshAttachment分析ツール読み込み -->
    <script src="../debug-mesh-attachment-analysis.js"></script>

    <script>
    // 緊急デバッグテスト関数
    async function runEmergencyDebugTest() {
        try {
            console.log("🚨 緊急デバッグテスト開始 - getImage詳細追跡");
            document.getElementById("emergency-debug-result").innerHTML = "<div class=\"info\">🔄 緊急デバッグテスト実行中...</div>";
            
            // デフォルトファイルを使用して即座にテスト
            if (!selectedFiles) {
                await loadDefaultSpineFiles();
            }
            
            if (!conversionResult) {
                await testConversion();
            }
            
            console.log("🎯 StableSpineRenderer初期化 - getImage詳細追跡モード");
            await testSpineIntegration();
            
            document.getElementById("emergency-debug-result").innerHTML = "<div class=\"success\">✅ 緊急デバッグテスト完了 - F12コンソールで詳細ログを確認</div>";
            
        } catch (error) {
            console.error("❌ 緊急デバッグテスト失敗:", error);
            document.getElementById("emergency-debug-result").innerHTML = `<div class="error">❌ 緊急デバッグテスト失敗: ${error.message}</div>`;
        }
    }
    
    // 詳細ログ表示関数
    function showDetailedLogs() {
        const logContainer = document.getElementById("log-container");
        logContainer.style.maxHeight = "500px";
        logContainer.scrollTop = logContainer.scrollHeight;
        console.log("📋 ログ表示を拡張しました - getImage関数の詳細な呼び出し状況を確認してください");
    }
    
    // 🔍 段階的安全診断 - コンソールクラッシュ防止版
    let diagnosticStep = 0;
    let successRenderer = null;
    let failureRenderer = null;
    
    async function runStepByStepDiagnosis() {
        try {
            diagnosticStep++;
            console.log(`🔍 段階 ${diagnosticStep}: 安全診断モード`);
            
            const resultDiv = document.getElementById("comparison-result");
            
            switch (diagnosticStep) {
                case 1:
                    resultDiv.innerHTML = "<div class=\"info\">Step 1: 成功パターン構造分析中...</div>";
                    await analyzeSucessPattern();
                    break;
                case 2:
                    resultDiv.innerHTML = "<div class=\"info\">Step 2: 失敗パターン準備中...</div>";
                    await prepareFailurePattern();
                    break;
                case 3:
                    resultDiv.innerHTML = "<div class=\"info\">Step 3: 失敗パターン構造分析中...</div>";
                    await analyzeFailurePattern();
                    break;
                case 4:
                    resultDiv.innerHTML = "<div class=\"info\">Step 4: 詳細差異比較中...</div>";
                    await comparePatterns();
                    break;
                case 5:
                    resultDiv.innerHTML = "<div class=\"info\">Step 5: getImage()詳細テスト中...</div>";
                    await testGetImageDetails();
                    break;
                default:
                    diagnosticStep = 0;
                    resultDiv.innerHTML = "<div class=\"success\">✅ 全段階完了 - 診断をリセット</div>";
            }
            
        } catch (error) {
            console.error(`❌ 段階 ${diagnosticStep} 診断失敗:`, error);
            document.getElementById("comparison-result").innerHTML = `<div class="error">❌ Step ${diagnosticStep} 失敗: ${error.message}</div>`;
        }
    }
    
    async function analyzeSucessPattern() {
        console.log("✅ 成功パターン分析開始 - メモリ使用量監視");
        
        if (!successRenderer) {
            successRenderer = new StableSpineRenderer({
                character: 'nezumi',
                canvasId: 'comparison-success-canvas'
            });
            await successRenderer.initialize();
            
            // 🎯 重要: 成功パターンのアニメーション開始
            console.log("🎨 成功パターンアニメーション開始");
            if (successRenderer.startAnimation && typeof successRenderer.startAnimation === 'function') {
                successRenderer.startAnimation();
                console.log("✅ 成功パターン: startAnimation() 実行完了");
            } else {
                console.warn("⚠️ 成功パターン: startAnimation() メソッドが見つかりません");
            }
        }
        
        // StableSpineRendererのatlas参照を複数の方法で試行
        const atlas = successRenderer.atlas || successRenderer.textureAtlas || successRenderer.assetManager?.get('nezumi.atlas');
        const analysis = {
            pages_count: atlas ? atlas.pages?.length || 0 : 0,
            regions_count: atlas ? atlas.regions?.length || 0 : 0,
            page0_exists: atlas?.pages?.[0] ? true : false,
            page0_texture_exists: atlas?.pages?.[0]?.texture ? true : false,
            page0_getImage_exists: typeof atlas?.pages?.[0]?.texture?.getImage === 'function',
            page0_getImage_result: null
        };
        
        // 安全なgetImage()テスト
        if (analysis.page0_getImage_exists) {
            try {
                analysis.page0_getImage_result = atlas?.pages?.[0]?.texture?.getImage?.();
                analysis.getImage_type = analysis.page0_getImage_result ? typeof analysis.page0_getImage_result : 'null';
            } catch (e) {
                analysis.getImage_error = e.message;
            }
        }
        
        // 🔍 重要: pageオブジェクトにgetImageメソッドがあるかチェック
        if (atlas?.pages?.[0]) {
            analysis.page0_has_getImage_method = typeof atlas.pages[0].getImage === 'function';
            analysis.page0_direct_getImage = atlas.pages[0].getImage ? 'メソッド存在' : 'メソッドなし';
        }
        
        console.log("✅ 成功パターン分析結果:", analysis);
        document.getElementById("comparison-result").innerHTML = `
            <div class="success">✅ 成功パターン分析完了</div>
            <div class="info">Pages: ${analysis.pages_count}, Regions: ${analysis.regions_count}</div>
            <div class="info">getImage(): ${analysis.page0_getImage_result ? '正常' : 'null/エラー'}</div>
        `;
    }
    
    async function prepareFailurePattern() {
        console.log("❌ 失敗パターン準備開始");
        
        // デフォルトファイル準備
        if (!selectedFiles) {
            await loadDefaultSpineFiles();
        }
        if (!conversionResult) {
            await testConversion();
        }
        
        document.getElementById("comparison-result").innerHTML = "<div class=\"success\">✅ 失敗パターン準備完了</div>";
        console.log("❌ 失敗パターン準備完了 - Blob URLs利用可能");
    }
    
    async function analyzeFailurePattern() {
        console.log("❌ 失敗パターン分析開始");
        
        // 🚨 修正: conversionResult.blobUrls を正しく使用
        console.log("🚨 analyzeFailurePattern - blobUrls取得:");
        console.log("  conversionResult.blobUrls:", conversionResult.blobUrls);
        
        const blobUrls = {
            atlas: conversionResult.blobUrls?.atlas,
            json: conversionResult.blobUrls?.json,
            texture: conversionResult.blobUrls?.texture
        };
        
        console.log("🚨 analyzeFailurePattern - 修正後blobUrls:", blobUrls);
        
        if (!failureRenderer) {
            failureRenderer = new StableSpineRenderer({
                character: 'nezumi', // 成功パターンと同じパス名を使用
                canvasId: 'comparison-failure-canvas',
                blobUrls: blobUrls
            });
            await failureRenderer.initialize();
            
            // 🎯 重要: FileToHttpBridgeパターンのアニメーション開始
            console.log("🎨 FileToHttpBridgeパターンアニメーション開始");
            if (failureRenderer.startAnimation && typeof failureRenderer.startAnimation === 'function') {
                failureRenderer.startAnimation();
                console.log("✅ FileToHttpBridgeパターン: startAnimation() 実行完了");
            } else {
                console.warn("⚠️ FileToHttpBridgeパターン: startAnimation() メソッドが見つかりません");
            }
        }
        
        // StableSpineRendererのatlas参照を複数の方法で試行
        console.log("🚨 診断: failureRenderer構造調査");
        console.log("  📋 failureRenderer.atlas:", failureRenderer.atlas?.constructor?.name);
        console.log("  📋 failureRenderer.textureAtlas:", failureRenderer.textureAtlas?.constructor?.name);
        console.log("  📋 assetManager.get('nezumi.atlas'):", failureRenderer.assetManager?.get('nezumi.atlas')?.constructor?.name);
        
        // assetManager.get('nezumi.atlas')はString型なので、実際のTextureAtlasを探す
        let atlas = failureRenderer.atlas || failureRenderer.textureAtlas;
        
        // 内部のTextureAtlasインスタンスを探す
        if (!atlas) {
            // StableSpineRendererの内部構造から直接TextureAtlasを取得
            const internalAtlas = failureRenderer.attachmentLoader?.atlas || failureRenderer.skeletonJson?.attachmentLoader?.atlas;
            if (internalAtlas && typeof internalAtlas.findRegion === 'function') {
                atlas = internalAtlas;
                console.log("🎯 診断: 内部TextureAtlas発見:", atlas.constructor?.name);
            }
        }
        const analysis = {
            pages_count: atlas?.pages?.length || 0,
            regions_count: atlas?.regions?.length || 0,
            page0_exists: atlas?.pages?.[0] ? true : false,
            page0_texture_exists: atlas?.pages?.[0]?.texture ? true : false,
            page0_getImage_exists: typeof atlas?.pages?.[0]?.texture?.getImage === 'function',
            page0_getImage_result: null
        };
        
        // 安全なgetImage()テスト
        if (analysis.page0_getImage_exists) {
            try {
                analysis.page0_getImage_result = atlas?.pages?.[0]?.texture?.getImage?.() || atlas?.pages?.[0]?.getImage?.();
                analysis.getImage_type = analysis.page0_getImage_result ? typeof analysis.page0_getImage_result : 'null';
            } catch (e) {
                analysis.getImage_error = e.message;
            }
        }
        
        console.log("❌ 失敗パターン分析結果:", analysis);
        document.getElementById("comparison-result").innerHTML = `
            <div class="success">✅ 失敗パターン分析完了</div>
            <div class="info">Pages: ${analysis.pages_count}, Regions: ${analysis.regions_count}</div>
            <div class="info">getImage(): ${analysis.page0_getImage_result ? '正常' : 'null/エラー'}</div>
        `;
    }
    
    async function comparePatterns() {
        console.log("🔍 パターン比較開始");
        
        const successAtlas = successRenderer?.atlas;
        const failureAtlas = failureRenderer?.atlas;
        
        const comparison = {
            success_pages: successAtlas?.pages?.length || 0,
            failure_pages: failureAtlas?.pages?.length || 0,
            success_regions: successAtlas?.regions?.length || 0,
            failure_regions: failureAtlas?.regions?.length || 0,
            success_getImage: null,
            failure_getImage: null,
            success_texture_type: successAtlas?.pages?.[0]?.texture?.constructor?.name,
            failure_texture_type: failureAtlas?.pages?.[0]?.texture?.constructor?.name
        };
        
        // 安全なgetImage比較
        try {
            comparison.success_getImage = successAtlas?.pages?.[0]?.texture?.getImage?.();
        } catch (e) {
            comparison.success_getImage_error = e.message;
        }
        
        try {
            comparison.failure_getImage = failureAtlas?.pages?.[0]?.texture?.getImage?.();
        } catch (e) {
            comparison.failure_getImage_error = e.message;
        }
        
        console.log("🎯 詳細比較結果:", comparison);
        document.getElementById("comparison-result").innerHTML = `
            <div class="success">✅ パターン比較完了</div>
            <div class="info">📊 Pages - 成功: ${comparison.success_pages}, 失敗: ${comparison.failure_pages}</div>
            <div class="info">📊 Regions - 成功: ${comparison.success_regions}, 失敗: ${comparison.failure_regions}</div>
            <div class="info">🎯 getImage - 成功: ${comparison.success_getImage ? '正常' : 'null'}, 失敗: ${comparison.failure_getImage ? '正常' : 'null'}</div>
            <div class="info">🔧 Texture型 - 成功: ${comparison.success_texture_type}, 失敗: ${comparison.failure_texture_type}</div>
        `;
    }
    
    async function testGetImageDetails() {
        console.log("🔬 getImage()詳細テスト開始");
        
        const details = {
            success: {},
            failure: {}
        };
        
        // 成功パターン詳細
        if (successRenderer?.atlas?.pages?.[0]?.texture) {
            const texture = successRenderer.atlas.pages[0].texture;
            details.success = {
                texture_exists: true,
                getImage_method: typeof texture.getImage,
                getImage_result: texture.getImage ? texture.getImage() : null,
                texture_properties: Object.getOwnPropertyNames(texture)
            };
        }
        
        // 失敗パターン詳細
        if (failureRenderer?.atlas?.pages?.[0]?.texture) {
            const texture = failureRenderer.atlas.pages[0].texture;
            details.failure = {
                texture_exists: true,
                getImage_method: typeof texture.getImage,
                getImage_result: texture.getImage ? texture.getImage() : null,
                texture_properties: Object.getOwnPropertyNames(texture)
            };
        }
        
        console.log("🔬 getImage()詳細結果:", details);
        
        // 根本原因の特定
        let rootCause = "未特定";
        if (!details.failure.getImage_result && details.success.getImage_result) {
            rootCause = "失敗パターンのtexture.getImage()がnullを返している";
        } else if (details.failure.getImage_method !== details.success.getImage_method) {
            rootCause = "texture.getImage()メソッドの型が異なる";
        }
        
        document.getElementById("comparison-result").innerHTML = `
            <div class="success">✅ getImage()詳細テスト完了</div>
            <div class="info">🎯 根本原因: ${rootCause}</div>
            <div class="info">🔧 成功texture: ${details.success.texture_properties?.length || 0}プロパティ</div>
            <div class="info">🔧 失敗texture: ${details.failure.texture_properties?.length || 0}プロパティ</div>
        `;
    }
    </script>
</body>
</html>