<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🔍 座標レイヤー重複問題 - BBハンドル操作診断システム</title>
    <style>
        body {
            background: #f0f0f0;
            font-family: monospace;
            padding: 10px;
            margin: 0;
            touch-action: none;
        }
        .debug-container {
            background: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 1400px;
            margin: 0 auto;
        }
        .test-area {
            position: relative;
            width: 800px;
            height: 400px;
            background: #e8f4f8;
            border: 2px solid #007cba;
            margin: 20px auto;
            border-radius: 10px;
            touch-action: none;
        }
        .layout-anchor {
            position: absolute;
            background: rgba(255, 107, 107, 0.3);
            border: 2px solid #ff6b6b;
            border-radius: 8px;
            transform: translate(-50%, -50%);
            touch-action: none;
        }
        .interactive {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            font-weight: bold;
            cursor: pointer;
            transform: translate(var(--tx, 0), var(--ty, 0));
            touch-action: none;
        }
        .debug-panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        .debug-panel {
            background: #f8f9fa;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.4;
        }
        .debug-panel h3 {
            margin-top: 0;
            color: #007cba;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        .coordinate-layer {
            background: #fff;
            border: 1px solid #ccc;
            margin: 8px 0;
            padding: 8px;
            border-radius: 4px;
        }
        .layer-conflict {
            background: #ffe6e6;
            border-color: #ff9999;
        }
        .layer-normal {
            background: #e6f7ff;
            border-color: #87d2ff;
        }
        .controls {
            text-align: center;
            margin: 15px 0;
        }
        button {
            background: #007cba;
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 3px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        button:hover {
            background: #005a8a;
        }
        .realtime-monitor {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-size: 10px;
            z-index: 1000;
            display: none;
        }
        .warning {
            color: #ff6b6b;
            font-weight: bold;
        }
        .success {
            color: #28a745;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="debug-container">
        <h1>🔍 座標レイヤー重複問題診断システム</h1>
        <p><strong>目的:</strong> BBハンドル操作時に発生する座標レイヤー競合を診断・可視化</p>
        
        <div class="controls">
            <button onclick="startDiagnosis()">🔍 診断開始</button>
            <button onclick="enableRealtimeMonitor()">📊 リアルタイム監視ON</button>
            <button onclick="disableRealtimeMonitor()">📊 リアルタイム監視OFF</button>
            <button onclick="startBBEdit()">🎯 BB編集開始</button>
            <button onclick="analyzeCoordinateLayers()">📋 レイヤー分析</button>
            <button onclick="clearDebugPanels()">🧹 クリア</button>
        </div>
        
        <!-- テストエリア -->
        <div class="test-area" id="test-area">
            <div class="layout-anchor" id="test-target" style="left: 40%; top: 50%; width: 120px; height: 80px;">
                <div class="interactive" id="interactive-element">
                    <span>Test Element<br>🔍 座標診断</span>
                </div>
            </div>
        </div>
        
        <!-- デバッグパネル -->
        <div class="debug-panels">
            <div class="debug-panel">
                <h3>📍 座標レイヤー構造</h3>
                <div id="coordinate-layers"></div>
            </div>
            <div class="debug-panel">
                <h3>⚠️ 競合・重複検出</h3>
                <div id="conflict-detection"></div>
            </div>
        </div>
        
        <!-- リアルタイム監視パネル -->
        <div class="realtime-monitor" id="realtime-monitor">
            <div id="realtime-data"></div>
        </div>
    </div>

    <!-- マイクロモジュール読み込み -->
    <script src="assets/js/libs/spine-webgl.js"></script>
    <script src="micromodules/element-observer/ElementObserverCore.js"></script>
    <script src="micromodules/element-observer/ElementObserver.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxCore.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxBounds.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxUI.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxEvents.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBox.js"></script>

    <script>
        let elementObserver = null;
        let currentBoundingBox = null;
        let realtimeMonitorActive = false;
        let monitoringInterval = null;

        // 🔍 座標レイヤー診断システム
        class CoordinateLayerDiagnosticSystem {
            constructor() {
                this.targetElement = document.getElementById('test-target');
                this.interactiveElement = document.getElementById('interactive-element');
                this.testArea = document.getElementById('test-area');
                this.layers = [];
                this.conflicts = [];
            }

            // 全座標レイヤーの分析
            analyzeAllLayers() {
                console.log('🔍 [DIAGNOSTIC] 座標レイヤー分析開始');
                
                this.layers = [];
                this.conflicts = [];

                // Layer 1: CSS position (left, top)
                this.analyzeCSSPositionLayer();
                
                // Layer 2: CSS transform (translate, scale, rotate)
                this.analyzeCSSTransformLayer();
                
                // Layer 3: CSS variables (--tx, --ty)
                this.analyzeCSSVariableLayer();
                
                // Layer 4: ElementObserver座標制御
                this.analyzeElementObserverLayer();
                
                // Layer 5: PureBoundingBox座標制御
                this.analyzeBBLayer();
                
                // Layer 6: 親要素の座標変換
                this.analyzeParentCoordinateLayer();

                // 競合検出
                this.detectConflicts();

                // 結果を表示
                this.displayResults();
                
                return {
                    layers: this.layers,
                    conflicts: this.conflicts,
                    totalLayers: this.layers.length,
                    conflictCount: this.conflicts.length
                };
            }

            // CSS position レイヤー分析
            analyzeCSSPositionLayer() {
                const element = this.targetElement;
                const computedStyle = getComputedStyle(element);
                
                const layer = {
                    name: 'CSS Position',
                    type: 'position',
                    active: element.style.position === 'absolute',
                    values: {
                        left: element.style.left || computedStyle.left,
                        top: element.style.top || computedStyle.top,
                        position: element.style.position || computedStyle.position
                    },
                    computed: {
                        left: computedStyle.left,
                        top: computedStyle.top,
                        position: computedStyle.position
                    },
                    element: element,
                    impact: 'primary-positioning',
                    priority: 1
                };
                
                this.layers.push(layer);
            }

            // CSS transform レイヤー分析
            analyzeCSSTransformLayer() {
                const element = this.targetElement;
                const computedStyle = getComputedStyle(element);
                
                const layer = {
                    name: 'CSS Transform (Anchor)',
                    type: 'transform',
                    active: !!element.style.transform || !!computedStyle.transform,
                    values: {
                        transform: element.style.transform,
                        webkitTransform: element.style.webkitTransform
                    },
                    computed: {
                        transform: computedStyle.transform,
                        transformOrigin: computedStyle.transformOrigin
                    },
                    element: element,
                    impact: 'anchor-centering',
                    priority: 2
                };
                
                this.layers.push(layer);

                // Interactive要素のtransform
                if (this.interactiveElement) {
                    const interactiveComputedStyle = getComputedStyle(this.interactiveElement);
                    const interactiveLayer = {
                        name: 'CSS Transform (Interactive)',
                        type: 'transform',
                        active: !!this.interactiveElement.style.transform || !!interactiveComputedStyle.transform,
                        values: {
                            transform: this.interactiveElement.style.transform
                        },
                        computed: {
                            transform: interactiveComputedStyle.transform
                        },
                        element: this.interactiveElement,
                        impact: 'interactive-offset',
                        priority: 3
                    };
                    
                    this.layers.push(interactiveLayer);
                }
            }

            // CSS variables レイヤー分析
            analyzeCSSVariableLayer() {
                if (!this.interactiveElement) return;

                const computedStyle = getComputedStyle(this.interactiveElement);
                const tx = computedStyle.getPropertyValue('--tx') || '0px';
                const ty = computedStyle.getPropertyValue('--ty') || '0px';
                
                const layer = {
                    name: 'CSS Variables',
                    type: 'css-variables',
                    active: tx !== '0px' || ty !== '0px',
                    values: {
                        '--tx': tx,
                        '--ty': ty
                    },
                    parsed: {
                        tx: parseFloat(tx) || 0,
                        ty: parseFloat(ty) || 0
                    },
                    element: this.interactiveElement,
                    impact: 'variable-offset',
                    priority: 4
                };
                
                this.layers.push(layer);
            }

            // ElementObserver レイヤー分析
            analyzeElementObserverLayer() {
                const layer = {
                    name: 'ElementObserver',
                    type: 'element-observer',
                    active: !!elementObserver,
                    values: {},
                    status: 'monitoring',
                    element: this.targetElement,
                    impact: 'stability-control',
                    priority: 5
                };

                if (elementObserver) {
                    try {
                        const debugInfo = elementObserver.getDebugInfo();
                        const safetyCheck = elementObserver.isSafeForCoordinateSwap(this.targetElement);
                        
                        layer.values = {
                            parentSizeCacheCount: debugInfo.pureBoundingBoxIntegration.parentSizeCacheCount,
                            safetyCheck: safetyCheck,
                            isMonitoring: true
                        };
                    } catch (error) {
                        layer.values = { error: error.message };
                    }
                }
                
                this.layers.push(layer);
            }

            // PureBoundingBox レイヤー分析
            analyzeBBLayer() {
                const layer = {
                    name: 'PureBoundingBox',
                    type: 'bounding-box',
                    active: !!currentBoundingBox,
                    values: {},
                    element: this.targetElement,
                    impact: 'editing-control',
                    priority: 6
                };

                if (currentBoundingBox) {
                    try {
                        const state = currentBoundingBox.getState();
                        layer.values = {
                            editingMode: state.swapState.currentMode,
                            isDragging: state.dragState.isDragging,
                            bounds: state.bounds,
                            transform: state.transform,
                            visible: state.uiState.visible
                        };
                    } catch (error) {
                        layer.values = { error: error.message };
                    }
                }
                
                this.layers.push(layer);
            }

            // 親要素座標変換レイヤー分析
            analyzeParentCoordinateLayer() {
                const parentElement = this.testArea;
                const computedStyle = getComputedStyle(parentElement);
                
                const layer = {
                    name: 'Parent Container',
                    type: 'parent-transform',
                    active: true,
                    values: {
                        position: parentElement.style.position || computedStyle.position,
                        transform: parentElement.style.transform || computedStyle.transform
                    },
                    computed: {
                        transform: computedStyle.transform,
                        transformOrigin: computedStyle.transformOrigin
                    },
                    element: parentElement,
                    impact: 'container-coordinate-system',
                    priority: 0
                };
                
                this.layers.push(layer);
            }

            // 競合検出
            detectConflicts() {
                this.conflicts = [];

                // 1. 複数transformの重複
                const transformLayers = this.layers.filter(layer => layer.type === 'transform');
                if (transformLayers.length > 1) {
                    const activeTransforms = transformLayers.filter(layer => 
                        layer.active && 
                        layer.computed.transform !== 'none' && 
                        layer.computed.transform !== 'matrix(1, 0, 0, 1, 0, 0)'
                    );
                    
                    if (activeTransforms.length > 1) {
                        this.conflicts.push({
                            type: 'multiple-transforms',
                            severity: 'high',
                            description: '複数のtransformが同時適用されています',
                            affectedLayers: activeTransforms.map(l => l.name),
                            solution: 'transform統合または優先順位の明確化が必要'
                        });
                    }
                }

                // 2. CSS variables と transform の競合
                const cssVarLayer = this.layers.find(layer => layer.type === 'css-variables');
                const interactiveTransformLayer = this.layers.find(layer => 
                    layer.type === 'transform' && layer.name.includes('Interactive')
                );

                if (cssVarLayer && interactiveTransformLayer && cssVarLayer.active && interactiveTransformLayer.active) {
                    if ((cssVarLayer.parsed.tx !== 0 || cssVarLayer.parsed.ty !== 0) && 
                        interactiveTransformLayer.computed.transform.includes('translate')) {
                        
                        this.conflicts.push({
                            type: 'css-variable-transform-conflict',
                            severity: 'medium',
                            description: 'CSS変数とtransformが同一要素で重複しています',
                            affectedLayers: [cssVarLayer.name, interactiveTransformLayer.name],
                            solution: 'CSS変数をリセットまたはtransform統一が必要'
                        });
                    }
                }

                // 3. PureBoundingBox編集中の座標系競合
                const bbLayer = this.layers.find(layer => layer.type === 'bounding-box');
                if (bbLayer && bbLayer.active && bbLayer.values.isDragging) {
                    const activeLayers = this.layers.filter(layer => 
                        layer.active && 
                        layer.type !== 'bounding-box' && 
                        layer.impact.includes('offset')
                    );

                    if (activeLayers.length > 0) {
                        this.conflicts.push({
                            type: 'bb-editing-interference',
                            severity: 'critical',
                            description: 'BB編集中に他の座標レイヤーが干渉しています',
                            affectedLayers: [bbLayer.name, ...activeLayers.map(l => l.name)],
                            solution: 'BB編集中は他の座標制御を一時停止する必要があります'
                        });
                    }
                }

                // 4. ElementObserverとBB統合の安全性チェック
                const eoLayer = this.layers.find(layer => layer.type === 'element-observer');
                if (eoLayer && bbLayer && eoLayer.active && bbLayer.active) {
                    if (eoLayer.values.safetyCheck && !eoLayer.values.safetyCheck.safe) {
                        this.conflicts.push({
                            type: 'elementobserver-safety',
                            severity: 'high',
                            description: `ElementObserver安全性チェック失敗: ${eoLayer.values.safetyCheck.reason}`,
                            affectedLayers: [eoLayer.name, bbLayer.name],
                            solution: 'ElementObserver統合の安全性チェックに対応が必要'
                        });
                    }
                }
            }

            // 結果表示
            displayResults() {
                this.displayCoordinateLayers();
                this.displayConflicts();
            }

            displayCoordinateLayers() {
                const container = document.getElementById('coordinate-layers');
                container.innerHTML = '';

                this.layers.sort((a, b) => a.priority - b.priority).forEach(layer => {
                    const div = document.createElement('div');
                    div.className = `coordinate-layer ${layer.active ? 'layer-normal' : ''}`;
                    
                    div.innerHTML = `
                        <strong>${layer.name}</strong> (Priority: ${layer.priority})
                        <br>Type: ${layer.type} | Impact: ${layer.impact}
                        <br>Active: ${layer.active ? '✅' : '❌'}
                        <br>Element: ${layer.element.tagName}${layer.element.id ? '#' + layer.element.id : ''}
                        <br>Values: <code>${JSON.stringify(layer.values, null, 1)}</code>
                        ${layer.computed ? `<br>Computed: <code>${JSON.stringify(layer.computed, null, 1)}</code>` : ''}
                    `;
                    
                    container.appendChild(div);
                });
            }

            displayConflicts() {
                const container = document.getElementById('conflict-detection');
                container.innerHTML = '';

                if (this.conflicts.length === 0) {
                    container.innerHTML = '<div class="success">✅ 座標レイヤー競合は検出されませんでした</div>';
                    return;
                }

                this.conflicts.forEach(conflict => {
                    const div = document.createElement('div');
                    div.className = 'coordinate-layer layer-conflict';
                    
                    const severityColor = {
                        'critical': '#ff0000',
                        'high': '#ff6600',
                        'medium': '#ffaa00',
                        'low': '#ffdd00'
                    }[conflict.severity] || '#999';
                    
                    div.innerHTML = `
                        <strong style="color: ${severityColor}">⚠️ ${conflict.type.toUpperCase()}</strong>
                        <br>Severity: <span style="color: ${severityColor}">${conflict.severity}</span>
                        <br>Description: ${conflict.description}
                        <br>Affected: ${conflict.affectedLayers.join(', ')}
                        <br><strong>Solution:</strong> ${conflict.solution}
                    `;
                    
                    container.appendChild(div);
                });
            }

            // リアルタイム監視データ
            getRealtimeData() {
                return {
                    timestamp: new Date().toLocaleTimeString(),
                    activeLayers: this.layers.filter(l => l.active).length,
                    conflicts: this.conflicts.length,
                    bbDragging: currentBoundingBox?.getState().dragState.isDragging || false,
                    elementObserverActive: !!elementObserver,
                    cssVariables: this.interactiveElement ? {
                        tx: getComputedStyle(this.interactiveElement).getPropertyValue('--tx') || '0px',
                        ty: getComputedStyle(this.interactiveElement).getPropertyValue('--ty') || '0px'
                    } : null
                };
            }
        }

        // グローバル診断システムインスタンス
        const diagnosticSystem = new CoordinateLayerDiagnosticSystem();

        // 🔍 診断開始
        function startDiagnosis() {
            console.log('🔍 座標レイヤー診断開始');
            
            // ElementObserver初期化（未初期化の場合）
            if (!elementObserver) {
                elementObserver = new ElementObserver();
                elementObserver.observeParentSize(diagnosticSystem.targetElement, (parentRect, isValid) => {
                    console.log('📡 ElementObserver親要素変化:', { isValid, size: `${parentRect.width}x${parentRect.height}` });
                });
            }

            // 診断実行
            const results = diagnosticSystem.analyzeAllLayers();
            
            console.log('✅ 座標レイヤー診断完了:', results);
            return results;
        }

        // 📊 リアルタイム監視
        function enableRealtimeMonitor() {
            const monitor = document.getElementById('realtime-monitor');
            const dataContainer = document.getElementById('realtime-data');
            
            monitor.style.display = 'block';
            realtimeMonitorActive = true;

            monitoringInterval = setInterval(() => {
                const data = diagnosticSystem.getRealtimeData();
                
                dataContainer.innerHTML = `
                    <div>⏰ ${data.timestamp}</div>
                    <div>📊 Active Layers: ${data.activeLayers}</div>
                    <div class="${data.conflicts > 0 ? 'warning' : 'success'}">⚠️ Conflicts: ${data.conflicts}</div>
                    <div>🎯 BB Dragging: ${data.bbDragging ? '✅' : '❌'}</div>
                    <div>🌊 ElementObserver: ${data.elementObserverActive ? '✅' : '❌'}</div>
                    ${data.cssVariables ? `<div>📐 CSS Vars: tx=${data.cssVariables.tx} ty=${data.cssVariables.ty}</div>` : ''}
                `;
            }, 100); // 100ms間隔で更新

            console.log('📊 リアルタイム監視開始');
        }

        function disableRealtimeMonitor() {
            const monitor = document.getElementById('realtime-monitor');
            monitor.style.display = 'none';
            realtimeMonitorActive = false;

            if (monitoringInterval) {
                clearInterval(monitoringInterval);
                monitoringInterval = null;
            }

            console.log('📊 リアルタイム監視停止');
        }

        // 🎯 BB編集開始
        async function startBBEdit() {
            console.log('🎯 BB編集開始');

            try {
                // ElementObserver初期化（未初期化の場合）
                if (!elementObserver) {
                    startDiagnosis();
                }

                // 既存BBクリーンアップ
                if (currentBoundingBox) {
                    currentBoundingBox.cleanup();
                }

                // PureBoundingBox作成
                currentBoundingBox = new PureBoundingBox({
                    targetElement: diagnosticSystem.targetElement,
                    nodeId: 'coordinate-debug-bb'
                });

                // BB実行
                const result = await currentBoundingBox.execute({ visible: true });
                
                if (result.success) {
                    console.log('✅ BB編集モード開始成功');
                    
                    // 診断更新
                    setTimeout(() => {
                        diagnosticSystem.analyzeAllLayers();
                    }, 100);
                } else {
                    throw new Error(result.error);
                }

            } catch (error) {
                console.error('❌ BB編集開始エラー:', error);
            }
        }

        // 📋 レイヤー分析
        function analyzeCoordinateLayers() {
            return startDiagnosis();
        }

        // 🧹 クリア
        function clearDebugPanels() {
            document.getElementById('coordinate-layers').innerHTML = '';
            document.getElementById('conflict-detection').innerHTML = '';
            console.clear();
        }

        // ページロード時の初期化
        window.addEventListener('load', () => {
            console.log('🔍 座標レイヤー重複診断システム準備完了');
            console.log('📋 使用方法:');
            console.log('  1. 「診断開始」で座標レイヤー分析');
            console.log('  2. 「BB編集開始」でBB操作開始');
            console.log('  3. 「リアルタイム監視ON」で動的追跡');
            console.log('  4. BBハンドルをドラッグして競合を観察');
        });
    </script>
</body>
</html>
