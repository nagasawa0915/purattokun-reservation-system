<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ” åº§æ¨™ãƒ¬ã‚¤ãƒ¤ãƒ¼é‡è¤‡å•é¡Œ - BBãƒãƒ³ãƒ‰ãƒ«æ“ä½œè¨ºæ–­ã‚·ã‚¹ãƒ†ãƒ </title>
    <style>
        body {
            background: #f0f0f0;
            font-family: monospace;
            padding: 10px;
            margin: 0;
            touch-action: none;
        }
        .debug-container {
            background: white;
            padding: 15px;
            border-radius: 8px;
            max-width: 1400px;
            margin: 0 auto;
        }
        .test-area {
            position: relative;
            width: 800px;
            height: 400px;
            background: #e8f4f8;
            border: 2px solid #007cba;
            margin: 20px auto;
            border-radius: 10px;
            touch-action: none;
        }
        .layout-anchor {
            position: absolute;
            background: rgba(255, 107, 107, 0.3);
            border: 2px solid #ff6b6b;
            border-radius: 8px;
            transform: translate(-50%, -50%);
            touch-action: none;
        }
        .interactive {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            font-weight: bold;
            cursor: pointer;
            transform: translate(var(--tx, 0), var(--ty, 0));
            touch-action: none;
        }
        .debug-panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        .debug-panel {
            background: #f8f9fa;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.4;
        }
        .debug-panel h3 {
            margin-top: 0;
            color: #007cba;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        .coordinate-layer {
            background: #fff;
            border: 1px solid #ccc;
            margin: 8px 0;
            padding: 8px;
            border-radius: 4px;
        }
        .layer-conflict {
            background: #ffe6e6;
            border-color: #ff9999;
        }
        .layer-normal {
            background: #e6f7ff;
            border-color: #87d2ff;
        }
        .controls {
            text-align: center;
            margin: 15px 0;
        }
        button {
            background: #007cba;
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 3px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        button:hover {
            background: #005a8a;
        }
        .realtime-monitor {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-size: 10px;
            z-index: 1000;
            display: none;
        }
        .warning {
            color: #ff6b6b;
            font-weight: bold;
        }
        .success {
            color: #28a745;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="debug-container">
        <h1>ğŸ” åº§æ¨™ãƒ¬ã‚¤ãƒ¤ãƒ¼é‡è¤‡å•é¡Œè¨ºæ–­ã‚·ã‚¹ãƒ†ãƒ </h1>
        <p><strong>ç›®çš„:</strong> BBãƒãƒ³ãƒ‰ãƒ«æ“ä½œæ™‚ã«ç™ºç”Ÿã™ã‚‹åº§æ¨™ãƒ¬ã‚¤ãƒ¤ãƒ¼ç«¶åˆã‚’è¨ºæ–­ãƒ»å¯è¦–åŒ–</p>
        
        <div class="controls">
            <button onclick="startDiagnosis()">ğŸ” è¨ºæ–­é–‹å§‹</button>
            <button onclick="enableRealtimeMonitor()">ğŸ“Š ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ON</button>
            <button onclick="disableRealtimeMonitor()">ğŸ“Š ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–OFF</button>
            <button onclick="startBBEdit()">ğŸ¯ BBç·¨é›†é–‹å§‹</button>
            <button onclick="analyzeCoordinateLayers()">ğŸ“‹ ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ†æ</button>
            <button onclick="clearDebugPanels()">ğŸ§¹ ã‚¯ãƒªã‚¢</button>
        </div>
        
        <!-- ãƒ†ã‚¹ãƒˆã‚¨ãƒªã‚¢ -->
        <div class="test-area" id="test-area">
            <div class="layout-anchor" id="test-target" style="left: 40%; top: 50%; width: 120px; height: 80px;">
                <div class="interactive" id="interactive-element">
                    <span>Test Element<br>ğŸ” åº§æ¨™è¨ºæ–­</span>
                </div>
            </div>
        </div>
        
        <!-- ãƒ‡ãƒãƒƒã‚°ãƒ‘ãƒãƒ« -->
        <div class="debug-panels">
            <div class="debug-panel">
                <h3>ğŸ“ åº§æ¨™ãƒ¬ã‚¤ãƒ¤ãƒ¼æ§‹é€ </h3>
                <div id="coordinate-layers"></div>
            </div>
            <div class="debug-panel">
                <h3>âš ï¸ ç«¶åˆãƒ»é‡è¤‡æ¤œå‡º</h3>
                <div id="conflict-detection"></div>
            </div>
        </div>
        
        <!-- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ãƒ‘ãƒãƒ« -->
        <div class="realtime-monitor" id="realtime-monitor">
            <div id="realtime-data"></div>
        </div>
    </div>

    <!-- ãƒã‚¤ã‚¯ãƒ­ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«èª­ã¿è¾¼ã¿ -->
    <script src="assets/js/libs/spine-webgl.js"></script>
    <script src="micromodules/element-observer/ElementObserverCore.js"></script>
    <script src="micromodules/element-observer/ElementObserver.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxCore.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxBounds.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxUI.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxEvents.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBox.js"></script>

    <script>
        let elementObserver = null;
        let currentBoundingBox = null;
        let realtimeMonitorActive = false;
        let monitoringInterval = null;

        // ğŸ” åº§æ¨™ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨ºæ–­ã‚·ã‚¹ãƒ†ãƒ 
        class CoordinateLayerDiagnosticSystem {
            constructor() {
                this.targetElement = document.getElementById('test-target');
                this.interactiveElement = document.getElementById('interactive-element');
                this.testArea = document.getElementById('test-area');
                this.layers = [];
                this.conflicts = [];
            }

            // å…¨åº§æ¨™ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åˆ†æ
            analyzeAllLayers() {
                console.log('ğŸ” [DIAGNOSTIC] åº§æ¨™ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ†æé–‹å§‹');
                
                this.layers = [];
                this.conflicts = [];

                // Layer 1: CSS position (left, top)
                this.analyzeCSSPositionLayer();
                
                // Layer 2: CSS transform (translate, scale, rotate)
                this.analyzeCSSTransformLayer();
                
                // Layer 3: CSS variables (--tx, --ty)
                this.analyzeCSSVariableLayer();
                
                // Layer 4: ElementObserveråº§æ¨™åˆ¶å¾¡
                this.analyzeElementObserverLayer();
                
                // Layer 5: PureBoundingBoxåº§æ¨™åˆ¶å¾¡
                this.analyzeBBLayer();
                
                // Layer 6: è¦ªè¦ç´ ã®åº§æ¨™å¤‰æ›
                this.analyzeParentCoordinateLayer();

                // ç«¶åˆæ¤œå‡º
                this.detectConflicts();

                // çµæœã‚’è¡¨ç¤º
                this.displayResults();
                
                return {
                    layers: this.layers,
                    conflicts: this.conflicts,
                    totalLayers: this.layers.length,
                    conflictCount: this.conflicts.length
                };
            }

            // CSS position ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ†æ
            analyzeCSSPositionLayer() {
                const element = this.targetElement;
                const computedStyle = getComputedStyle(element);
                
                const layer = {
                    name: 'CSS Position',
                    type: 'position',
                    active: element.style.position === 'absolute',
                    values: {
                        left: element.style.left || computedStyle.left,
                        top: element.style.top || computedStyle.top,
                        position: element.style.position || computedStyle.position
                    },
                    computed: {
                        left: computedStyle.left,
                        top: computedStyle.top,
                        position: computedStyle.position
                    },
                    element: element,
                    impact: 'primary-positioning',
                    priority: 1
                };
                
                this.layers.push(layer);
            }

            // CSS transform ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ†æ
            analyzeCSSTransformLayer() {
                const element = this.targetElement;
                const computedStyle = getComputedStyle(element);
                
                const layer = {
                    name: 'CSS Transform (Anchor)',
                    type: 'transform',
                    active: !!element.style.transform || !!computedStyle.transform,
                    values: {
                        transform: element.style.transform,
                        webkitTransform: element.style.webkitTransform
                    },
                    computed: {
                        transform: computedStyle.transform,
                        transformOrigin: computedStyle.transformOrigin
                    },
                    element: element,
                    impact: 'anchor-centering',
                    priority: 2
                };
                
                this.layers.push(layer);

                // Interactiveè¦ç´ ã®transform
                if (this.interactiveElement) {
                    const interactiveComputedStyle = getComputedStyle(this.interactiveElement);
                    const interactiveLayer = {
                        name: 'CSS Transform (Interactive)',
                        type: 'transform',
                        active: !!this.interactiveElement.style.transform || !!interactiveComputedStyle.transform,
                        values: {
                            transform: this.interactiveElement.style.transform
                        },
                        computed: {
                            transform: interactiveComputedStyle.transform
                        },
                        element: this.interactiveElement,
                        impact: 'interactive-offset',
                        priority: 3
                    };
                    
                    this.layers.push(interactiveLayer);
                }
            }

            // CSS variables ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ†æ
            analyzeCSSVariableLayer() {
                if (!this.interactiveElement) return;

                const computedStyle = getComputedStyle(this.interactiveElement);
                const tx = computedStyle.getPropertyValue('--tx') || '0px';
                const ty = computedStyle.getPropertyValue('--ty') || '0px';
                
                const layer = {
                    name: 'CSS Variables',
                    type: 'css-variables',
                    active: tx !== '0px' || ty !== '0px',
                    values: {
                        '--tx': tx,
                        '--ty': ty
                    },
                    parsed: {
                        tx: parseFloat(tx) || 0,
                        ty: parseFloat(ty) || 0
                    },
                    element: this.interactiveElement,
                    impact: 'variable-offset',
                    priority: 4
                };
                
                this.layers.push(layer);
            }

            // ElementObserver ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ†æ
            analyzeElementObserverLayer() {
                const layer = {
                    name: 'ElementObserver',
                    type: 'element-observer',
                    active: !!elementObserver,
                    values: {},
                    status: 'monitoring',
                    element: this.targetElement,
                    impact: 'stability-control',
                    priority: 5
                };

                if (elementObserver) {
                    try {
                        const debugInfo = elementObserver.getDebugInfo();
                        const safetyCheck = elementObserver.isSafeForCoordinateSwap(this.targetElement);
                        
                        layer.values = {
                            parentSizeCacheCount: debugInfo.pureBoundingBoxIntegration.parentSizeCacheCount,
                            safetyCheck: safetyCheck,
                            isMonitoring: true
                        };
                    } catch (error) {
                        layer.values = { error: error.message };
                    }
                }
                
                this.layers.push(layer);
            }

            // PureBoundingBox ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ†æ
            analyzeBBLayer() {
                const layer = {
                    name: 'PureBoundingBox',
                    type: 'bounding-box',
                    active: !!currentBoundingBox,
                    values: {},
                    element: this.targetElement,
                    impact: 'editing-control',
                    priority: 6
                };

                if (currentBoundingBox) {
                    try {
                        const state = currentBoundingBox.getState();
                        layer.values = {
                            editingMode: state.swapState.currentMode,
                            isDragging: state.dragState.isDragging,
                            bounds: state.bounds,
                            transform: state.transform,
                            visible: state.uiState.visible
                        };
                    } catch (error) {
                        layer.values = { error: error.message };
                    }
                }
                
                this.layers.push(layer);
            }

            // è¦ªè¦ç´ åº§æ¨™å¤‰æ›ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ†æ
            analyzeParentCoordinateLayer() {
                const parentElement = this.testArea;
                const computedStyle = getComputedStyle(parentElement);
                
                const layer = {
                    name: 'Parent Container',
                    type: 'parent-transform',
                    active: true,
                    values: {
                        position: parentElement.style.position || computedStyle.position,
                        transform: parentElement.style.transform || computedStyle.transform
                    },
                    computed: {
                        transform: computedStyle.transform,
                        transformOrigin: computedStyle.transformOrigin
                    },
                    element: parentElement,
                    impact: 'container-coordinate-system',
                    priority: 0
                };
                
                this.layers.push(layer);
            }

            // ç«¶åˆæ¤œå‡º
            detectConflicts() {
                this.conflicts = [];

                // 1. è¤‡æ•°transformã®é‡è¤‡
                const transformLayers = this.layers.filter(layer => layer.type === 'transform');
                if (transformLayers.length > 1) {
                    const activeTransforms = transformLayers.filter(layer => 
                        layer.active && 
                        layer.computed.transform !== 'none' && 
                        layer.computed.transform !== 'matrix(1, 0, 0, 1, 0, 0)'
                    );
                    
                    if (activeTransforms.length > 1) {
                        this.conflicts.push({
                            type: 'multiple-transforms',
                            severity: 'high',
                            description: 'è¤‡æ•°ã®transformãŒåŒæ™‚é©ç”¨ã•ã‚Œã¦ã„ã¾ã™',
                            affectedLayers: activeTransforms.map(l => l.name),
                            solution: 'transformçµ±åˆã¾ãŸã¯å„ªå…ˆé †ä½ã®æ˜ç¢ºåŒ–ãŒå¿…è¦'
                        });
                    }
                }

                // 2. CSS variables ã¨ transform ã®ç«¶åˆ
                const cssVarLayer = this.layers.find(layer => layer.type === 'css-variables');
                const interactiveTransformLayer = this.layers.find(layer => 
                    layer.type === 'transform' && layer.name.includes('Interactive')
                );

                if (cssVarLayer && interactiveTransformLayer && cssVarLayer.active && interactiveTransformLayer.active) {
                    if ((cssVarLayer.parsed.tx !== 0 || cssVarLayer.parsed.ty !== 0) && 
                        interactiveTransformLayer.computed.transform.includes('translate')) {
                        
                        this.conflicts.push({
                            type: 'css-variable-transform-conflict',
                            severity: 'medium',
                            description: 'CSSå¤‰æ•°ã¨transformãŒåŒä¸€è¦ç´ ã§é‡è¤‡ã—ã¦ã„ã¾ã™',
                            affectedLayers: [cssVarLayer.name, interactiveTransformLayer.name],
                            solution: 'CSSå¤‰æ•°ã‚’ãƒªã‚»ãƒƒãƒˆã¾ãŸã¯transformçµ±ä¸€ãŒå¿…è¦'
                        });
                    }
                }

                // 3. PureBoundingBoxç·¨é›†ä¸­ã®åº§æ¨™ç³»ç«¶åˆ
                const bbLayer = this.layers.find(layer => layer.type === 'bounding-box');
                if (bbLayer && bbLayer.active && bbLayer.values.isDragging) {
                    const activeLayers = this.layers.filter(layer => 
                        layer.active && 
                        layer.type !== 'bounding-box' && 
                        layer.impact.includes('offset')
                    );

                    if (activeLayers.length > 0) {
                        this.conflicts.push({
                            type: 'bb-editing-interference',
                            severity: 'critical',
                            description: 'BBç·¨é›†ä¸­ã«ä»–ã®åº§æ¨™ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå¹²æ¸‰ã—ã¦ã„ã¾ã™',
                            affectedLayers: [bbLayer.name, ...activeLayers.map(l => l.name)],
                            solution: 'BBç·¨é›†ä¸­ã¯ä»–ã®åº§æ¨™åˆ¶å¾¡ã‚’ä¸€æ™‚åœæ­¢ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™'
                        });
                    }
                }

                // 4. ElementObserverã¨BBçµ±åˆã®å®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯
                const eoLayer = this.layers.find(layer => layer.type === 'element-observer');
                if (eoLayer && bbLayer && eoLayer.active && bbLayer.active) {
                    if (eoLayer.values.safetyCheck && !eoLayer.values.safetyCheck.safe) {
                        this.conflicts.push({
                            type: 'elementobserver-safety',
                            severity: 'high',
                            description: `ElementObserverå®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯å¤±æ•—: ${eoLayer.values.safetyCheck.reason}`,
                            affectedLayers: [eoLayer.name, bbLayer.name],
                            solution: 'ElementObserverçµ±åˆã®å®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯ã«å¯¾å¿œãŒå¿…è¦'
                        });
                    }
                }
            }

            // çµæœè¡¨ç¤º
            displayResults() {
                this.displayCoordinateLayers();
                this.displayConflicts();
            }

            displayCoordinateLayers() {
                const container = document.getElementById('coordinate-layers');
                container.innerHTML = '';

                this.layers.sort((a, b) => a.priority - b.priority).forEach(layer => {
                    const div = document.createElement('div');
                    div.className = `coordinate-layer ${layer.active ? 'layer-normal' : ''}`;
                    
                    div.innerHTML = `
                        <strong>${layer.name}</strong> (Priority: ${layer.priority})
                        <br>Type: ${layer.type} | Impact: ${layer.impact}
                        <br>Active: ${layer.active ? 'âœ…' : 'âŒ'}
                        <br>Element: ${layer.element.tagName}${layer.element.id ? '#' + layer.element.id : ''}
                        <br>Values: <code>${JSON.stringify(layer.values, null, 1)}</code>
                        ${layer.computed ? `<br>Computed: <code>${JSON.stringify(layer.computed, null, 1)}</code>` : ''}
                    `;
                    
                    container.appendChild(div);
                });
            }

            displayConflicts() {
                const container = document.getElementById('conflict-detection');
                container.innerHTML = '';

                if (this.conflicts.length === 0) {
                    container.innerHTML = '<div class="success">âœ… åº§æ¨™ãƒ¬ã‚¤ãƒ¤ãƒ¼ç«¶åˆã¯æ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ</div>';
                    return;
                }

                this.conflicts.forEach(conflict => {
                    const div = document.createElement('div');
                    div.className = 'coordinate-layer layer-conflict';
                    
                    const severityColor = {
                        'critical': '#ff0000',
                        'high': '#ff6600',
                        'medium': '#ffaa00',
                        'low': '#ffdd00'
                    }[conflict.severity] || '#999';
                    
                    div.innerHTML = `
                        <strong style="color: ${severityColor}">âš ï¸ ${conflict.type.toUpperCase()}</strong>
                        <br>Severity: <span style="color: ${severityColor}">${conflict.severity}</span>
                        <br>Description: ${conflict.description}
                        <br>Affected: ${conflict.affectedLayers.join(', ')}
                        <br><strong>Solution:</strong> ${conflict.solution}
                    `;
                    
                    container.appendChild(div);
                });
            }

            // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ãƒ‡ãƒ¼ã‚¿
            getRealtimeData() {
                return {
                    timestamp: new Date().toLocaleTimeString(),
                    activeLayers: this.layers.filter(l => l.active).length,
                    conflicts: this.conflicts.length,
                    bbDragging: currentBoundingBox?.getState().dragState.isDragging || false,
                    elementObserverActive: !!elementObserver,
                    cssVariables: this.interactiveElement ? {
                        tx: getComputedStyle(this.interactiveElement).getPropertyValue('--tx') || '0px',
                        ty: getComputedStyle(this.interactiveElement).getPropertyValue('--ty') || '0px'
                    } : null
                };
            }
        }

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨ºæ–­ã‚·ã‚¹ãƒ†ãƒ ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        const diagnosticSystem = new CoordinateLayerDiagnosticSystem();

        // ğŸ” è¨ºæ–­é–‹å§‹
        function startDiagnosis() {
            console.log('ğŸ” åº§æ¨™ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨ºæ–­é–‹å§‹');
            
            // ElementObserveråˆæœŸåŒ–ï¼ˆæœªåˆæœŸåŒ–ã®å ´åˆï¼‰
            if (!elementObserver) {
                elementObserver = new ElementObserver();
                elementObserver.observeParentSize(diagnosticSystem.targetElement, (parentRect, isValid) => {
                    console.log('ğŸ“¡ ElementObserverè¦ªè¦ç´ å¤‰åŒ–:', { isValid, size: `${parentRect.width}x${parentRect.height}` });
                });
            }

            // è¨ºæ–­å®Ÿè¡Œ
            const results = diagnosticSystem.analyzeAllLayers();
            
            console.log('âœ… åº§æ¨™ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨ºæ–­å®Œäº†:', results);
            return results;
        }

        // ğŸ“Š ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–
        function enableRealtimeMonitor() {
            const monitor = document.getElementById('realtime-monitor');
            const dataContainer = document.getElementById('realtime-data');
            
            monitor.style.display = 'block';
            realtimeMonitorActive = true;

            monitoringInterval = setInterval(() => {
                const data = diagnosticSystem.getRealtimeData();
                
                dataContainer.innerHTML = `
                    <div>â° ${data.timestamp}</div>
                    <div>ğŸ“Š Active Layers: ${data.activeLayers}</div>
                    <div class="${data.conflicts > 0 ? 'warning' : 'success'}">âš ï¸ Conflicts: ${data.conflicts}</div>
                    <div>ğŸ¯ BB Dragging: ${data.bbDragging ? 'âœ…' : 'âŒ'}</div>
                    <div>ğŸŒŠ ElementObserver: ${data.elementObserverActive ? 'âœ…' : 'âŒ'}</div>
                    ${data.cssVariables ? `<div>ğŸ“ CSS Vars: tx=${data.cssVariables.tx} ty=${data.cssVariables.ty}</div>` : ''}
                `;
            }, 100); // 100msé–“éš”ã§æ›´æ–°

            console.log('ğŸ“Š ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–é–‹å§‹');
        }

        function disableRealtimeMonitor() {
            const monitor = document.getElementById('realtime-monitor');
            monitor.style.display = 'none';
            realtimeMonitorActive = false;

            if (monitoringInterval) {
                clearInterval(monitoringInterval);
                monitoringInterval = null;
            }

            console.log('ğŸ“Š ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–åœæ­¢');
        }

        // ğŸ¯ BBç·¨é›†é–‹å§‹
        async function startBBEdit() {
            console.log('ğŸ¯ BBç·¨é›†é–‹å§‹');

            try {
                // ElementObserveråˆæœŸåŒ–ï¼ˆæœªåˆæœŸåŒ–ã®å ´åˆï¼‰
                if (!elementObserver) {
                    startDiagnosis();
                }

                // æ—¢å­˜BBã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                if (currentBoundingBox) {
                    currentBoundingBox.cleanup();
                }

                // PureBoundingBoxä½œæˆ
                currentBoundingBox = new PureBoundingBox({
                    targetElement: diagnosticSystem.targetElement,
                    nodeId: 'coordinate-debug-bb'
                });

                // BBå®Ÿè¡Œ
                const result = await currentBoundingBox.execute({ visible: true });
                
                if (result.success) {
                    console.log('âœ… BBç·¨é›†ãƒ¢ãƒ¼ãƒ‰é–‹å§‹æˆåŠŸ');
                    
                    // è¨ºæ–­æ›´æ–°
                    setTimeout(() => {
                        diagnosticSystem.analyzeAllLayers();
                    }, 100);
                } else {
                    throw new Error(result.error);
                }

            } catch (error) {
                console.error('âŒ BBç·¨é›†é–‹å§‹ã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        // ğŸ“‹ ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ†æ
        function analyzeCoordinateLayers() {
            return startDiagnosis();
        }

        // ğŸ§¹ ã‚¯ãƒªã‚¢
        function clearDebugPanels() {
            document.getElementById('coordinate-layers').innerHTML = '';
            document.getElementById('conflict-detection').innerHTML = '';
            console.clear();
        }

        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã®åˆæœŸåŒ–
        window.addEventListener('load', () => {
            console.log('ğŸ” åº§æ¨™ãƒ¬ã‚¤ãƒ¤ãƒ¼é‡è¤‡è¨ºæ–­ã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº†');
            console.log('ğŸ“‹ ä½¿ç”¨æ–¹æ³•:');
            console.log('  1. ã€Œè¨ºæ–­é–‹å§‹ã€ã§åº§æ¨™ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ†æ');
            console.log('  2. ã€ŒBBç·¨é›†é–‹å§‹ã€ã§BBæ“ä½œé–‹å§‹');
            console.log('  3. ã€Œãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ONã€ã§å‹•çš„è¿½è·¡');
            console.log('  4. BBãƒãƒ³ãƒ‰ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ç«¶åˆã‚’è¦³å¯Ÿ');
        });
    </script>
</body>
</html>
