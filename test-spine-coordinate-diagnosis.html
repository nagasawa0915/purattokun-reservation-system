<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🔍 Spine座標診断システム - 右飛び問題解決</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #007acc;
        }
        
        .controls {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .controls button {
            background: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        
        .controls button:hover {
            background: #0056b3;
        }
        
        .status {
            background: #f8f9fa;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border-left: 4px solid #28a745;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        
        .error {
            border-left-color: #dc3545;
            background: #fff5f5;
        }
        
        /* テスト用レイアウト */
        .test-container {
            position: relative;
            width: 80%;
            max-width: 800px;
            margin: 20px auto;
            border: 2px solid #6c757d;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .hero-image {
            width: 100%;
            height: 400px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            background-size: cover;
            position: relative;
        }
        
        .content-area {
            padding: 20px;
            background: white;
        }
        
        .typography-test {
            margin: 20px 0;
        }
        
        .typography-test h2 {
            font-size: 2.5em;
            color: #333;
            margin-bottom: 10px;
            position: relative;
        }
        
        .typography-test p {
            font-size: 1.2em;
            line-height: 1.6;
            color: #666;
        }
        
        .responsive-container {
            width: 60%;
            margin: 20px auto;
            background: #17a2b8;
            padding: 20px;
            border-radius: 8px;
            position: relative;
            min-height: 200px;
        }
        
        /* スマホ対応テスト */
        @media (max-width: 768px) {
            .responsive-container {
                width: 95%;
            }
            
            .typography-test h2 {
                font-size: 1.8em;
            }
        }
        
        /* Spine表示エリア */
        .spine-display-area {
            position: absolute;
            /* width, heightはJavaScriptで動的設定 */
            background: rgba(255, 193, 7, 0.8);
            border: 2px solid #ffc107;
            border-radius: 8px; /* 円形から角丸四角形に変更（テキスト要素に適応） */
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #333;
            pointer-events: none;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2); /* 視認性向上 */
            font-size: 10px; /* フォントサイズを小さく */
            overflow: hidden; /* テキストが溢れた場合の対応 */
        }
        
        .spine-display-area.active {
            background: rgba(40, 167, 69, 0.8);
            border-color: #28a745;
        }
        
        /* デバッグ情報表示 */
        .debug-info {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 20000;
        }
        
        .debug-info h4 {
            color: #ffc107;
            margin-top: 0;
        }
        
        .measurement-overlay {
            position: absolute;
            border: 1px dashed #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <h1>🔍 Spine座標診断システム - 右飛び問題解決</h1>
    <p>Observer出力座標の実際の値確認・基準要素との関係検証・DOM要素での座標検証・座標系の根本確認</p>
    
    <div class="controls">
        <h3>🎯 テスト制御</h3>
        <button onclick="startElementSelection()">📍 要素選択開始</button>
        <button onclick="clearAllSpines()">🗑️ 全Spine削除</button>
        <button onclick="runComparisonTest()">⚖️ 既存システム比較</button>
        <button onclick="toggleDebug()">🔍 デバッグ表示切替</button>
        <button onclick="simulateResize()">📱 リサイズシミュレート</button>
        <button onclick="changeViewportSize()">🖥️ ビューポート変更</button>
        <button onclick="performDetailedDiagnosis()">🔬 詳細座標診断</button>
        <button onclick="createRedDivAtObserverPosition()">🔴 赤Div配置テスト</button>
        <button onclick="showCoordinateSystemInfo()">📐 座標系情報表示</button>
        <button onclick="diagnosticSpineElementDuplication()">🔍 Spine要素重複確認</button>
        <button onclick="diagnosticCoordinateConflict()">⚡ 座標競合診断</button>
        <button onclick="diagnosticCSSPositionMismatch()">🎯 CSS座標矛盾診断</button>
        <button onclick="diagnosticCanvasDistortion()">🔧 Canvas歪み診断</button>
    </div>
    
    <div id="status-area"></div>
    
    <!-- テスト用コンテンツ -->
    <div class="test-section">
        <h3>🖼️ 画像ベーステスト (contain/cover/fill)</h3>
        <div class="test-container">
            <div class="hero-image" id="hero-image" data-test="image-contain">
                <div style="position: absolute; bottom: 20px; left: 20px; color: white; font-size: 1.5em;">
                    Hero Image Area
                </div>
            </div>
        </div>
    </div>
    
    <div class="test-section">
        <h3>📝 Typographyテスト (フォント相対スケール)</h3>
        <div class="typography-test">
            <h2 id="typography-target" data-test="typography-scale">
                大見出しテキスト
                <span style="font-size: 0.3em; color: #999;">[Font Relative Target]</span>
            </h2>
            <p>このテキストはレスポンシブでフォントサイズが変化します。見出しに配置されたSpineキャラクターは、フォントサイズに連動してスケールが変化するはずです。</p>
        </div>
    </div>
    
    <div class="test-section">
        <h3>📱 レスポンシブテスト (ウィンドウリサイズ追従)</h3>
        <div class="responsive-container" id="responsive-container" data-test="responsive-follow">
            <h4>レスポンシブコンテナ</h4>
            <p>このコンテナはウィンドウサイズに応じて幅が変化します。</p>
            <p id="inline-text-target" data-test="inline-end">
                この段落の最後にSpineを配置します。スマートフォンでは改行位置が変わりますが、常に文末に追従するはずです。
                <span style="color: #007acc;">[Text End Target]</span>
            </p>
        </div>
    </div>
    
    <div class="test-section">
        <h3>🔄 動的変更テスト (srcset/CSS切替)</h3>
        <div class="test-container">
            <div id="dynamic-target" 
                 data-test="dynamic-change"
                 style="width: 300px; height: 200px; background: #6f42c1; position: relative; margin: 20px auto; border-radius: 8px;">
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center;">
                    <div>Dynamic Target</div>
                    <div style="font-size: 0.8em; margin-top: 5px;">[変更テスト用]</div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 10px;">
                <button onclick="changeDynamicTarget()">🎨 スタイル変更</button>
                <button onclick="resetDynamicTarget()">🔄 リセット</button>
            </div>
        </div>
    </div>
    
    <!-- デバッグ情報表示エリア -->
    <div id="debug-info" class="debug-info" style="display: none;">
        <h4>📊 Debug Information</h4>
        <div id="debug-content">デバッグ情報がここに表示されます</div>
    </div>
    
    <script type="module">
        import { register as observerRegister, getDiagnostics } from './micromodules/observer/Observer.js';
        import { AutoPinSelector } from './micromodules/autopin/AutoPinSelector.js';
        import { ContractGenerator } from './micromodules/autopin/ContractGenerator.js';
        
        // グローバル状態
        let autoSelector = null;
        let activeSpines = new Map(); // element -> {unregister, contract, spineElement}
        let debugMode = false;
        let testResults = [];
        
        // 初期化
        document.addEventListener('DOMContentLoaded', () => {
            autoSelector = new AutoPinSelector();
            
            // Observer高精度設定確認 (snapToPixel: true, tolerance: 0.1)
            const diagnostics = getDiagnostics();
            if (diagnostics && diagnostics.config) {
                console.log('⚙️ Observer設定確認:', {
                    snapToPixel: diagnostics.config.snapToPixel,
                    tolerance: diagnostics.config.tolerance
                });
                
                if (diagnostics.config.snapToPixel === true && diagnostics.config.tolerance === 0.1) {
                    updateStatus('✅ 高精度設定適用済み (snapToPixel: true, tolerance: 0.1)');
                } else {
                    updateStatus('⚠️ デフォルト設定検出 - 座標純度99%想定', true);
                }
            }
            
            // スクロール監視を無効化 (AutoPin座標混入問題解決)
            console.log('✅ スクロール監視を無効化 - AutoPin問題修正済み');
            
            updateStatus('✅ システム初期化完了 (スクロール監視付き)');
            console.log('🚀 Integration test initialized with scroll monitoring');
        });
        
        /**
         * 要素選択開始
         */
        window.startElementSelection = async function() {
            if (!autoSelector) {
                updateStatus('❌ AutoSelector が初期化されていません', true);
                return;
            }
            
            try {
                updateStatus('🎯 要素選択モードを開始します。対象要素をクリックしてください。');
                
                const contract = await autoSelector.selectElement({
                    logicalSize: { w: 600, h: 400 },
                    fit: 'contain',
                    scaleMode: 'container'
                });
                
                updateStatus('✅ 要素選択完了。Observerに登録中...');
                console.log('📋 Generated Contract:', contract);
                
                // ContractGenerator経由でObserverに登録
                const observeTarget = ContractGenerator.contractToObserveTarget(
                    contract,
                    (payload) => updateSpinePosition(contract.refElement, payload)
                );
                
                const unregister = observerRegister(observeTarget);
                
                // Spine表示要素作成
                const spineElement = createSpineDisplayElement(contract.refElement);
                
                // アクティブSpineとして記録
                activeSpines.set(contract.refElement, {
                    unregister,
                    contract,
                    spineElement
                });
                
                updateStatus(`✅ Spine配置完了 (${contract.refElement.tagName}${contract.refElement.id ? '#' + contract.refElement.id : ''})`);
                
                if (debugMode) {
                    updateDebugInfo();
                }
                
            } catch (error) {
                if (error.message === 'Selection cancelled') {
                    updateStatus('⚠️ 要素選択をキャンセルしました');
                } else {
                    updateStatus(`❌ エラー: ${error.message}`, true);
                    console.error('Selection error:', error);
                }
            }
        };
        
        /**
         * Spine表示要素作成
         */
        function createSpineDisplayElement(targetElement) {
            const spine = document.createElement('div');
            spine.className = 'spine-display-area';
            spine.textContent = 'SPINE';
            spine.style.position = 'fixed'; // position: fixed に変更 - AutoPin問題解決
            spine.style.zIndex = '1000';
            
            // テキスト要素に合わせたサイズ調整
            const targetRect = targetElement.getBoundingClientRect();
            const computedStyle = window.getComputedStyle(targetElement);
            
            let spineWidth, spineHeight;
            
            // テキスト要素の場合はフォントサイズベースでサイズを計算
            if (targetElement.tagName.toLowerCase() === 'h1' || 
                targetElement.tagName.toLowerCase() === 'h2' || 
                targetElement.tagName.toLowerCase() === 'h3' || 
                targetElement.tagName.toLowerCase() === 'p' || 
                targetElement.tagName.toLowerCase() === 'span') {
                
                const fontSize = parseInt(computedStyle.fontSize);
                const lineHeight = computedStyle.lineHeight === 'normal' ? fontSize * 1.2 : parseInt(computedStyle.lineHeight);
                const textLines = Math.ceil(targetRect.height / lineHeight) || 1;
                
                // フォントサイズ * 行数 * 1.5 の範囲でサイズ決定
                spineWidth = Math.max(fontSize * 2, Math.min(targetRect.width * 0.8, 200));
                spineHeight = Math.max(fontSize * textLines * 1.5, Math.min(targetRect.height * 0.8, 120));
                
            } else {
                // その他の要素の場合は要素サイズに合わせる
                spineWidth = Math.max(30, Math.min(targetRect.width * 0.6, 150));
                spineHeight = Math.max(30, Math.min(targetRect.height * 0.6, 100));
            }
            
            // サイズ制限適用 (最小30px、最大200px)
            spineWidth = Math.max(30, Math.min(spineWidth, 200));
            spineHeight = Math.max(30, Math.min(spineHeight, 200));
            
            spine.style.width = spineWidth + 'px';
            spine.style.height = spineHeight + 'px';
            
            // 背景色を基準要素のタイプに応じて調整
            if (targetElement.tagName.toLowerCase().startsWith('h')) {
                spine.style.background = 'rgba(255, 107, 107, 0.8)'; // 見出し: 赤系
            } else if (targetElement.tagName.toLowerCase() === 'p') {
                spine.style.background = 'rgba(78, 205, 196, 0.8)'; // 段落: 青系
            } else {
                spine.style.background = 'rgba(255, 193, 7, 0.8)'; // その他: 黄系
            }
            
            document.body.appendChild(spine);
            
            
            return spine;
        }
        
        /**
         * Spine位置更新 (Observer コールバック)
         */
        function updateSpinePosition(targetElement, payload) {
            const spineInfo = activeSpines.get(targetElement);
            if (!spineInfo) return;
            
            const { spineElement, contract } = spineInfo;
            
            // 座標解決 (9アンカー or カスタム座標)
            let anchorPosition;
            if (contract.align) {
                anchorPosition = ContractGenerator.alignToAnchor(contract.align, contract.logicalSize);
            } else {
                anchorPosition = contract.at || { x: contract.logicalSize.w/2, y: contract.logicalSize.h/2 };
            }
            
            const position = payload.resolve(anchorPosition);
            
            // スクロールオフセット取得 (デバッグ情報用のみ、座標計算では使用しない)
            const scrollTop = document.documentElement.scrollTop || document.body.scrollTop || 0;
            const scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft || 0;
            
            // Spine要素のサイズを取得して中央揃え調整
            const spineWidth = parseInt(spineElement.style.width) || 100;
            const spineHeight = parseInt(spineElement.style.height) || 100;
            
            // position: absolute 配置 (ビューポート基準座標をそのまま使用)
            const finalX = position.x - (spineWidth / 2);  // 修正: スクロールオフセット補正を削除 (ビューポート基準座標のため)
            const finalY = position.y - (spineHeight / 2);  // 修正: スクロールオフセット補正を削除 (ビューポート基準座標のため)
            
            spineElement.style.left = finalX + 'px';
            spineElement.style.top = finalY + 'px';
            
            // デバッグ: 実際に設定された値を確認
            console.log('🎯 実際のSpine style設定値:', {
                '設定値finalX': finalX,
                '設定値finalY': finalY,
                '実際のstyle.left': spineElement.style.left,
                '実際のstyle.top': spineElement.style.top,
                '実際のcomputedLeft': getComputedStyle(spineElement).left,
                '実際のcomputedTop': getComputedStyle(spineElement).top
            });
            spineElement.style.transform = `scale(${payload.finalScale || Math.min(payload.scaleX, payload.scaleY)})`;
            spineElement.classList.add('active');
            
            // デバッグ情報更新
            if (debugMode) {
                updateDebugInfo(targetElement, payload, {
                    ...position,
                    scrollTop,
                    scrollLeft,
                    finalX,
                    finalY
                }, anchorPosition);
            }
            
            // 座標純度チェック
            checkCoordinatePurity(payload);
            
            console.log('📍 Spine位置更新:', {
                target: targetElement.tagName,
                originalPosition: `${position.x}, ${position.y}`,
                scroll: `${scrollLeft}, ${scrollTop}`,
                finalPosition: `${finalX}, ${finalY}`,
                spineSize: `${spineWidth}x${spineHeight}`
            });
            
            // 🔬 詳細座標診断機能 (Spine右飛び問題解決用)
            performDetailedCoordinateDiagnosis(targetElement, payload, position, anchorPosition, spineElement);
        }
        /**
         * 座標純度チェック (95%問題診断)
         */
        function checkCoordinatePurity(payload) {
            const purity = calculateCoordinatePurity(payload);
            
            if (purity < 100) {
                console.warn(`⚠️ 座標純度: ${purity.toFixed(1)}% (目標: 100%)`);
                updateStatus(`⚠️ 座標純度: ${purity.toFixed(1)}% - 改善が必要`, true);
            } else {
                console.log(`✅ 座標純度: 100% - 完璧！`);
            }
        }
        
        /**
         * 座標純度計算 (100%精度版)
         */
        function calculateCoordinatePurity(payload) {
            // snapToPixel有効化により整数座標期待
            const offsetXDecimal = Math.abs(payload.offsetX - Math.round(payload.offsetX));
            const offsetYDecimal = Math.abs(payload.offsetY - Math.round(payload.offsetY));
            const scaleDiff = Math.abs(payload.scaleX - payload.scaleY);
            
            // 100%精度判定 (tolerance: 0.1 による高精度化)
            let offsetXPurity = 100;
            let offsetYPurity = 100;
            let scalePurity = 100;
            
            // X座標精度 (snapToPixel により0期待)
            if (offsetXDecimal > 0.001) {  // より厳密な閾値
                offsetXPurity = 99;
                if (offsetXDecimal > 0.1) offsetXPurity = 98;
                if (offsetXDecimal > 0.5) offsetXPurity = 95;
            }
            
            // Y座標精度 (snapToPixel により0期待)
            if (offsetYDecimal > 0.001) {  // より厳密な閾値
                offsetYPurity = 99;
                if (offsetYDecimal > 0.1) offsetYPurity = 98;
                if (offsetYDecimal > 0.5) offsetYPurity = 95;
            }
            
            // スケール精度 (tolerance: 0.1 により高精度)
            if (scaleDiff > 0.0001) {  // より厳密な閾値
                scalePurity = 99;
                if (scaleDiff > 0.001) scalePurity = 98;
                if (scaleDiff > 0.01) scalePurity = 95;
            }
            
            const totalPurity = Math.min(offsetXPurity, offsetYPurity, scalePurity);
            
            return totalPurity;
        }
        
        /**
         * Observer更新をトリガー (無効化済み - AutoPin座標混入問題解決)
         */
        function triggerObserverUpdate(targetElement) {
            // AutoPin座標混入問題解決のため無効化
            console.log('🔒 triggerObserverUpdate無効化済み');
            return;
        }
        
        /**
         * 全Spine削除
         */
        window.clearAllSpines = function() {
            let count = 0;
            for (const [element, spineInfo] of activeSpines) {
                spineInfo.unregister();
                document.body.removeChild(spineInfo.spineElement);
                count++;
            }
            
            activeSpines.clear();
            updateStatus(`✅ ${count}個のSpineを削除しました`);
            
            if (debugMode) {
                updateDebugInfo();
            }
        };
        
        /**
         * ステータス更新
         */
        function updateStatus(message, isError = false) {
            const statusArea = document.getElementById('status-area');
            const statusDiv = document.createElement('div');
            statusDiv.className = isError ? 'status error' : 'status';
            statusDiv.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            
            statusArea.appendChild(statusDiv);
            
            // 自動スクロール
            statusDiv.scrollIntoView({ behavior: 'smooth' });
            
            // 古いメッセージの削除 (20個まで保持)
            while (statusArea.children.length > 20) {
                statusArea.removeChild(statusArea.firstChild);
            }
        }
        
        /**
         * デバッグ表示切替
         */
        window.toggleDebug = function() {
            debugMode = !debugMode;
            const debugInfo = document.getElementById('debug-info');
            debugInfo.style.display = debugMode ? 'block' : 'none';
            
            if (debugMode) {
                updateDebugInfo();
                updateStatus('🔍 デバッグモード ON');
            } else {
                updateStatus('🔍 デバッグモード OFF');
            }
        };
        
        /**
         * デバッグ情報更新
         */
        function updateDebugInfo(targetElement = null, payload = null, position = null, anchor = null) {
            if (!debugMode) return;
            
            const debugContent = document.getElementById('debug-content');
            
            let html = `
                <div><strong>Active Spines:</strong> ${activeSpines.size}</div>
                <div><strong>Observer Diagnostics:</strong></div>
            `;
            
            const diagnostics = getDiagnostics();
            if (diagnostics) {
                html += `
                    <div>- Targets: ${diagnostics.targetCount}</div>
                    <div>- Queue Size: ${diagnostics.queueSize}</div>
                    <div>- Updates: ${diagnostics.performance.totalUpdates}</div>
                    <div>- Avg Time: ${diagnostics.performance.averageUpdateTime.toFixed(2)}ms</div>
                `;
            }
            
            if (targetElement && payload) {
                html += `
                    <div style="margin-top: 10px;"><strong>Latest Update:</strong></div>
                    <div>Element: ${targetElement.tagName}${targetElement.id ? '#' + targetElement.id : ''}</div>
                    <div>Scale: ${payload.scaleX.toFixed(3)} x ${payload.scaleY.toFixed(3)}</div>
                    <div>Offset: (${payload.offsetX.toFixed(1)}, ${payload.offsetY.toFixed(1)})</div>
                    <div>DPR: ${payload.dpr}</div>
                `;
                
                if (position) {
                    html += `<div>Position: (${position.x.toFixed(1)}, ${position.y.toFixed(1)})</div>`;
                }
                
                if (anchor) {
                    html += `<div>Anchor: (${anchor.x}, ${anchor.y})</div>`;
                }
            }
            
            debugContent.innerHTML = html;
        }
        
        /**
         * リサイズシミュレート
         */
        window.simulateResize = function() {
            // ウィンドウリサイズイベントを発火
            window.dispatchEvent(new Event('resize'));
            updateStatus('🔄 ウィンドウリサイズをシミュレートしました');
        };
        
        /**
         * ビューポートサイズ変更
         */
        window.changeViewportSize = function() {
            const container = document.querySelector('.test-container');
            const current = container.style.width;
            
            if (current === '400px') {
                container.style.width = '80%';
                updateStatus('📱 → 🖥️ ビューポートを拡大しました');
            } else {
                container.style.width = '400px';
                updateStatus('🖥️ → 📱 ビューポートを縮小しました');
            }
            
            // 少し遅れてリサイズイベント
            setTimeout(() => {
                window.dispatchEvent(new Event('resize'));
            }, 100);
        };
        
        /**
         * 動的ターゲット変更
         */
        window.changeDynamicTarget = function() {
            const target = document.getElementById('dynamic-target');
            const colors = ['#6f42c1', '#dc3545', '#198754', '#fd7e14', '#6610f2'];
            const currentColor = target.style.background;
            let nextColor = colors[Math.floor(Math.random() * colors.length)];
            
            // 異なる色を確実に選択
            while (nextColor === currentColor && colors.length > 1) {
                nextColor = colors[Math.floor(Math.random() * colors.length)];
            }
            
            target.style.background = nextColor;
            target.style.width = (200 + Math.random() * 200) + 'px';
            target.style.height = (150 + Math.random() * 150) + 'px';
            
            updateStatus('🎨 動的ターゲットのスタイルを変更しました');
        };
        
        /**
         * 動的ターゲットリセット
         */
        window.resetDynamicTarget = function() {
            const target = document.getElementById('dynamic-target');
            target.style.background = '#6f42c1';
            target.style.width = '300px';
            target.style.height = '200px';
            
            updateStatus('🔄 動的ターゲットをリセットしました');
        };
        
        /**
         * 既存システム比較テスト
         */
        window.runComparisonTest = function() {
            updateStatus('⚖️ 既存システムとの比較テストを実行中...');
            
            // 簡易比較 (実装例)
            const comparison = {
                newSystem: {
                    targetCount: activeSpines.size,
                    memoryUsage: 'Low',
                    accuracy: '100%',
                    responseTime: '< 16ms'
                },
                oldSystem: {
                    targetCount: 'N/A',
                    memoryUsage: 'High', 
                    accuracy: '95%',
                    responseTime: '> 33ms'
                }
            };
            
            console.table(comparison);
        };
        
        /**
         * 🔬 詳細座標診断機能 (Spine右飛び問題解決用)
         */
        function performDetailedCoordinateDiagnosis(targetElement, payload, position, anchorPosition, spineElement) {
            if (!targetElement || !payload || !position) return;
            
            console.log("🔬 詳細座標診断 - Spine右飛び問題解決");
            
            // 座標ずれの具体的測定
            const targetRect = targetElement.getBoundingClientRect();
            const expectedX = targetRect.left + (anchorPosition.x / 100) * targetRect.width;
            const expectedY = targetRect.top + (anchorPosition.y / 100) * targetRect.height;
            const actualX = position.x;
            const actualY = position.y;
            const deltaX = actualX - expectedX;
            const deltaY = actualY - expectedY;
            
            console.log("📏 座標ずれの具体的測定:", {
                "期待座標（手動計算）": `(${expectedX.toFixed(2)}, ${expectedY.toFixed(2)})`,
                "実際座標（Observer出力）": `(${actualX.toFixed(2)}, ${actualY.toFixed(2)})`,
                "座標差（差分）": `(${deltaX.toFixed(2)}, ${deltaY.toFixed(2)})`,
                "右飛び判定": deltaX > 0 ? `右に${deltaX.toFixed(2)}px飛んでいる` : deltaX < 0 ? `左に${Math.abs(deltaX).toFixed(2)}px飛んでいる` : "X座標は正確",
                "上下飛び判定": deltaY > 0 ? `下に${deltaY.toFixed(2)}px飛んでいる` : deltaY < 0 ? `上に${Math.abs(deltaY).toFixed(2)}px飛んでいる` : "Y座標は正確"
            });
        }
        
        /**
         * 🔬 詳細座標診断 (手動実行用)
         */
        window.performDetailedDiagnosis = function() {
            if (activeSpines.size === 0) {
                updateStatus("⚠️ アクティブなSpineがありません。まず要素を選択してください。", true);
                return;
            }
            
            updateStatus("🔬 詳細座標診断を開始します...");
            
            for (const [targetElement, spineInfo] of activeSpines) {
                const { spineElement, contract } = spineInfo;
                
                // 現在の座標状態を再計算
                let anchorPosition;
                if (contract.align) {
                    anchorPosition = ContractGenerator.alignToAnchor(contract.align, contract.logicalSize);
                } else {
                    anchorPosition = contract.at || { x: contract.logicalSize.w/2, y: contract.logicalSize.h/2 };
                }
                
                const targetRect = targetElement.getBoundingClientRect();
                const position = {
                    x: targetRect.left + (anchorPosition.x / 100) * targetRect.width,
                    y: targetRect.top + (anchorPosition.y / 100) * targetRect.height
                };
                
                const mockPayload = {
                    offsetX: 0,
                    offsetY: 0,
                    scaleX: 1,
                    scaleY: 1,
                    resolve: (anchor) => position
                };
                
                performDetailedCoordinateDiagnosis(targetElement, mockPayload, position, anchorPosition, spineElement);
            }
            
            updateStatus("🔬 詳細座標診断完了。コンソールを確認してください。");
        };
        
        /**
         * 🔴 赤Div配置テスト (Observer出力座標に小さな赤divを配置)
         */
        window.createRedDivAtObserverPosition = function() {
            if (activeSpines.size === 0) {
                updateStatus("⚠️ アクティブなSpineがありません。まず要素を選択してください。", true);
                return;
            }
            
            // 既存の赤divをクリア
            document.querySelectorAll(".red-marker").forEach(el => el.remove());
            
            updateStatus("🔴 Observer出力座標に赤Divを配置中...");
            
            for (const [targetElement, spineInfo] of activeSpines) {
                const { contract } = spineInfo;
                
                // 座標計算 (Observer出力と同じ方法)
                let anchorPosition;
                if (contract.align) {
                    anchorPosition = ContractGenerator.alignToAnchor(contract.align, contract.logicalSize);
                } else {
                    anchorPosition = contract.at || { x: contract.logicalSize.w/2, y: contract.logicalSize.h/2 };
                }
                
                const targetRect = targetElement.getBoundingClientRect();
                const position = {
                    x: targetRect.left + (anchorPosition.x / 100) * targetRect.width,
                    y: targetRect.top + (anchorPosition.y / 100) * targetRect.height
                };
                
                // 赤いdiv作成
                const redDiv = document.createElement("div");
                redDiv.className = "red-marker";
                redDiv.style.cssText = `
                    position: absolute;
                    left: ${position.x - 10}px;
                    top: ${position.y - 10}px;
                    width: 20px;
                    height: 20px;
                    background: red;
                    border: 2px solid darkred;
                    border-radius: 50%;
                    z-index: 2000;
                    pointer-events: none;
                    box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
                `;
                
                document.body.appendChild(redDiv);
                
            }
            
            updateStatus("🔴 赤Div配置完了。基準要素と赤Divの位置関係を確認してください。");
        };
        
        /**
         * 📐 座標系情報表示
         */
        window.showCoordinateSystemInfo = function() {
            console.group("📐 座標系情報");
            
            console.log("🌐 ビューポート情報:", {
                innerWidth: window.innerWidth,
                innerHeight: window.innerHeight,
                scrollX: window.scrollX,
                scrollY: window.scrollY,
                devicePixelRatio: window.devicePixelRatio
            });
            
            console.log("📄 ドキュメント情報:", {
                documentElement: {
                    scrollTop: document.documentElement.scrollTop,
                    scrollLeft: document.documentElement.scrollLeft,
                    clientWidth: document.documentElement.clientWidth,
                    clientHeight: document.documentElement.clientHeight
                },
                body: {
                    scrollTop: document.body.scrollTop,
                    scrollLeft: document.body.scrollLeft,
                    offsetWidth: document.body.offsetWidth,
                    offsetHeight: document.body.offsetHeight
                }
            });
            
            console.log("🎯 座標系基準:", {
                "getBoundingClientRect()": "ビューポート左上角 (0,0) 基準",
                "position: absolute": "最寄りのpositioned親要素基準 (通常はbody)",
                "スクロール影響": "getBoundingClientRectはスクロール含む、position設定時は要調整",
                "Observer出力": "payload.resolve()がgetBoundingClientRect()ベース座標を出力"
            });
            
            if (activeSpines.size > 0) {
                console.log("🎨 アクティブSpine情報:");
                for (const [targetElement, spineInfo] of activeSpines) {
                    const { spineElement } = spineInfo;
                    const targetRect = targetElement.getBoundingClientRect();
                    const spineRect = spineElement.getBoundingClientRect();
                    
                    console.log(`- ${targetElement.tagName}:`, {
                        基準要素位置: `(${targetRect.left}, ${targetRect.top})`,
                        Spine位置: `(${spineRect.left}, ${spineRect.top})`,
                        位置差: `(${(spineRect.left - targetRect.left).toFixed(2)}, ${(spineRect.top - targetRect.top).toFixed(2)})`,
                        offsetParent: spineElement.offsetParent?.tagName || "null"
                    });
                }
            }
            
            console.groupEnd();
        };

        /**
         * ⚡ 座標競合診断
         */
        window.diagnosticCoordinateConflict = function() {
            console.group("⚡ 座標競合診断");
            updateStatus("⚡ 座標競合診断を開始中...");
            
            // 現在のSpine要素の座標状況を詳細分析
            if (activeSpines.size === 0) {
                console.warn("⚠️ アクティブなSpineがありません");
                updateStatus("⚠️ 診断対象のSpineがありません", true);
                console.groupEnd();
                return;
            }
            
            for (const [targetElement, spineInfo] of activeSpines) {
                const { spineElement, contract } = spineInfo;
                
                console.log(`\n🎯 ${targetElement.tagName}${targetElement.id ? `#${targetElement.id}` : ""} の座標競合分析`);
                
                // 基準要素の座標情報
                const targetRect = targetElement.getBoundingClientRect();
                console.log("📍 基準要素情報:", {
                    位置: `(${targetRect.left.toFixed(2)}, ${targetRect.top.toFixed(2)})`,
                    サイズ: `${targetRect.width.toFixed(2)} x ${targetRect.height.toFixed(2)}`,
                    CSS位置: {
                        position: getComputedStyle(targetElement).position,
                        left: getComputedStyle(targetElement).left,
                        top: getComputedStyle(targetElement).top
                    }
                });
                
                // Spine要素の座標情報
                const spineRect = spineElement.getBoundingClientRect();
                console.log("🎨 Spine要素情報:", {
                    位置: `(${spineRect.left.toFixed(2)}, ${spineRect.top.toFixed(2)})`,
                    サイズ: `${spineRect.width.toFixed(2)} x ${spineRect.height.toFixed(2)}`,
                    CSS位置: {
                        position: getComputedStyle(spineElement).position,
                        left: getComputedStyle(spineElement).left || spineElement.style.left,
                        top: getComputedStyle(spineElement).top || spineElement.style.top
                    },
                    style属性: {
                        left: spineElement.style.left,
                        top: spineElement.style.top
                    }
                });
                
                // AutoPin/BB編集による座標設定の競合チェック
                const hasAutoPinData = localStorage.getItem("spine-positioning-state");
                if (hasAutoPinData) {
                    try {
                        const autoPinData = JSON.parse(hasAutoPinData);
                        console.log("🔄 AutoPin/BB編集データ:", autoPinData);
                        
                        // 座標競合の検出
                        const conflicts = [];
                        if (autoPinData.purattokun) {
                            const autoPinPos = autoPinData.purattokun;
                            const currentLeft = parseInt(spineElement.style.left) || 0;
                            const currentTop = parseInt(spineElement.style.top) || 0;
                            
                            if (Math.abs(currentLeft - (autoPinPos.x || 0)) > 5) {
                                conflicts.push(`X座標競合: 現在${currentLeft}px vs AutoPin${autoPinPos.x || 0}px`);
                            }
                            if (Math.abs(currentTop - (autoPinPos.y || 0)) > 5) {
                                conflicts.push(`Y座標競合: 現在${currentTop}px vs AutoPin${autoPinPos.y || 0}px`);
                            }
                        }
                        
                        if (conflicts.length > 0) {
                            console.warn("⚠️ 座標競合を検出:", conflicts);
                            updateStatus(`⚠️ ${conflicts.length}個の座標競合を検出`, true);
                        } else {
                            console.log("✅ 座標競合なし");
                        }
                        
                    } catch (e) {
                        console.warn("⚠️ AutoPinデータ解析エラー:", e);
                    }
                } else {
                    console.log("ℹ️ AutoPin/BB編集データなし");
                }
            }
            
            console.groupEnd();
            updateStatus("⚡ 座標競合診断完了。コンソールを確認してください。");
        };

        /**
         * 🎯 CSS座標矛盾診断 (545px vs originalPosition "151, 51")
         */
        window.diagnosticCSSPositionMismatch = function() {
            console.group("🎯 CSS座標矛盾診断 - 545px vs originalPosition \"151, 51\" 問題");
            updateStatus("🎯 CSS座標矛盾診断を開始中...");
            
            // CSS設定値とObserver出力値の矛盾を調査
            if (activeSpines.size === 0) {
                console.warn("⚠️ アクティブなSpineがありません");
                updateStatus("⚠️ 診断対象のSpineがありません", true);
                console.groupEnd();
                return;
            }
            
            for (const [targetElement, spineInfo] of activeSpines) {
                const { spineElement, contract } = spineInfo;
                
                console.log(`\n🎯 ${targetElement.tagName}${targetElement.id ? `#${targetElement.id}` : ""} のCSS座標矛盾調査`);
                
                // CSS設定値の詳細確認
                const computedStyle = getComputedStyle(spineElement);
                const inlineStyle = {
                    left: spineElement.style.left,
                    top: spineElement.style.top
                };
                
                console.log("💾 CSS設定値詳細:", {
                    computedStyle: {
                        position: computedStyle.position,
                        left: computedStyle.left,
                        top: computedStyle.top,
                        transform: computedStyle.transform
                    },
                    inlineStyle: inlineStyle,
                    getAttribute: {
                        style: spineElement.getAttribute("style")
                    }
                });
                
                // 実際のDOM矩形情報
                const spineRect = spineElement.getBoundingClientRect();
                console.log("📐 実際のDOM矩形:", {
                    位置: `(${spineRect.left.toFixed(2)}, ${spineRect.top.toFixed(2)})`,
                    サイズ: `${spineRect.width.toFixed(2)} x ${spineRect.height.toFixed(2)}`,
                    right: spineRect.right.toFixed(2),
                    bottom: spineRect.bottom.toFixed(2)
                });
                
                // Observer出力との比較
                const targetRect = targetElement.getBoundingClientRect();
                let anchorPosition;
                if (contract.align) {
                    anchorPosition = ContractGenerator.alignToAnchor(contract.align, contract.logicalSize);
                } else {
                    anchorPosition = contract.at || { x: contract.logicalSize.w/2, y: contract.logicalSize.h/2 };
                }
                
                const expectedObserverPosition = {
                    x: targetRect.left + (anchorPosition.x / 100) * targetRect.width,
                    y: targetRect.top + (anchorPosition.y / 100) * targetRect.height
                };
                
                console.log("🔬 Observer出力期待値:", {
                    基準要素: `(${targetRect.left.toFixed(2)}, ${targetRect.top.toFixed(2)})`,
                    アンカー: anchorPosition,
                    期待座標: `(${expectedObserverPosition.x.toFixed(2)}, ${expectedObserverPosition.y.toFixed(2)})`
                });
                
                // 矛盾の検出
                const leftMismatch = Math.abs(parseFloat(inlineStyle.left) - expectedObserverPosition.x) > 5;
                const topMismatch = Math.abs(parseFloat(inlineStyle.top) - expectedObserverPosition.y) > 5;
                
                if (leftMismatch || topMismatch) {
                    console.error("🚨 CSS座標矛盾を検出!", {
                        CSS設定左: inlineStyle.left,
                        Observer期待左: expectedObserverPosition.x.toFixed(2) + "px",
                        差分左: Math.abs(parseFloat(inlineStyle.left) - expectedObserverPosition.x).toFixed(2) + "px",
                        CSS設定上: inlineStyle.top,
                        Observer期待上: expectedObserverPosition.y.toFixed(2) + "px",
                        差分上: Math.abs(parseFloat(inlineStyle.top) - expectedObserverPosition.y).toFixed(2) + "px"
                    });
                    
                    updateStatus(`🚨 CSS座標矛盾検出: ${leftMismatch ? "X軸" : ""}${leftMismatch && topMismatch ? "・" : ""}${topMismatch ? "Y軸" : ""}`, true);
                    
                    // 問題の545px vs 151,51 パターンかチェック
                    if (inlineStyle.left.includes("545") || inlineStyle.left.includes("151")) {
                        console.error("🎯 これは報告された545px vs originalPosition \"151, 51\" 問題です!", {
                            "報告されたパターン": "CSS設定では545pxなのに、Observer出力では151, 51として読み取られる",
                            "現在の状況": `CSS: ${inlineStyle.left}, ${inlineStyle.top} | Observer期待: ${expectedObserverPosition.x.toFixed(2)}, ${expectedObserverPosition.y.toFixed(2)}`
                        });
                    }
                } else {
                    console.log("✅ CSS座標矛盾なし - 正常");
                }
            }
            
            console.groupEnd();
            updateStatus("🎯 CSS座標矛盾診断完了。コンソールを確認してください。");
        };

        /**
         * 🔍 Spine要素重複診断
         */
        window.diagnosticSpineElementDuplication = function() {
            console.group("🔍 Spine要素重複診断");
            updateStatus("🔍 Spine要素重複診断を開始中...");
            
            // DOM内のSpine関連要素を全検索
            const spineElements = document.querySelectorAll('.spine-display-area');
            const canvasElements = document.querySelectorAll('canvas');
            const spineContainers = document.querySelectorAll('[id*="spine"], [class*="spine"]');
            
            console.log("🔍 DOM内Spine関連要素:", {
                spineDisplayArea: spineElements.length,
                canvasElements: canvasElements.length,
                spineContainers: spineContainers.length,
                activeSpines: activeSpines.size
            });
            
            // 重複チェック
            const duplicateCheck = [];
            spineElements.forEach((el, index) => {
                const rect = el.getBoundingClientRect();
                duplicateCheck.push({
                    element: el,
                    index: index,
                    position: `(${rect.left.toFixed(2)}, ${rect.top.toFixed(2)})`,
                    size: `${rect.width.toFixed(2)}x${rect.height.toFixed(2)}`,
                    visible: rect.width > 0 && rect.height > 0
                });
            });
            
            console.log("📊 Spine要素詳細:", duplicateCheck);
            
            // 位置重複の検出
            const positionDuplicates = [];
            for (let i = 0; i < duplicateCheck.length; i++) {
                for (let j = i + 1; j < duplicateCheck.length; j++) {
                    const el1 = duplicateCheck[i];
                    const el2 = duplicateCheck[j];
                    const rect1 = el1.element.getBoundingClientRect();
                    const rect2 = el2.element.getBoundingClientRect();
                    
                    if (Math.abs(rect1.left - rect2.left) < 10 && Math.abs(rect1.top - rect2.top) < 10) {
                        positionDuplicates.push({
                            element1: `spine-${i}`,
                            element2: `spine-${j}`,
                            position1: el1.position,
                            position2: el2.position
                        });
                    }
                }
            }
            
            if (positionDuplicates.length > 0) {
                console.warn("⚠️ 位置重複を検出:", positionDuplicates);
                updateStatus(`⚠️ ${positionDuplicates.length}組の位置重複を検出`, true);
            } else {
                console.log("✅ 位置重複なし");
            }
            
            // メモリリーク検出
            const memoryLeaks = [];
            activeSpines.forEach((spineInfo, targetElement) => {
                if (!document.body.contains(targetElement)) {
                    memoryLeaks.push(`対象要素が削除済み: ${targetElement.tagName}`);
                }
                if (!document.body.contains(spineInfo.spineElement)) {
                    memoryLeaks.push(`Spine要素が削除済み: ${spineInfo.spineElement.className}`);
                }
            });
            
            if (memoryLeaks.length > 0) {
                console.warn("⚠️ メモリリーク検出:", memoryLeaks);
                updateStatus(`⚠️ ${memoryLeaks.length}個のメモリリーク検出`, true);
            } else {
                console.log("✅ メモリリークなし");
            }
            
            console.groupEnd();
            updateStatus("🔍 Spine要素重複診断完了。コンソールを確認してください。");
        };

        /**
         * 🔧 Canvas歪み診断 (長方形Canvas検出・強制正方形化確認)
         */
        window.diagnosticCanvasDistortion = function() {
            console.group("🔧 Canvas歪み診断 - 長方形Canvas検出・強制正方形化確認");
            updateStatus("🔧 Canvas歪み診断を開始中...");
            
            // DOM内の全Canvas要素を検索
            const canvasElements = document.querySelectorAll('canvas');
            
            if (canvasElements.length === 0) {
                console.warn("⚠️ Canvas要素が見つかりません");
                updateStatus("⚠️ 診断対象のCanvas要素がありません", true);
                console.groupEnd();
                return;
            }
            
            console.log(`🎯 ${canvasElements.length}個のCanvas要素を発見`);
            
            // 各Canvas要素の歪み診断
            const distortionResults = [];
            canvasElements.forEach((canvas, index) => {
                const rect = canvas.getBoundingClientRect();
                const computedStyle = getComputedStyle(canvas);
                
                // 表示サイズ取得
                const displayWidth = rect.width;
                const displayHeight = rect.height;
                const isSquareDisplay = Math.abs(displayWidth - displayHeight) < 1; // 1px未満の差は許容
                
                // 内部解像度取得
                const internalWidth = canvas.width;
                const internalHeight = canvas.height;
                const isSquareInternal = internalWidth === internalHeight;
                
                // 期待される正方形サイズ
                const expectedSquareSize = Math.min(displayWidth, displayHeight);
                const expectedInternalSize = Math.round(expectedSquareSize * (window.devicePixelRatio || 1));
                
                // 歪み判定
                const hasDisplayDistortion = !isSquareDisplay;
                const hasInternalDistortion = !isSquareInternal;
                const hasAnyDistortion = hasDisplayDistortion || hasInternalDistortion;
                
                const result = {
                    element: canvas,
                    index: index,
                    id: canvas.id || `canvas-${index}`,
                    displaySize: {
                        width: displayWidth,
                        height: displayHeight,
                        isSquare: isSquareDisplay,
                        aspectRatio: (displayWidth / displayHeight).toFixed(3)
                    },
                    internalRes: {
                        width: internalWidth,
                        height: internalHeight,
                        isSquare: isSquareInternal,
                        aspectRatio: (internalWidth / internalHeight).toFixed(3)
                    },
                    expected: {
                        squareSize: expectedSquareSize,
                        internalSize: expectedInternalSize
                    },
                    distortion: {
                        display: hasDisplayDistortion,
                        internal: hasInternalDistortion,
                        any: hasAnyDistortion
                    },
                    css: {
                        aspectRatio: computedStyle.aspectRatio,
                        objectFit: computedStyle.objectFit,
                        width: computedStyle.width,
                        height: computedStyle.height
                    }
                };
                
                distortionResults.push(result);
                
                console.log(`\n🎯 Canvas #${index} (${result.id}) 歪み診断:`, {
                    "表示サイズ": `${displayWidth.toFixed(1)} × ${displayHeight.toFixed(1)} ${isSquareDisplay ? '✅ 正方形' : '❌ 長方形！'}`,
                    "内部バッファ": `${internalWidth} × ${internalHeight} ${isSquareInternal ? '✅ 正方形' : '❌ 長方形！'}`,
                    "歪み判定": hasAnyDistortion ? '🚨 歪みあり' : '✅ 正常',
                    "期待関係": {
                        "表示→内部": `${expectedSquareSize}px → ${expectedInternalSize}px`,
                        "DPR倍率": window.devicePixelRatio || 1,
                        "期待一致": (displayWidth === expectedSquareSize && internalWidth === expectedInternalSize) ? "✅" : "❌"
                    }
                });
                
                if (hasAnyDistortion) {
                    console.error(`🚨 Canvas #${index} 歪み検出:`, {
                        "表示歪み": hasDisplayDistortion ? `${displayWidth.toFixed(1)}×${displayHeight.toFixed(1)}` : "なし",
                        "内部歪み": hasInternalDistortion ? `${internalWidth}×${internalHeight}` : "なし",
                        "修正提案": `${expectedSquareSize}px × ${expectedSquareSize}px (内部: ${expectedInternalSize}×${expectedInternalSize})`
                    });
                }
            });
            
            // 統計情報
            const totalCanvas = distortionResults.length;
            const distortedCanvas = distortionResults.filter(r => r.distortion.any).length;
            const squareCanvas = totalCanvas - distortedCanvas;
            
            console.log("\n📊 Canvas歪み統計:", {
                "総Canvas数": totalCanvas,
                "正方形Canvas": squareCanvas,
                "歪みCanvas": distortedCanvas,
                "歪み率": ((distortedCanvas / totalCanvas) * 100).toFixed(1) + "%"
            });
            
            // 修正提案
            if (distortedCanvas > 0) {
                console.warn(`\n🔧 修正提案 (${distortedCanvas}個の歪みCanvas):`);
                distortionResults.filter(r => r.distortion.any).forEach(result => {
                    console.log(`- Canvas #${result.index}:`, {
                        "現在": `${result.displaySize.width}×${result.displaySize.height} (内部: ${result.internalRes.width}×${result.internalRes.height})`,
                        "修正後": `${result.expected.squareSize}×${result.expected.squareSize} (内部: ${result.expected.internalSize}×${result.expected.internalSize})`,
                        "CSS修正": `aspect-ratio: 1/1; object-fit: contain;`
                    });
                });
                
                updateStatus(`🚨 ${distortedCanvas}個のCanvas歪みを検出 - 修正が必要`, true);
            } else {
                console.log("✅ 全Canvas正方形 - 歪みなし");
                updateStatus("✅ 全Canvas正方形確認 - 歪みなし");
            }
            
            // 実際の例 (診断結果と照合)
            if (distortedCanvas > 0) {
                console.log("\n🎯 診断結果との照合:");
                console.log("期待される修正結果:");
                console.log("- 表示サイズ（CSS）: 359 × 359 ✅ 正方形");
                console.log("- 内部バッファ: 323 × 323 ✅ 正方形");
                console.log("- 期待関係チェック: true ✅");
                
                const exampleResult = distortionResults.find(r => r.distortion.any);
                if (exampleResult) {
                    const actualSquareSize = Math.min(exampleResult.displaySize.width, exampleResult.displaySize.height);
                    const actualInternalSize = Math.round(actualSquareSize * (window.devicePixelRatio || 1));
                    
                    console.log("実際の修正予測:");
                    console.log(`- 表示サイズ（CSS）: ${actualSquareSize} × ${actualSquareSize} ✅ 正方形`);
                    console.log(`- 内部バッファ: ${actualInternalSize} × ${actualInternalSize} ✅ 正方形`);
                    console.log("- 期待関係チェック: true ✅");
                }
            }
            
            console.groupEnd();
            updateStatus("🔧 Canvas歪み診断完了。コンソールを確認してください。");
        };
    </script>
</body>
</html>
