<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>最小プロトタイプ - Spine Editor v4.0</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2d2d2d;
            color: #cccccc;
            height: 100vh;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        
        .app-container {
            display: grid;
            grid-template-areas: 
                "toolbar toolbar toolbar toolbar"
                "outliner preview preview properties"
                "outliner preview preview properties"
                "timeline timeline timeline timeline";
            grid-template-columns: minmax(200px, 300px) 2fr 2fr minmax(250px, 400px);
            grid-template-rows: 50px 2fr 1fr minmax(120px, 200px);
            height: 100vh;
            gap: 1px;
        }

        /* レスポンシブ対応 */
        @media (max-width: 1200px) {
            .app-container {
                grid-template-columns: minmax(180px, 250px) 3fr 1fr minmax(200px, 300px);
            }
        }

        @media (max-width: 900px) {
            .app-container {
                grid-template-areas: 
                    "toolbar toolbar toolbar"
                    "outliner preview properties"
                    "outliner preview properties"
                    "timeline timeline timeline";
                grid-template-columns: minmax(150px, 200px) 2fr minmax(150px, 250px);
                grid-template-rows: 50px 2fr 1fr minmax(100px, 150px);
            }
        }

        @media (max-width: 600px) {
            .app-container {
                grid-template-areas: 
                    "toolbar"
                    "preview"
                    "outliner"
                    "properties"
                    "timeline";
                grid-template-columns: 1fr;
                grid-template-rows: 50px 2fr 150px 200px 120px;
            }
            
            .outliner, .properties {
                padding: 8px;
            }
            
            .timeline {
                padding: 8px;
            }
        }
        
        .toolbar {
            grid-area: toolbar;
            background: linear-gradient(135deg, #1e1e1e 0%, #252525 100%);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 12px;
            border-bottom: 1px solid #404040;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .toolbar button {
            background: #404040;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .toolbar button:hover {
            background: #505050;
        }
        
        .toolbar button.primary {
            background: #007acc;
        }
        
        .toolbar button.primary:hover {
            background: #1a8cff;
        }
        
        .outliner {
            grid-area: outliner;
            background: linear-gradient(135deg, #2a2a2a 0%, #1f1f1f 100%);
            border-right: 1px solid #404040;
            padding: 12px;
            overflow-y: auto;
            box-shadow: inset -1px 0 3px rgba(0, 0, 0, 0.2);
        }
        
        .preview {
            grid-area: preview;
            background: linear-gradient(135deg, #1e1e1e 0%, #151515 100%);
            position: relative;
            overflow: hidden;
            border: 1px solid #404040;
        }
        
        .properties {
            grid-area: properties;
            background: linear-gradient(135deg, #2a2a2a 0%, #1f1f1f 100%);
            border-left: 1px solid #404040;
            padding: 12px;
            overflow-y: auto;
            box-shadow: inset 1px 0 3px rgba(0, 0, 0, 0.2);
        }

        .timeline {
            grid-area: timeline;
            background: linear-gradient(135deg, #262626 0%, #1c1c1c 100%);
            border-top: 1px solid #404040;
            padding: 12px;
            overflow-x: auto;
            overflow-y: hidden;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .timeline-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .timeline-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .timeline-btn {
            background: #404040;
            border: 1px solid #606060;
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            min-width: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .timeline-btn:hover {
            background: #505050;
        }

        .timeline-btn.active {
            background: #007acc;
            border-color: #1a8cff;
        }

        .timeline-scrubber {
            flex: 1;
            height: 60px;
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 4px;
            position: relative;
            margin: 0 12px;
            overflow: hidden;
        }

        .timeline-ruler {
            height: 20px;
            background: #333333;
            border-bottom: 1px solid #404040;
            position: relative;
        }

        .timeline-track {
            height: 39px;
            position: relative;
            border-bottom: 1px solid #404040;
        }

        .timeline-track:last-child {
            border-bottom: none;
        }

        .timeline-playhead {
            position: absolute;
            top: 0;
            left: 20%;
            width: 2px;
            height: 100%;
            background: #ff6b6b;
            z-index: 10;
            pointer-events: none;
        }

        .timeline-keyframe {
            position: absolute;
            top: 50%;
            width: 8px;
            height: 8px;
            background: #ffd43b;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            border: 1px solid #ffffff;
        }

        .timeline-keyframe:hover {
            background: #ffec8c;
            transform: translate(-50%, -50%) scale(1.2);
        }

        .timeline-time-display {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #cccccc;
            min-width: 80px;
        }
        
        .panel-title {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid #404040;
        }
        
        .file-tree {
            font-size: 12px;
        }
        
        .file-item {
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
            margin: 2px 0;
        }
        
        .file-item:hover {
            background: #404040;
        }
        
        .file-item.selected {
            background: #007acc;
        }
        
        .property-group {
            margin-bottom: 16px;
        }
        
        .property-label {
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 6px;
            color: #cccccc;
        }
        
        .property-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .property-row label {
            font-size: 11px;
            width: 20px;
            color: #999999;
        }
        
        .property-input {
            background: #404040;
            border: 1px solid #606060;
            color: white;
            padding: 4px 6px;
            border-radius: 3px;
            font-size: 11px;
            width: 60px;
        }
        
        .property-input:focus {
            outline: none;
            border-color: #007acc;
        }
        
        .property-select {
            background: #404040;
            border: 1px solid #606060;
            color: white;
            padding: 4px 6px;
            border-radius: 3px;
            font-size: 11px;
            width: 100px;
        }
        
        .property-select:focus {
            outline: none;
            border-color: #007acc;
        }
        
        .layer-controls {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }
        
        .layer-btn {
            background: #404040;
            border: 1px solid #606060;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
        }
        
        .layer-btn:hover {
            background: #505050;
        }
        
        .character-layers {
            font-size: 12px;
            min-height: 200px;
            position: relative;
        }
        
        .layer-item {
            background: linear-gradient(135deg, #383838 0%, #2d2d2d 100%);
            border: 1px solid #4a4a4a;
            border-radius: 6px;
            margin: 3px 0;
            padding: 10px;
            cursor: grab;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .layer-item:hover {
            background: linear-gradient(135deg, #454545 0%, #363636 100%);
            border-color: #5a5a5a;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
            transform: translateY(-1px);
        }
        
        .layer-item.selected {
            background: linear-gradient(135deg, #0099ff 0%, #007acc 100%);
            border-color: #1aa3ff;
            box-shadow: 0 3px 12px rgba(0, 122, 204, 0.3);
        }
        
        .layer-item.dragging {
            opacity: 0.7;
            cursor: grabbing;
            transform: rotate(2deg) scale(1.02);
            z-index: 1000;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
        }
        
        .layer-item.drag-over {
            border-color: #ff6b6b;
            background: linear-gradient(135deg, #ff6b6b20 0%, #ff4757 100%);
        }
        
        .layer-info {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 0;
        }
        
        .layer-name {
            font-weight: 600;
            font-size: 13px;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .layer-icon {
            font-size: 14px;
            opacity: 0.8;
        }
        
        .layer-animation {
            font-size: 10px;
            color: #b3b3b3;
            margin-top: 3px;
            font-style: italic;
        }
        
        .layer-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .layer-z-container {
            display: flex;
            align-items: center;
            gap: 4px;
            background: #1e1e1e;
            padding: 4px 8px;
            border-radius: 12px;
            border: 1px solid #404040;
        }
        
        .layer-z-label {
            font-size: 9px;
            color: #888888;
            font-weight: 600;
        }
        
        .layer-z-input {
            background: transparent;
            border: none;
            color: #ffffff;
            font-size: 11px;
            font-weight: 600;
            width: 30px;
            text-align: center;
            padding: 0;
        }
        
        .layer-z-input:focus {
            outline: 1px solid #007acc;
            outline-offset: -1px;
            border-radius: 2px;
        }
        
        .layer-drag-handle {
            color: #666666;
            font-size: 12px;
            cursor: grab;
            padding: 0 4px;
            user-select: none;
        }
        
        .layer-drag-handle:hover {
            color: #999999;
        }
        
        .layer-visibility-btn {
            background: none;
            border: none;
            color: #888888;
            font-size: 14px;
            cursor: pointer;
            padding: 2px;
            border-radius: 3px;
            transition: color 0.15s ease;
        }
        
        .layer-visibility-btn:hover {
            color: #ffffff;
        }
        
        .layer-visibility-btn.hidden {
            color: #ff6b6b;
        }
        
        .drop-indicator {
            height: 2px;
            background: #007acc;
            margin: 1px 0;
            opacity: 0;
            transition: opacity 0.2s ease;
            border-radius: 1px;
        }
        
        .drop-indicator.active {
            opacity: 1;
        }
        
        .preview-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid #404040;
            background: #f0f0f0;
        }
        
        .status-bar {
            position: absolute;
            bottom: 8px;
            left: 8px;
            font-size: 11px;
            color: #888888;
        }
        
        .bounding-box {
            position: absolute;
            border: 2px solid #007acc;
            background: rgba(0, 122, 204, 0.1);
            cursor: move;
            z-index: 1000;
            display: none;
            box-shadow: 0 0 12px rgba(0, 122, 204, 0.3);
            transition: all 0.1s ease;
        }
        
        .bounding-box.active {
            display: block;
        }
        
        .bounding-box:hover {
            background: rgba(0, 122, 204, 0.15);
            box-shadow: 0 0 16px rgba(0, 122, 204, 0.4);
        }
        
        .bounding-box-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #007acc;
            border: 2px solid #ffffff;
            border-radius: 2px;
            z-index: 1001;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0.9;
            /* 12px以上の当たり判定を確保 */
            min-width: 12px;
            min-height: 12px;
        }
        
        .bounding-box-handle:hover {
            background: #1a8cff;
            transform: scale(1.4);
            opacity: 1;
            box-shadow: 0 3px 8px rgba(0, 122, 204, 0.4);
        }
        
        /* 修飾キー状態表示 */
        .modifier-key-hint {
            position: absolute;
            bottom: -70px;
            left: 0;
            background: rgba(0, 0, 0, 0.85);
            color: #ffffff;
            padding: 6px 10px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            border-radius: 4px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1005;
        }
        
        .bounding-box:hover .modifier-key-hint,
        .bounding-box.resizing .modifier-key-hint {
            opacity: 1;
        }
        
        .bounding-box-handle:active {
            background: #0066cc;
            transform: scale(1.1);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        /* 8ハンドル配置 - Maya/AfterEffects style (当たり判定12px以上) */
        .handle-nw { top: -7px; left: -7px; cursor: nw-resize; }
        .handle-ne { top: -7px; right: -7px; cursor: ne-resize; }
        .handle-sw { bottom: -7px; left: -7px; cursor: sw-resize; }
        .handle-se { bottom: -7px; right: -7px; cursor: se-resize; }
        .handle-n { top: -7px; left: 50%; margin-left: -6px; cursor: n-resize; }
        .handle-s { bottom: -7px; left: 50%; margin-left: -6px; cursor: s-resize; }
        .handle-w { top: 50%; left: -7px; margin-top: -6px; cursor: w-resize; }
        .handle-e { top: 50%; right: -7px; margin-top: -6px; cursor: e-resize; }
        
        /* 回転ハンドル */
        .handle-rotate {
            top: -25px;
            left: 50%;
            margin-left: -6px;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill="%23007acc" d="M8 1a7 7 0 0 1 7 7h-2a5 5 0 1 0-5-5V1z"/><path fill="%23007acc" d="M6 0v4l2-2 2 2V0H6z"/></svg>') 8 8, auto;
            background: #ff6b6b;
        }
        
        .handle-rotate:hover {
            background: #ff5252;
            transform: scale(1.3) rotate(15deg);
        }
        
        /* アクティブ状態の視覚フィードバック */
        .bounding-box-handle.resizing {
            background: #ff6b6b;
            border-color: #ffffff;
            transform: scale(1.4);
        }
        
        /* 座標表示 */
        .bounding-box-info {
            position: absolute;
            bottom: -45px;
            left: 0;
            background: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            padding: 4px 8px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            border-radius: 3px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1004;
        }
        
        .bounding-box:hover .bounding-box-info,
        .bounding-box.resizing .bounding-box-info {
            opacity: 1;
        }
        
        .drag-handle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #007acc;
            border: 1px solid #ffffff;
            border-radius: 50%;
            cursor: move;
            z-index: 1000;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888888;
            font-size: 14px;
        }
        
        .error {
            color: #ff6b6b;
        }
        
        .success {
            color: #51cf66;
        }
        
        .saving {
            color: #ffd43b;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        /* トーストアニメーション */
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
    </style>
    
    <!-- Spine WebGL Runtime -->
    <script src="../assets/js/libs/spine-webgl.js" onerror="console.error('Failed to load Spine WebGL library')"></script>
    
    <script>
        // Spine WebGL 読み込み確認
        window.addEventListener('load', function() {
            if (typeof spine === 'undefined') {
                console.error('❌ Spine WebGL library not loaded');
            } else {
                console.log('✅ Spine WebGL library loaded successfully');
                console.log('Available spine objects:', Object.keys(spine));
            }
        });
    </script>
</head>
<body>
    <div class="app-container">
        <!-- ツールバー -->
        <div class="toolbar">
            <button id="btn-select-hp">HPフォルダ選択</button>
            <button id="btn-select-spine">Spineフォルダ選択</button>
            <button id="btn-real-spine-test" class="primary">🎯 実Spineテスト</button>
            <button id="btn-quick-save" class="primary">⚡ Quick Save (Ctrl+S)</button>
            <button id="btn-project-save">💾 Project Save (Ctrl+Shift+S)</button>
            <button id="btn-export">📦 Export</button>
            <span id="project-status">プロジェクト未選択</span>
        </div>
        
        <!-- アウトライナー -->
        <div class="outliner">
            <div class="panel-title">📁 アウトライナー</div>
            
            <!-- HPファイル一覧 -->
            <div class="property-group">
                <div class="property-label">📄 HP / .html ファイル</div>
                <div id="hp-file-list" class="file-tree">
                    <div class="loading">HPフォルダを選択してください</div>
                </div>
            </div>
            
            <!-- キャラクターアニメーション一覧 -->
            <div class="property-group">
                <div class="property-label">🎭 Characters / Animations</div>
                <div id="character-animation-tree" class="file-tree">
                    <div class="loading">Spineフォルダを選択してください</div>
                </div>
            </div>
        </div>
        
        <!-- プレビューエリア -->
        <div class="preview">
            <canvas id="preview-canvas" class="preview-canvas" width="640" height="360"></canvas>
            <div class="status-bar" id="status-bar">準備完了</div>
        </div>
        
        <!-- プロパティパネル -->
        <div class="properties">
            <!-- レイヤー管理セクション -->
            <div class="property-group">
                <div class="panel-title">📚 レイヤー管理</div>
                <div id="character-layers" class="character-layers">
                    <div class="loading">キャラクターを読み込んでください</div>
                </div>
                <div class="layer-controls">
                    <button class="layer-btn" id="btn-move-layer-up">↑ Up</button>
                    <button class="layer-btn" id="btn-move-layer-down">↓ Down</button>
                </div>
            </div>
            
            <div class="panel-title">🎛️ インスペクター</div>
            
            <!-- 選択オブジェクト情報 -->
            <div class="property-group">
                <div class="property-label">選択オブジェクト</div>
                <div class="selected-object-info" id="selected-object-info">
                    <div style="color: #888; font-size: 11px;">オブジェクトを選択してください</div>
                </div>
            </div>
            
            <!-- Transform -->
            <div class="property-group">
                <div class="property-label">🔄 Transform</div>
                <div class="property-row">
                    <label>X</label>
                    <input type="number" class="property-input" id="prop-x" value="0" step="0.1">
                    <label>Y</label>
                    <input type="number" class="property-input" id="prop-y" value="0" step="0.1">
                </div>
                <div class="property-row">
                    <label>W</label>
                    <input type="number" class="property-input" id="prop-width" value="100" step="1">
                    <label>H</label>
                    <input type="number" class="property-input" id="prop-height" value="100" step="1">
                </div>
                <div class="property-row">
                    <label>Rot</label>
                    <input type="number" class="property-input" id="prop-rotation" value="0" step="1">
                    <label style="margin-left: 20px;">°</label>
                </div>
                <div class="property-row">
                    <label>SX</label>
                    <input type="number" class="property-input" id="prop-scale-x" value="1.0" step="0.01">
                    <label>SY</label>
                    <input type="number" class="property-input" id="prop-scale-y" value="1.0" step="0.01">
                </div>
            </div>
            
            <!-- Canvas設定 -->
            <div class="property-group">
                <div class="property-label">🎨 Canvas</div>
                <div class="property-row">
                    <label>W</label>
                    <input type="number" class="property-input" id="canvas-width" value="640" step="1">
                    <label>H</label>
                    <input type="number" class="property-input" id="canvas-height" value="360" step="1">
                </div>
                <div class="property-row">
                    <label>BG</label>
                    <input type="color" class="property-input" id="canvas-bg-color" value="#1a1a1a" style="width: 40px; height: 24px; padding: 2px;">
                    <button class="layer-btn" id="btn-canvas-clear" style="margin-left: 8px;">Clear</button>
                </div>
                <div class="property-row">
                    <button class="layer-btn" id="btn-canvas-fit">Fit to View</button>
                    <button class="layer-btn" id="btn-canvas-reset">Reset</button>
                </div>
            </div>
            
            <!-- Animation -->
            <div class="property-group">
                <div class="property-label">🎬 Animation</div>
                <div class="property-row">
                    <select class="property-select" id="prop-animation" style="width: 100%;">
                        <option value="idle">idle</option>
                        <option value="walk">walk</option>
                        <option value="run">run</option>
                        <option value="jump">jump</option>
                        <option value="attack">attack</option>
                    </select>
                </div>
                <div class="property-row">
                    <label>Speed</label>
                    <input type="range" class="property-input" id="prop-anim-speed" value="1.0" min="0.1" max="3.0" step="0.1" style="width: 80px;">
                    <span id="speed-value" style="font-size: 10px; color: #888;">1.0x</span>
                </div>
                <div class="property-row">
                    <button class="layer-btn" id="btn-anim-play">▶ Play</button>
                    <button class="layer-btn" id="btn-anim-pause">⏸ Pause</button>
                    <button class="layer-btn" id="btn-anim-stop">⏹ Stop</button>
                </div>
            </div>
            
            <!-- Layer Order -->
            <div class="property-group">
                <div class="property-label">📚 Layer Order</div>
                <div class="property-row">
                    <label>Z</label>
                    <input type="number" class="property-input" id="prop-z-index" value="0" step="1">
                </div>
                <div class="layer-controls">
                    <button class="layer-btn" id="btn-bring-to-front">↑↑ Front</button>
                    <button class="layer-btn" id="btn-bring-forward">↑ Forward</button>
                </div>
                <div class="layer-controls">
                    <button class="layer-btn" id="btn-send-backward">↓ Backward</button>
                    <button class="layer-btn" id="btn-send-to-back">↓↓ Back</button>
                </div>
            </div>
            
            <!-- Visibility -->
            <div class="property-group">
                <div class="property-label">👁️ Visibility</div>
                <div class="property-row">
                    <label>Alpha</label>
                    <input type="range" class="property-input" id="prop-alpha" value="1.0" min="0" max="1" step="0.01" style="width: 80px;">
                    <span id="alpha-value" style="font-size: 10px; color: #888;">100%</span>
                </div>
                <div class="property-row">
                    <button class="layer-btn" id="btn-toggle-visibility">👁️ Show/Hide</button>
                    <button class="layer-btn" id="btn-lock-object">🔒 Lock</button>
                </div>
            </div>
        </div>

        <!-- タイムラインパネル -->
        <div class="timeline">
            <div class="timeline-header">
                <div class="panel-title">🎬 タイムライン</div>
                <div class="timeline-controls">
                    <button class="timeline-btn" id="btn-play-pause" title="再生/停止">▶</button>
                    <button class="timeline-btn" id="btn-stop" title="停止">⏹</button>
                    <button class="timeline-btn" id="btn-prev-frame" title="前フレーム">⏮</button>
                    <button class="timeline-btn" id="btn-next-frame" title="次フレーム">⏭</button>
                </div>
                <div class="timeline-time-display" id="timeline-time">00:00.00 / 00:05.00</div>
                <button class="timeline-btn" id="btn-loop" title="ループ再生">🔁</button>
            </div>
            
            <div class="timeline-scrubber" id="timeline-scrubber">
                <div class="timeline-ruler">
                    <!-- ルーラーマークは動的に生成 -->
                </div>
                <div class="timeline-track">
                    <!-- アニメーショントラック -->
                    <div class="timeline-keyframe" style="left: 10%;" title="キーフレーム 0s"></div>
                    <div class="timeline-keyframe" style="left: 30%;" title="キーフレーム 1.5s"></div>
                    <div class="timeline-keyframe" style="left: 60%;" title="キーフレーム 3.0s"></div>
                    <div class="timeline-keyframe" style="left: 90%;" title="キーフレーム 4.5s"></div>
                </div>
                <div class="timeline-playhead" id="timeline-playhead"></div>
            </div>
        </div>
    </div>

    <script>
        // 改善版プロジェクト管理
        class ImprovedProjectManager {
            constructor() {
                this.project = null;
                this.selectedCharacter = null;
                this.characters = new Map();
                this.availableAnimations = new Map(); // キャラクターごとのアニメーション一覧
                this.isDirty = false; // 未保存の変更があるか
                this.realSpineTestMode = false; // 実Spineテストモードフラグ
                this.useSpineCanvasMethod = false; // SpineCanvas使用フラグ
                this.debugMode = false; // 🎯 AABB精度デバッグモードフラグ
                this.init();
            }
            
            init() {
                this.bindEvents();
                this.updateStatus('プロトタイプ準備完了');
            }
            
            bindEvents() {
                // フォルダ選択（モック）
                document.getElementById('btn-select-hp').addEventListener('click', () => {
                    this.selectHPFolder();
                });
                
                document.getElementById('btn-select-spine').addEventListener('click', () => {
                    this.selectSpineFolder();
                });
                
                document.getElementById('btn-real-spine-test').addEventListener('click', () => {
                    this.runRealSpineTest();
                });
                
                // 2段階保存システム
                document.getElementById('btn-quick-save').addEventListener('click', () => {
                    this.quickSave();
                });
                
                document.getElementById('btn-project-save').addEventListener('click', () => {
                    this.projectSave();
                });
                
                document.getElementById('btn-export').addEventListener('click', () => {
                    this.exportProject();
                });
                
                // キーボードショートカット
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.shiftKey && e.key === 'S') {
                        // Ctrl+Shift+S: Project Save
                        e.preventDefault();
                        this.projectSave();
                    } else if (e.ctrlKey && e.key === 's') {
                        // Ctrl+S: Quick Save
                        e.preventDefault();
                        this.quickSave();
                    } else if (e.code === 'Space') {
                        // Space: Play/Pause
                        e.preventDefault();
                        this.togglePlayPause();
                    } else if (e.ctrlKey && e.key === 'd') {
                        // Ctrl+D: デバッグモード切り替え
                        e.preventDefault();
                        this.toggleDebugMode();
                    }
                });

                // タイムライン制御
                this.setupTimelineControls();
                
                // プロパティ変更
                ['prop-x', 'prop-y', 'prop-scale-x', 'prop-scale-y', 'prop-rotation', 'prop-z-index'].forEach(id => {
                    document.getElementById(id).addEventListener('input', (e) => {
                        this.updateCharacterProperty(id.replace('prop-', ''), e.target.value);
                        this.markDirty();
                    });
                });
                
                // アニメーション選択
                document.getElementById('prop-animation').addEventListener('change', (e) => {
                    this.updateCharacterAnimation(e.target.value);
                    this.markDirty();
                });
                
                // レイヤーコントロール
                document.getElementById('btn-bring-forward').addEventListener('click', () => {
                    this.bringForward();
                });
                
                document.getElementById('btn-send-backward').addEventListener('click', () => {
                    this.sendBackward();
                });
                
                // Z順管理ボタン
                document.getElementById('btn-move-layer-up').addEventListener('click', () => {
                    this.moveLayerUp();
                });
                
                document.getElementById('btn-move-layer-down').addEventListener('click', () => {
                    this.moveLayerDown();
                });
                
                // レイヤーリストのドラッグ&ドロップ初期化
                this.initializeLayerDragAndDrop();
                
                // キャンバスクリック
                document.getElementById('preview-canvas').addEventListener('click', (e) => {
                    this.handleCanvasClick(e);
                });
            }
            
            selectHPFolder() {
                // モック: HPフォルダ選択
                this.updateStatus('HPフォルダ: D:/example/homepage');
                this.updateFileTree([
                    { name: 'index.html', type: 'file' },
                    { name: 'assets', type: 'folder' },
                    { name: 'css', type: 'folder' }
                ]);
            }
            
            // 欠落していたupdateFileTreeメソッドを実装
            updateFileTree(files) {
                console.log('📁 ファイルツリー更新:', files);
                // 実装: 実際のファイルツリー表示は今後のフェーズで追加予定
                // 現在はコンソールログのみで動作確認
                if (files && files.length > 0) {
                    console.log('✅ ファイル一覧取得成功:', files.map(f => f.name));
                } else {
                    console.warn('⚠️ ファイル一覧が空です');
                }
            }
            
            selectSpineFolder() {
                // 実際のSpineフォルダ選択準備
                this.updateStatus('Spineフォルダ選択準備中...');
                this.initializeSpineSystem();
            }
            
            initializeSpineSystem() {
                // 実Spineシステム初期化
                console.log('🎯 実Spineシステム初期化開始');
                
                // プレビューキャンバスの準備
                this.setupSpineCanvas();
                
                // Spine WebGLライブラリの読み込み準備
                this.loadSpineLibrary();
            }
            
            setupSpineCanvas() {
                const preview = document.querySelector('.preview');
                
                // 既存のcanvasがあれば削除
                const existingCanvas = preview.querySelector('canvas');
                if (existingCanvas) {
                    existingCanvas.remove();
                }
                
                // Spine用WebGLキャンバス作成
                const canvas = document.createElement('canvas');
                canvas.id = 'spine-webgl-canvas';
                canvas.width = preview.clientWidth;
                canvas.height = preview.clientHeight;
                canvas.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: transparent;
                `;
                
                preview.appendChild(canvas);
                
                // WebGLコンテキスト初期化
                this.initializeWebGL(canvas);
                
                console.log('✅ Spine WebGLキャンバス準備完了');
            }
            
            // WebGL初期化とSpineレンダリングシステム
            initializeWebGL(canvas) {
                try {
                    // WebGLコンテキスト取得
                    this.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (!this.gl) {
                        throw new Error('WebGLがサポートされていません');
                    }
                    
                    console.log('✅ WebGLコンテキスト初期化完了');
                    
                    // Spine WebGLの初期化は loadSpineLibrary() 後に実行
                    this.webglCanvas = canvas;
                    
                } catch (error) {
                    console.error('❌ WebGL初期化エラー:', error);
                    this.updateStatus('WebGL初期化失敗: ' + error.message);
                }
            }
            
            // Spineレンダリングループ開始（エラーハンドリング強化）
            startSpineRenderLoop() {
                console.log('🎬 Spineレンダリングループ開始準備...');
                
                // WebGL/Spine環境チェック
                if (!this.gl) {
                    console.warn('⚠️ WebGLコンテキストが初期化されていません。2Dキャンバスにフォールバック');
                    this.startCanvasFallbackRenderLoop();
                    return;
                }
                
                if (!this.spineRenderer) {
                    console.warn('⚠️ Spineレンダラーが初期化されていません。基本WebGLのみで実行');
                }
                
                let frameCount = 0;
                const maxFPS = 60;
                const frameInterval = 1000 / maxFPS;
                let lastFrameTime = performance.now();
                
                const render = (currentTime) => {
                    try {
                        // FPS制限
                        const deltaTime = currentTime - lastFrameTime;
                        if (deltaTime < frameInterval) {
                            requestAnimationFrame(render);
                            return;
                        }
                        
                        lastFrameTime = currentTime;
                        frameCount++;
                        
                        // WebGLクリア処理
                        if (this.gl && this.gl.canvas) {
                            this.gl.clearColor(0, 0, 0, 0); // 透明背景
                            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
                        }
                        
                        // 各キャラクターをレンダリング
                        if (this.characters.size > 0) {
                            this.characters.forEach((character) => {
                                this.renderSpineCharacter(character);
                            });
                        }
                        
                        // フレーム統計（デバッグ用）
                        if (frameCount % 300 === 0) { // 5秒ごと（60fps x 5s = 300frames）
                            console.log(`🎬 レンダリング統計: ${frameCount}フレーム処理済み`);
                        }
                        
                    } catch (error) {
                        console.error('❌ レンダリングループエラー:', error);
                        
                        // エラー発生時は2Dフォールバックに切り替え
                        console.log('🔄 2Dキャンバスレンダリングにフォールバック');
                        this.startCanvasFallbackRenderLoop();
                        return;
                    }
                    
                    // 次フレーム
                    requestAnimationFrame(render);
                };
                
                requestAnimationFrame(render);
                console.log('✅ Spineレンダリングループ開始');
            }
            
            // 2Dキャンバスフォールバックレンダリング
            startCanvasFallbackRenderLoop() {
                console.log('🔄 2Dキャンバスフォールバックレンダリング開始');
                
                // 既存のWebGLキャンバスを非表示
                const webglCanvas = document.getElementById('spine-webgl-canvas');
                if (webglCanvas) {
                    webglCanvas.style.display = 'none';
                }
                
                // 2Dキャンバス作成
                const preview = document.querySelector('.preview');
                let canvas2d = document.getElementById('fallback-2d-canvas');
                
                if (!canvas2d) {
                    canvas2d = document.createElement('canvas');
                    canvas2d.id = 'fallback-2d-canvas';
                    canvas2d.width = preview.clientWidth;
                    canvas2d.height = preview.clientHeight;
                    canvas2d.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: transparent;
                    `;
                    preview.appendChild(canvas2d);
                }
                
                const ctx = canvas2d.getContext('2d');
                
                const render = () => {
                    try {
                        // キャンバスクリア
                        ctx.clearRect(0, 0, canvas2d.width, canvas2d.height);
                        
                        // グリッド描画
                        this.drawGrid(ctx, canvas2d);
                        
                        // キャラクター代替表示
                        this.characters.forEach(character => {
                            this.drawMockCharacter(character, ctx, canvas2d);
                        });
                        
                    } catch (error) {
                        console.error('❌ 2Dレンダリングエラー:', error);
                    }
                    
                    requestAnimationFrame(render);
                };
                
                requestAnimationFrame(render);
                console.log('✅ 2Dフォールバックレンダリング開始');
            }
            
            // 個別Spineキャラクターレンダリング
            renderSpineCharacter(character) {
                if (!character.skeleton || !character.animationState) return;
                
                try {
                    // アニメーション更新
                    character.animationState.update(0.016); // 60fps
                    character.animationState.apply(character.skeleton);
                    
                    // skeleton座標の適用（安全原則に従う）
                    character.skeleton.x = character.transform.x || 0;
                    character.skeleton.y = character.transform.y || 0;
                    character.skeleton.scaleX = character.transform.scaleX || 1.0;
                    character.skeleton.scaleY = character.transform.scaleY || 1.0;
                    
                    // ワールド変換更新
                    character.skeleton.updateWorldTransform();
                    
                    // Spineレンダラーで描画
                    if (this.spineRenderer) {
                        this.spineRenderer.draw(character.skeleton);
                    }
                    
                } catch (error) {
                    console.warn('⚠️ キャラクターレンダリングエラー:', character.id, error);
                }
            }
            
            loadSpineLibrary() {
                // Spine WebGLライブラリが読み込まれているか確認
                if (typeof spine !== 'undefined') {
                    console.log('✅ Spine WebGLライブラリ読み込み完了');
                    this.initializeSpineApp();
                } else {
                    console.error('❌ Spine WebGLライブラリが見つかりません');
                    this.updateStatus('Spine WebGLライブラリエラー');
                }
            }
            
            initializeSpineApp() {
                const canvas = document.getElementById('spine-webgl-canvas');
                
                try {
                    // Spine WebGLライブラリが正しく読み込まれているか詳細チェック
                    console.log('🔍 Spine WebGL構造確認:', {
                        spine: typeof spine,
                        spineWebgl: typeof spine?.webgl,
                        SpineCanvas: typeof spine?.SpineCanvas,
                        SceneRenderer: typeof spine?.webgl?.SceneRenderer
                    });
                    
                    // Spine WebGLアプリ初期化
                    if (typeof spine.SpineCanvas !== 'undefined') {
                        this.spineApp = new spine.SpineCanvas(canvas, {
                            pathPrefix: '../assets/spine/characters/',
                            alpha: true,
                            backgroundColor: '#00000000' // 透明背景
                        });
                        console.log('✅ Spine WebGLアプリ初期化完了');
                    } else {
                        console.warn('⚠️ spine.SpineCanvas が見つかりません。代替初期化を実行...');
                        // 代替: 基本WebGLコンテキストのみ使用
                        this.spineApp = { gl: this.gl, canvas: canvas };
                    }
                    
                    this.updateStatus('Spine WebGL初期化完了');
                    
                    // WebGLレンダラー初期化（修正版）
                    if (spine && spine.webgl) {
                        // SceneRenderer確認
                        if (spine.webgl.SceneRenderer) {
                            this.spineRenderer = new spine.webgl.SceneRenderer(this.gl, canvas);
                            console.log('✅ SceneRenderer初期化完了');
                        } else if (spine.webgl.SkeletonRenderer) {
                            // 代替: SkeletonRendererを使用
                            this.spineRenderer = new spine.webgl.SkeletonRenderer(this.gl);
                            console.log('✅ SkeletonRenderer（代替）初期化完了');
                        } else {
                            console.warn('⚠️ Spine WebGLレンダラーが見つかりません');
                            this.spineRenderer = null;
                        }
                    } else {
                        console.warn('⚠️ spine.webgl が見つかりません');
                        this.spineRenderer = null;
                    }
                    
                    // レンダリングループ開始
                    this.startSpineRenderLoop();
                    
                    // テスト用キャラクター読み込み
                    this.loadTestCharacters();
                    
                } catch (error) {
                    console.error('❌ Spine WebGLアプリ初期化エラー:', error);
                    console.error('❌ 詳細スタックトレース:', error.stack);
                    this.updateStatus('Spine初期化エラー: ' + error.message);
                    
                    // フォールバック: モックシステム開始
                    this.initializeMockSpineSystem();
                }
            }
            
            // Spine WebGL初期化失敗時のフォールバックシステム
            initializeMockSpineSystem() {
                console.log('🔄 Spine WebGL初期化失敗、モックシステムに切り替え');
                
                this.spineApp = null;
                this.spineRenderer = null;
                
                // 基本的なテストキャラクターを作成（モック）
                this.createMockCharacters();
                
                this.updateStatus('モックシステム初期化完了（デバッグモード）');
            }
            
            // モック用テストキャラクター作成
            createMockCharacters() {
                console.log('🎭 モックキャラクター作成開始...');
                
                try {
                    // nezumiモック
                    const nezumiMock = {
                        id: 'nezumi#mock',
                        name: 'nezumi',
                        skeleton: null,
                        animationState: null,
                        skeletonData: null,
                        transform: { x: -100, y: 0, scaleX: 0.8, scaleY: 0.8, rotation: 0 },
                        zIndex: 1,
                        animation: 'idle',
                        visible: true
                    };
                    
                    // purattokun モック
                    const purattokunMock = {
                        id: 'purattokun#mock',
                        name: 'purattokun', 
                        skeleton: null,
                        animationState: null,
                        skeletonData: null,
                        transform: { x: 100, y: 0, scaleX: 1.0, scaleY: 1.0, rotation: 0 },
                        zIndex: 2,
                        animation: 'idle',
                        visible: true
                    };
                    
                    // キャラクター管理に追加
                    this.characters.set(nezumiMock.id, nezumiMock);
                    this.characters.set(purattokunMock.id, purattokunMock);
                    
                    // モックアニメーション一覧
                    this.availableAnimations.set('nezumi', ['idle', 'walk', 'run']);
                    this.availableAnimations.set('purattokun', ['idle', 'taiki', 'walk']);
                    
                    // UI更新
                    this.updateCharacterLayers();
                    if (this.characters.size > 0) {
                        const firstCharacter = this.characters.values().next().value;
                        this.selectCharacter(firstCharacter.id);
                    }
                    
                    console.log('✅ モックキャラクター作成完了:', Array.from(this.characters.keys()));
                    
                } catch (error) {
                    console.error('❌ モックキャラクター作成エラー:', error);
                }
            }
            
            async loadTestCharacters() {
                console.log('🎭 テストキャラクター読み込み開始...');
                
                try {
                    // nezumi読み込み
                    await this.loadSpineCharacter('nezumi', {
                        x: -100, y: 0, scaleX: 0.8, scaleY: 0.8, zIndex: 1
                    });
                    
                    // purattokun読み込み
                    await this.loadSpineCharacter('purattokun', {
                        x: 100, y: 0, scaleX: 1.0, scaleY: 1.0, zIndex: 2
                    });
                    
                    console.log('✅ テストキャラクター読み込み完了');
                    this.updateStatus('キャラクター読み込み完了');
                    
                    // UI更新
                    this.updateCharacterLayers();
                    if (this.characters.size > 0) {
                        const firstCharacter = this.characters.values().next().value;
                        this.selectCharacter(firstCharacter.id);
                    }
                    
                } catch (error) {
                    console.error('❌ キャラクター読み込みエラー:', error);
                    this.updateStatus('キャラクター読み込みエラー: ' + error.message);
                }
            }
            
            // 🎯 実Spineデータテスト実行メソッド
            async runRealSpineTest() {
                console.log('🚀 実Spine最小スモークテスト開始');
                this.updateStatus('実Spineテスト実行中...', 'info');
                
                try {
                    // テストモード有効化
                    this.realSpineTestMode = true;
                    this.useSpineCanvasMethod = false; // 手動読み込みでテスト
                    
                    // キャラクターデータクリア
                    this.characters.clear();
                    this.clearPreview();
                    
                    // nezumi1体のみテスト読み込み
                    console.log('🐭 nezumi 1体テスト読み込み開始');
                    await this.loadSpineCharacter('nezumi', {
                        x: 0, y: 0, scaleX: 1.0, scaleY: 1.0, zIndex: 1
                    });
                    
                    // レンダリング開始
                    this.render();
                    
                    console.log('✅ 実Spineテスト完了');
                    this.updateStatus('実Spineテスト成功 ✅', 'success');
                    
                } catch (error) {
                    console.error('❌ 実Spineテストエラー:', error);
                    this.updateStatus(`実Spineテストエラー: ${error.message}`, 'error');
                    
                    // フォールバック: モックシステムに戻る
                    this.realSpineTestMode = false;
                    this.createMockCharacters();
                }
            }
            
            async loadSpineCharacter(characterName, transform) {
                console.log(`🎯 ${characterName} 読み込み開始...`);
                
                try {
                    // 実際のSpineファイルパス構成
                    const basePath = '../assets/spine/characters/';
                    const jsonPath = `${basePath}${characterName}/${characterName}.json`;
                    const atlasPath = `${basePath}${characterName}/${characterName}.atlas`;
                    
                    console.log(`📁 Spineファイルパス: ${jsonPath}`);
                    
                    // 実Spineテスト時のみ実際のデータ読み込みを実行
                    if (!this.realSpineTestMode) {
                        console.log('🛡️ 通常モード: モックシステム使用');
                        throw new Error('通常モードではモックシステム使用');
                    }
                    
                    console.log('🎯 実Spineテストモード: 実データ読み込み開始');
                    
                    // 実データ読み込みを実行
                    let skeletonData;
                    if (this.useSpineCanvasMethod) {
                        // SpineCanvasを使った読み込み
                        skeletonData = await this.spineApp.loadSkeleton(characterName, jsonPath);
                    } else {
                        // 手動でSpineデータを読み込み（現在問題あり）
                        const response = await fetch(jsonPath);
                        const jsonData = await response.json();
                        
                        const atlasResponse = await fetch(atlasPath);
                        const atlasText = await atlasResponse.text();
                        
                        // Spine WebGLでスケルトンデータ作成（修正版）
                        const atlas = new spine.TextureAtlas(atlasText, (path) => {
                            console.log(`🖼️ テクスチャファイル要求: ${path}`);
                            
                            const img = new Image();
                            img.crossOrigin = 'anonymous';
                            const fullPath = `${basePath}${characterName}/${path}`;
                            img.src = fullPath;
                            
                            console.log(`📁 フルパス: ${fullPath}`);
                            
                            // 🛡️ 同期的なテクスチャ作成（getImage回避）
                            if (spine.webgl && spine.webgl.GLTexture) {
                                try {
                                    const texture = new spine.webgl.GLTexture(this.gl, img);
                                    console.log(`✅ テクスチャ作成成功: ${path}`);
                                    return texture;
                                } catch (error) {
                                    console.error(`❌ テクスチャ作成失敗: ${path}`, error);
                                    throw error;
                                }
                            } else {
                                console.error('❌ spine.webgl.GLTexture が利用できません');
                                throw new Error('GLTexture unavailable');
                            }
                        });
                        
                        // Atlas読み込み完了を待つ
                        await this.waitForAtlasLoad(atlas);
                        
                        const atlasLoader = new spine.AtlasAttachmentLoader(atlas);
                        const skeletonJson = new spine.SkeletonJson(atlasLoader);
                        skeletonData = skeletonJson.readSkeletonData(jsonData);
                    }
                    
                    if (!skeletonData) {
                        throw new Error(`スケルトンデータ読み込み失敗: ${characterName}`);
                    }
                    
                    // キャラクターオブジェクト作成
                    const skeleton = new spine.Skeleton(skeletonData);
                    const animationState = new spine.AnimationState(
                        new spine.AnimationStateData(skeletonData)
                    );
                    
                    // 🚨 安全原則適用: skeleton座標は最小限に
                    skeleton.x = transform.x || 0;
                    skeleton.y = transform.y || 0;
                    skeleton.scaleX = transform.scaleX || 1.0;
                    skeleton.scaleY = transform.scaleY || 1.0;
                    
                    // デフォルトアニメーション設定
                    const animations = skeletonData.animations;
                    if (animations.length > 0) {
                        // 待機アニメーションを探す（taiki、idle等）
                        let defaultAnim = animations.find(anim => 
                            anim.name === 'taiki' || anim.name === 'idle' || anim.name === 'waiting'
                        ) || animations[0];
                        
                        animationState.setAnimation(0, defaultAnim.name, true);
                        console.log(`🎬 ${characterName} デフォルトアニメーション設定: ${defaultAnim.name}`);
                    }
                    
                    // キャラクターデータ作成
                    const characterId = `${characterName}#${Date.now()}`;
                    const characterData = {
                        id: characterId,
                        name: characterName,
                        skeleton: skeleton,
                        animationState: animationState,
                        skeletonData: skeletonData,
                        transform: {
                            x: transform.x || 0,
                            y: transform.y || 0,
                            scaleX: transform.scaleX || 1.0,
                            scaleY: transform.scaleY || 1.0,
                            rotation: 0
                        },
                        zIndex: transform.zIndex || 0,
                        animation: animations.length > 0 ? animations[0].name : 'none'
                    };
                    
                    // キャラクター管理に追加
                    this.characters.set(characterId, characterData);
                    
                    // アニメーション一覧を設定
                    const animationNames = animations.map(anim => anim.name);
                    this.availableAnimations.set(characterName, animationNames);
                    
                    console.log(`✅ ${characterName} 読み込み完了:`, {
                        animations: animationNames,
                        transform: characterData.transform
                    });
                    
                    return characterData;
                    
                } catch (error) {
                    console.error(`❌ ${characterName} 読み込み失敗:`, error);
                    
                    // 🛡️ v3.0安全設計: すべてのSpine読み込み失敗をモックに切り替え
                    console.log('🔄 Spine読み込み問題を検出、モックキャラクターに切り替え');
                    return this.createMockCharacterFallback(characterName, transform);
                }
            }
            
            // Atlas読み込み完了を待つヘルパーメソッド
            async waitForAtlasLoad(atlas) {
                console.log('🔄 Atlas読み込み完了を待機中...');
                
                try {
                    // Atlasのすべてのページ（テクスチャ）が読み込まれるまで待つ
                    const pages = atlas.pages;
                    if (!pages || pages.length === 0) {
                        console.warn('⚠️ Atlas にページが見つかりません');
                        return;
                    }
                    
                    const loadPromises = [];
                    
                    // 各ページ（テクスチャ）の読み込み完了を待つ
                    pages.forEach((page, index) => {
                        if (page && page.texture) {
                            const promise = new Promise((resolve) => {
                                // 🛡️ getImage問題回避: テクスチャオブジェクト存在チェックのみ
                                if (page.texture) {
                                    console.log(`✅ Atlas ページ ${index} テクスチャ確認済み`);
                                    resolve();
                                    return;
                                }
                                
                                // フォールバック: 短時間待機後に完了とみなす
                                setTimeout(() => {
                                    console.log(`🔄 Atlas ページ ${index} 待機完了`);
                                    resolve();
                                }, 50);
                            });
                            
                            loadPromises.push(promise);
                        }
                    });
                    
                    // すべてのページの読み込み完了を待つ
                    await Promise.all(loadPromises);
                    console.log('✅ Atlas の全テクスチャ読み込み完了');
                    
                } catch (error) {
                    console.error('❌ Atlas 読み込み待機エラー:', error);
                    throw error;
                }
            }
            
            // Atlas読み込み失敗時のモックキャラクターフォールバック
            createMockCharacterFallback(characterName, transform) {
                console.log(`🔄 ${characterName} のモックキャラクターフォールバック作成中...`);
                
                const characterId = `${characterName}#mock#${Date.now()}`;
                const mockCharacterData = {
                    id: characterId,
                    name: characterName + ' (Mock)',
                    skeleton: null,
                    animationState: null,
                    skeletonData: null,
                    transform: {
                        x: transform.x || 0,
                        y: transform.y || 0,
                        scaleX: transform.scaleX || 1.0,
                        scaleY: transform.scaleY || 1.0,
                        rotation: 0
                    },
                    zIndex: transform.zIndex || 0,
                    animation: 'idle (mock)',
                    visible: true
                };
                
                // キャラクター管理に追加
                this.characters.set(characterId, mockCharacterData);
                
                // モックアニメーション一覧を設定
                this.availableAnimations.set(characterName, ['idle', 'walk', 'run']);
                
                console.log(`✅ ${characterName} モックキャラクター作成完了:`, mockCharacterData);
                
                return mockCharacterData;
            }
            
            // Spineキャラクターレンダリングシステム
            renderSpineCharacters() {
                if (!this.spineApp) return;
                
                try {
                    // キャンバスクリア
                    this.spineApp.clear();
                    
                    // Z順でソートしてレンダリング
                    const sortedCharacters = Array.from(this.characters.values())
                        .sort((a, b) => a.zIndex - b.zIndex);
                    
                    sortedCharacters.forEach(character => {
                        if (character.skeleton && character.animationState) {
                            // アニメーション更新
                            character.animationState.update(this.spineApp.lastFrameTime);
                            character.animationState.apply(character.skeleton);
                            character.skeleton.updateWorldTransform();
                            
                            // レンダリング
                            this.spineApp.renderer.draw(character.skeleton);
                        }
                    });
                    
                } catch (error) {
                    console.error('❌ Spineレンダリングエラー:', error);
                }
            }
            
            // レンダリングループ開始
            startRenderLoop() {
                const render = () => {
                    this.renderSpineCharacters();
                    requestAnimationFrame(render);
                };
                requestAnimationFrame(render);
                console.log('✅ Spineレンダリングループ開始');
            }
            
            drawMockCharacter(character, ctx, canvas) {
                if (!ctx || !canvas || !character) {
                    console.warn('⚠️ drawMockCharacter: 必要なパラメータが不足しています');
                    return;
                }
                
                // 非表示の場合はスキップ
                if (character.visible === false) {
                    return;
                }
                
                try {
                    // キャラクター代替表示（矩形）
                    const { x, y, scaleX, scaleY, rotation } = character.transform;
                    
                    // キャンバス中心基準の座標変換
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const screenX = centerX + x;
                    const screenY = centerY + y;
                    
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate((rotation || 0) * Math.PI / 180);
                    ctx.scale(scaleX || 1, scaleY || 1);
                    
                    // キャラクタータイプに応じた色分け
                    const characterType = character.name.includes('nezumi') ? 'nezumi' : 'purattokun';
                    const colors = {
                        nezumi: {
                            fill: '#ff6b6b40',
                            stroke: '#ff6b6b',
                            text: '#ff6b6b'
                        },
                        purattokun: {
                            fill: '#007acc40',
                            stroke: '#007acc',
                            text: '#007acc'
                        }
                    };
                    
                    const color = colors[characterType] || colors.purattokun;
                    
                    // キャラクター代替矩形
                    ctx.fillStyle = color.fill;
                    ctx.strokeStyle = color.stroke;
                    ctx.lineWidth = 2;
                    ctx.fillRect(-30, -40, 60, 80);
                    ctx.strokeRect(-30, -40, 60, 80);
                    
                    // キャラクターアイコン（大きめ）
                    ctx.fillStyle = color.text;
                    ctx.font = 'bold 20px sans-serif';
                    ctx.textAlign = 'center';
                    const icon = characterType === 'nezumi' ? '🐭' : '🐱';
                    ctx.fillText(icon, 0, -10);
                    
                    // 名前表示
                    ctx.fillStyle = color.text;
                    ctx.font = '11px sans-serif';
                    ctx.fillText(character.name, 0, 50);
                    
                    // アニメーション表示
                    ctx.fillStyle = '#40c057';
                    ctx.font = '9px sans-serif';
                    ctx.fillText(character.animation || 'idle', 0, 63);
                    
                    // Z-index表示
                    ctx.fillStyle = '#888888';
                    ctx.font = '8px sans-serif';
                    ctx.fillText(`Z:${character.zIndex}`, 0, -50);
                    
                    ctx.restore();
                    
                    // 選択中の場合は枠線を強調
                    if (this.selectedCharacter === character.id) {
                        ctx.strokeStyle = '#ffd700';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([5, 3]);
                        ctx.strokeRect(screenX - 33, screenY - 43, 66, 86);
                        ctx.setLineDash([]); // 破線をリセット
                    }
                    
                } catch (error) {
                    console.error('❌ drawMockCharacterエラー:', error, 'character:', character.id);
                }
            }
            
            drawGrid(ctx, canvas) {
                ctx.strokeStyle = '#404040';
                ctx.lineWidth = 1;
                
                // 縦線
                for (let x = 0; x <= canvas.width; x += 20) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                // 横線
                for (let y = 0; y <= canvas.height; y += 20) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                // 中央線
                ctx.strokeStyle = '#007acc';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(canvas.width/2, 0);
                ctx.lineTo(canvas.width/2, canvas.height);
                ctx.moveTo(0, canvas.height/2);
                ctx.lineTo(canvas.width, canvas.height/2);
                ctx.stroke();
            }
            
            drawDragHandle(x, y) {
                const handle = document.createElement('div');
                handle.className = 'drag-handle';
                handle.style.left = `${x - 4}px`;
                handle.style.top = `${y - 4}px`;
                
                const preview = document.querySelector('.preview');
                // 既存のハンドルを削除
                preview.querySelectorAll('.drag-handle').forEach(h => h.remove());
                preview.appendChild(handle);
                
                this.makeDraggable(handle);
            }
            
            makeDraggable(handle) {
                let isDragging = false;
                let startX, startY;
                
                handle.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startX = e.clientX - handle.offsetLeft;
                    startY = e.clientY - handle.offsetTop;
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const x = e.clientX - startX;
                    const y = e.clientY - startY;
                    
                    handle.style.left = `${x}px`;
                    handle.style.top = `${y}px`;
                    
                    // キャラクター位置更新
                    if (this.selectedCharacter) {
                        const character = this.characters.get(this.selectedCharacter);
                        character.transform.x = x + 4;
                        character.transform.y = y + 4;
                        this.updatePropertiesPanel(character);
                        this.drawMockCharacter(character);
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }
            
            selectCharacter(characterId) {
                this.selectedCharacter = characterId;
                const character = this.characters.get(characterId);
                if (character) {
                    this.updatePropertiesPanel(character);
                }
                
                // アウトライナーでハイライト
                document.querySelectorAll('.file-item').forEach(item => {
                    item.classList.remove('selected');
                });
                const item = document.querySelector(`[data-id="${characterId}"]`);
                if (item) {
                    item.classList.add('selected');
                }
            }
            
            updatePropertiesPanel(character) {
                const { x, y, scaleX, scaleY, rotation } = character.transform;
                document.getElementById('prop-x').value = Math.round(x);
                document.getElementById('prop-y').value = Math.round(y);
                document.getElementById('prop-scale-x').value = scaleX;
                document.getElementById('prop-scale-y').value = scaleY;
                document.getElementById('prop-rotation').value = rotation;
                document.getElementById('prop-z-index').value = character.zIndex;
                
                // アニメーション選択を更新
                const animationSelect = document.getElementById('prop-animation');
                const availableAnims = this.availableAnimations.get(character.name) || ['idle'];
                
                // オプションを動的更新
                animationSelect.innerHTML = '';
                availableAnims.forEach(anim => {
                    const option = document.createElement('option');
                    option.value = anim;
                    option.textContent = anim;
                    option.selected = anim === character.animation;
                    animationSelect.appendChild(option);
                });
            }
            
            // Z順管理メソッド
            moveLayerUp() {
                if (!this.selectedCharacter) {
                    this.showToast('キャラクターを選択してください', 'warning');
                    return;
                }
                
                const character = this.characters.get(this.selectedCharacter);
                if (character) {
                    character.zIndex += 1;
                    this.updateCharacterLayers();
                    this.redrawAllCharacters();
                    this.markDirty();
                    this.showToast(`${character.name} を前面に移動しました`, 'success');
                }
            }
            
            moveLayerDown() {
                if (!this.selectedCharacter) {
                    this.showToast('キャラクターを選択してください', 'warning');
                    return;
                }
                
                const character = this.characters.get(this.selectedCharacter);
                if (character) {
                    character.zIndex -= 1;
                    this.updateCharacterLayers();
                    this.redrawAllCharacters();
                    this.markDirty();
                    this.showToast(`${character.name} を背面に移動しました`, 'success');
                }
            }
            
            // レイヤーリストのドラッグ&ドロップ初期化
            initializeLayerDragAndDrop() {
                console.log('📦 レイヤードラッグ&ドロップ機能を初期化中...');
                
                // ドラッグ状態管理
                this.dragState = {
                    isDragging: false,
                    draggedElement: null,
                    placeholder: null,
                    dragOffset: { x: 0, y: 0 }
                };
                
                // イベントリスナーを追加
                document.addEventListener('mousemove', (e) => this.handleLayerDragMove(e));
                document.addEventListener('mouseup', (e) => this.handleLayerDragEnd(e));
                
                console.log('✅ レイヤードラッグ&ドロップ機能初期化完了');
            }
            
            // レイヤーアイテムにドラッグイベントを追加
            attachDragEventsToLayerItem(layerItem, characterId) {
                const dragHandle = layerItem.querySelector('.layer-drag-handle');
                if (!dragHandle) return;
                
                layerItem.draggable = true;
                
                layerItem.addEventListener('dragstart', (e) => {
                    this.dragState.isDragging = true;
                    this.dragState.draggedElement = layerItem;
                    layerItem.classList.add('dragging');
                    
                    // ドラッグデータ設定
                    e.dataTransfer.setData('text/plain', characterId);
                    e.dataTransfer.effectAllowed = 'move';
                    
                    // 視覚的フィードバック
                    this.showToast(`${this.characters.get(characterId)?.name || 'キャラクター'} をドラッグ中...`, 'info');
                });
                
                layerItem.addEventListener('dragend', (e) => {
                    layerItem.classList.remove('dragging');
                    this.dragState.isDragging = false;
                    this.dragState.draggedElement = null;
                    
                    // ドロップインディケーターを清理
                    document.querySelectorAll('.drop-indicator').forEach(indicator => {
                        indicator.classList.remove('active');
                    });
                });
                
                layerItem.addEventListener('dragover', (e) => {
                    if (this.dragState.isDragging && layerItem !== this.dragState.draggedElement) {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        
                        // ドロップインディケーターを表示
                        this.showDropIndicator(layerItem, e);
                    }
                });
                
                layerItem.addEventListener('drop', (e) => {
                    if (this.dragState.isDragging && layerItem !== this.dragState.draggedElement) {
                        e.preventDefault();
                        
                        const draggedCharacterId = e.dataTransfer.getData('text/plain');
                        const dropTargetCharacterId = characterId;
                        
                        this.reorderLayers(draggedCharacterId, dropTargetCharacterId);
                        this.showToast('Z順を変更しました', 'success');
                    }
                });
            }
            
            // ドロップインディケーター表示
            showDropIndicator(targetElement, event) {
                // 既存のインディケーターを非表示
                document.querySelectorAll('.drop-indicator').forEach(indicator => {
                    indicator.classList.remove('active');
                });
                
                // マウス位置に応じて上下どちらにドロップするか判定
                const rect = targetElement.getBoundingClientRect();
                const mouseY = event.clientY;
                const elementMiddle = rect.top + rect.height / 2;
                
                const isDropAbove = mouseY < elementMiddle;
                const indicator = isDropAbove ? 
                    targetElement.previousElementSibling?.querySelector?.('.drop-indicator') :
                    targetElement.nextElementSibling?.querySelector?.('.drop-indicator');
                
                if (indicator) {
                    indicator.classList.add('active');
                }
            }
            
            // レイヤー順序を変更
            reorderLayers(draggedCharacterId, dropTargetCharacterId) {
                const draggedCharacter = this.characters.get(draggedCharacterId);
                const targetCharacter = this.characters.get(dropTargetCharacterId);
                
                if (!draggedCharacter || !targetCharacter || draggedCharacter === targetCharacter) {
                    return;
                }
                
                // Z-indexを交換
                const tempZIndex = draggedCharacter.zIndex;
                draggedCharacter.zIndex = targetCharacter.zIndex;
                targetCharacter.zIndex = tempZIndex;
                
                // UI更新
                this.updateCharacterLayers();
                this.redrawAllCharacters();
                this.markDirty();
                
                console.log(`🔄 Z順変更: ${draggedCharacter.name} (${draggedCharacter.zIndex}) ↔ ${targetCharacter.name} (${targetCharacter.zIndex})`);
            }
            
            // 全キャラクターを再描画
            redrawAllCharacters() {
                try {
                    // キャンバス確認
                    let canvas = document.getElementById('preview-canvas');
                    if (!canvas) {
                        canvas = document.getElementById('fallback-2d-canvas');
                    }
                    
                    if (!canvas) {
                        console.warn('⚠️ 描画用キャンバスが見つかりません');
                        return;
                    }
                    
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        console.warn('⚠️ 2Dコンテキストを取得できません');
                        return;
                    }
                    
                    // Z順でソートして描画
                    const sortedCharacters = Array.from(this.characters.values())
                        .sort((a, b) => a.zIndex - b.zIndex);
                    
                    // キャンバスクリア
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // グリッド描画
                    this.drawGrid(ctx, canvas);
                    
                    // 各キャラクターを順番に描画
                    sortedCharacters.forEach(character => {
                        this.drawMockCharacter(character, ctx, canvas);
                    });
                    
                    // 選択中キャラクターのバウンディングボックスを最後に描画
                    if (this.selectedCharacter) {
                        const selected = this.characters.get(this.selectedCharacter);
                        if (selected) {
                            this.drawBoundingBox(selected);
                        }
                    }
                    
                } catch (error) {
                    console.error('❌ redrawAllCharactersエラー:', error);
                }
            }
            
            // 🛡️ 安全なバウンディングボックス描画（実Spine対応）
            drawBoundingBox(character) {
                const preview = document.querySelector('.preview');
                
                // 既存のバウンディングボックスを削除
                preview.querySelectorAll('.bounding-box').forEach(box => box.remove());
                
                if (!character.skeleton) {
                    console.warn('⚠️ skeleton情報がありません:', character.id);
                    return;
                }
                
                // 🚨 重要: Spineのskeleton座標から位置を取得（安全原則）
                const skeleton = character.skeleton;
                const spineX = skeleton.x;
                const spineY = skeleton.y;
                const spineScaleX = skeleton.scaleX;
                const spineScaleY = skeleton.scaleY;
                
                // バウンディングボックス作成
                const boundingBox = document.createElement('div');
                boundingBox.className = 'bounding-box active';
                boundingBox.dataset.characterId = character.id;
                
                // Spineキャラクターの実際のバウンディングを計算
                const bounds = this.calculateSpineBounds(skeleton);
                
                // プレビューエリア基準の座標変換（安全原則適用）
                const previewRect = preview.getBoundingClientRect();
                const canvas = document.getElementById('spine-webgl-canvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                // Canvas中心基準からプレビュー左上基準に変換
                const centerX = (canvasRect.left - previewRect.left) + (canvasRect.width / 2);
                const centerY = (canvasRect.top - previewRect.top) + (canvasRect.height / 2);
                
                // 🚨 安全原則: 複雑座標変換を避け、直接計算
                const boxLeft = centerX + spineX + bounds.x;
                const boxTop = centerY - spineY + bounds.y; // Spine座標系はY軸が上向き
                const boxWidth = bounds.width * Math.abs(spineScaleX);
                const boxHeight = bounds.height * Math.abs(spineScaleY);
                
                boundingBox.style.left = `${boxLeft}px`;
                boundingBox.style.top = `${boxTop}px`;
                boundingBox.style.width = `${boxWidth}px`;
                boundingBox.style.height = `${boxHeight}px`;
                
                // キャラクター名ラベル追加
                const label = document.createElement('div');
                label.className = 'bounding-box-label';
                label.textContent = `📝 ${character.name}`;
                label.style.cssText = `
                    position: absolute;
                    top: -28px;
                    left: 0;
                    background: #667eea;
                    color: white;
                    padding: 4px 10px;
                    font-size: 12px;
                    font-weight: bold;
                    border-radius: 4px;
                    white-space: nowrap;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                `;
                boundingBox.appendChild(label);
                
                // リアルタイム座標・サイズ表示
                const infoDisplay = document.createElement('div');
                infoDisplay.className = 'bounding-box-info';
                infoDisplay.innerHTML = this.getBoundingBoxInfoText(character);
                boundingBox.appendChild(infoDisplay);
                
                // 8つのリサイズハンドル追加 (Maya/AfterEffects順序)
                const handles = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
                handles.forEach(position => {
                    const handle = document.createElement('div');
                    handle.className = `bounding-box-handle handle-${position}`;
                    handle.dataset.position = position;
                    boundingBox.appendChild(handle);
                });
                
                // 回転ハンドル追加
                const rotateHandle = document.createElement('div');
                rotateHandle.className = 'bounding-box-handle handle-rotate';
                rotateHandle.dataset.position = 'rotate';
                rotateHandle.title = 'ドラッグで回転、またはRキー + ドラッグ';
                boundingBox.appendChild(rotateHandle);
                
                // 修飾キーヒント追加
                const modifierHint = document.createElement('div');
                modifierHint.className = 'modifier-key-hint';
                modifierHint.innerHTML = `
                    <div>Shift: 縦横比保持 | Alt: 中心固定 | R+Drag: 回転</div>
                `;
                boundingBox.appendChild(modifierHint);
                
                preview.appendChild(boundingBox);
                
                // Maya/AfterEffects style バウンディングボックス操作システム
                this.setupAdvancedBoundingBoxInteraction(boundingBox, character);
                
                console.log(`✅ ${character.name} バウンディングボックス表示:`, {
                    spinePos: { x: spineX, y: spineY },
                    boxPos: { left: boxLeft, top: boxTop },
                    bounds: bounds
                });
            }
            
            // Spineキャラクターのバウンディング計算
            calculateSpineBounds(skeleton) {
                try {
                    // Spineの実際のバウンディングボックスを取得
                    skeleton.updateWorldTransform();
                    skeleton.getBounds();
                    
                    // デフォルトサイズ（Spineバウンディングが取得できない場合）
                    const defaultBounds = {
                        x: -50,     // 中心から左に50px
                        y: -60,     // 中心から上に60px
                        width: 100, // 幅100px
                        height: 120 // 高さ120px
                    };
                    
                    // 実際のバウンディングが利用可能な場合はそれを使用
                    if (skeleton.minX !== undefined && skeleton.maxX !== undefined) {
                        return {
                            x: skeleton.minX,
                            y: skeleton.minY,
                            width: skeleton.maxX - skeleton.minX,
                            height: skeleton.maxY - skeleton.minY
                        };
                    }
                    
                    return defaultBounds;
                    
                } catch (error) {
                    console.warn('⚠️ Spineバウンディング計算エラー:', error);
                    // エラー時はデフォルト値を返す
                    return {
                        x: -50,
                        y: -60,
                        width: 100,
                        height: 120
                    };
                }
            }
            
            // バウンディングボックス情報テキスト生成
            getBoundingBoxInfoText(character) {
                const { x, y, scaleX, scaleY, rotation } = character.transform;
                const width = Math.abs(100 * scaleX);
                const height = Math.abs(120 * scaleY);
                
                return `X: ${x.toFixed(1)} Y: ${y.toFixed(1)} | W: ${width.toFixed(0)} H: ${height.toFixed(0)} | S: ${scaleX.toFixed(2)} ${scaleY.toFixed(2)} | R: ${rotation.toFixed(1)}°`;
            }
            
            // Maya/AfterEffects style 高度なバウンディングボックス操作システム
            setupAdvancedBoundingBoxInteraction(boundingBox, character) {
                console.log('🎯 Maya/AfterEffects style バウンディングボックス操作設定:', character.id);
                
                // 操作状態管理
                let activeOperation = null; // 'move' | 'resize' | 'rotate' | null
                let resizeHandle = null;    // どのハンドルでリサイズ中か
                let startMouse = { x: 0, y: 0 };
                let startTransform = null;
                let startBounds = null;
                let startRotation = 0;
                let isShiftPressed = false;
                let isCtrlPressed = false;
                let isAltPressed = false;
                let isRPressed = false; // Rキー回転モード
                
                // キー状態監視
                const updateModifierKeys = (e) => {
                    isShiftPressed = e.shiftKey; // 縦横比保持
                    isCtrlPressed = e.ctrlKey;   // 中心固定（未実装）
                    isAltPressed = e.altKey;     // 中心固定（代替）
                    isRPressed = e.key === 'r' || e.key === 'R'; // Rキー回転モード
                    
                    // 修飾キーヒント更新
                    updateModifierHint();
                };
                
                const updateModifierHint = () => {
                    const hint = boundingBox.querySelector('.modifier-key-hint');
                    if (hint) {
                        const status = [];
                        if (isShiftPressed) status.push('Shift: ON (縦横比保持)');
                        if (isAltPressed) status.push('Alt: ON (中心固定)');
                        if (isRPressed) status.push('R: ON (回転モード)');
                        if (status.length === 0) {
                            status.push('Shift: 縦横比保持 | Alt: 中心固定 | R+Drag: 回転');
                        }
                        hint.innerHTML = status.join(' | ');
                    }
                };
                
                // グローバルキーイベント
                document.addEventListener('keydown', updateModifierKeys);
                document.addEventListener('keyup', updateModifierKeys);
                
                // 中央エリアでのドラッグ移動
                boundingBox.addEventListener('mousedown', (e) => {
                    // ハンドルをクリックした場合は除外
                    if (e.target.classList.contains('bounding-box-handle')) return;
                    
                    activeOperation = 'move';
                    startMouse = { x: e.clientX, y: e.clientY };
                    startTransform = { ...character.transform };
                    
                    boundingBox.style.cursor = 'grabbing';
                    boundingBox.classList.add('resizing');
                    updateModifierKeys(e);
                    
                    e.preventDefault();
                    console.log('🎯 移動操作開始:', character.id);
                });
                
                // 8つのハンドル + 回転ハンドル操作
                boundingBox.querySelectorAll('.bounding-box-handle').forEach(handle => {
                    handle.addEventListener('mousedown', (e) => {
                        const position = handle.dataset.position;
                        
                        if (position === 'rotate') {
                            // 回転操作
                            activeOperation = 'rotate';
                            startMouse = { x: e.clientX, y: e.clientY };
                            startTransform = { ...character.transform };
                            startRotation = character.transform.rotation || 0;
                            
                            // 回転中心点を計算
                            const rect = boundingBox.getBoundingClientRect();
                            this.rotationCenter = {
                                x: rect.left + rect.width / 2,
                                y: rect.top + rect.height / 2
                            };
                            
                            console.log('🌀 回転操作開始:', character.id);
                        } else {
                            // リサイズ操作
                            activeOperation = 'resize';
                            resizeHandle = position;
                            startMouse = { x: e.clientX, y: e.clientY };
                            startTransform = { ...character.transform };
                            startBounds = boundingBox.getBoundingClientRect();
                            
                            console.log('🎯 リサイズ操作開始:', character.id, resizeHandle);
                        }
                        
                        handle.classList.add('resizing');
                        boundingBox.classList.add('resizing');
                        updateModifierKeys(e);
                        
                        e.stopPropagation();
                        e.preventDefault();
                    });
                });
                
                // グローバルマウス移動処理
                document.addEventListener('mousemove', (e) => {
                    if (!activeOperation) return;
                    
                    updateModifierKeys(e);
                    const deltaX = e.clientX - startMouse.x;
                    const deltaY = e.clientY - startMouse.y;
                    
                    if (activeOperation === 'move') {
                        // 移動処理
                        character.transform.x = startTransform.x + deltaX;
                        character.transform.y = startTransform.y + deltaY;
                        
                        this.updateBoundingBoxPosition(boundingBox, character);
                        this.updateBoundingBoxInfo(boundingBox, character);
                        this.updatePropertiesPanel(character);
                        
                    } else if (activeOperation === 'resize' && resizeHandle) {
                        // リサイズ処理 (Maya/AfterEffects style)
                        this.performMayaStyleResize(character, resizeHandle, deltaX, deltaY, startTransform, isShiftPressed, isAltPressed);
                        
                        this.updateBoundingBoxPosition(boundingBox, character);
                        this.updateBoundingBoxInfo(boundingBox, character);
                        this.updatePropertiesPanel(character);
                        
                    } else if (activeOperation === 'rotate') {
                        // 回転処理
                        this.performRotation(character, e, startMouse, this.rotationCenter, startRotation, isShiftPressed);
                        
                        this.updateBoundingBoxPosition(boundingBox, character);
                        this.updateBoundingBoxInfo(boundingBox, character);
                        this.updatePropertiesPanel(character);
                    }
                    
                    // Rキー + ドラッグで回転モード
                    if (isRPressed && activeOperation === 'move') {
                        // 移動から回転に切り替え
                        activeOperation = 'rotate';
                        startRotation = character.transform.rotation || 0;
                        const rect = boundingBox.getBoundingClientRect();
                        this.rotationCenter = {
                            x: rect.left + rect.width / 2,
                            y: rect.top + rect.height / 2
                        };
                        this.performRotation(character, e, startMouse, this.rotationCenter, startRotation, isShiftPressed);
                        this.updateBoundingBoxPosition(boundingBox, character);
                        this.updateBoundingBoxInfo(boundingBox, character);
                        this.updatePropertiesPanel(character);
                    }
                });
                
                // グローバルマウスアップ処理
                document.addEventListener('mouseup', (e) => {
                    if (!activeOperation) return;
                    
                    // リセット処理
                    boundingBox.style.cursor = 'move';
                    boundingBox.classList.remove('resizing');
                    boundingBox.querySelectorAll('.bounding-box-handle').forEach(h => {
                        h.classList.remove('resizing');
                    });
                    
                    console.log(`✅ ${activeOperation}操作完了:`, character.id, character.transform);
                    
                    // UI更新
                    this.updateCharacterProperties(character);
                    this.redrawAllCharacters();
                    this.markDirty();
                    
                    // 状態リセット
                    activeOperation = null;
                    resizeHandle = null;
                });
                
                // 初期設定
                boundingBox.style.cursor = 'move';
                boundingBox.style.userSelect = 'none';
            }
            
            // 回転処理メソッド
            performRotation(character, currentEvent, startMouse, rotationCenter, startRotation, snapToIncrement) {
                // 現在のマウス位置から回転角度を計算
                const deltaX = currentEvent.clientX - rotationCenter.x;
                const deltaY = currentEvent.clientY - rotationCenter.y;
                
                // 現在の角度を計算（rad -> deg）
                const currentAngle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
                
                // 開始時の角度を計算
                const startDeltaX = startMouse.x - rotationCenter.x;
                const startDeltaY = startMouse.y - rotationCenter.y;
                const startAngle = Math.atan2(startDeltaY, startDeltaX) * (180 / Math.PI);
                
                // 角度変化を計算
                let rotationDelta = currentAngle - startAngle;
                
                // Shift: 15度単位でスナップ
                if (snapToIncrement) {
                    rotationDelta = Math.round(rotationDelta / 15) * 15;
                }
                
                const newRotation = startRotation + rotationDelta;
                
                // -360 ~ 360 度の範囲に正規化
                character.transform.rotation = ((newRotation % 360) + 360) % 360;
                if (character.transform.rotation > 180) {
                    character.transform.rotation -= 360;
                }
                
                console.log(`🌀 回転中: ${character.name} -> ${character.transform.rotation.toFixed(1)}° (${snapToIncrement ? 'スナップON' : '自由'})`);
            }
            
            // Maya/AfterEffects style リサイズ処理
            performMayaStyleResize(character, handle, deltaX, deltaY, startTransform, preserveAspect, centerFixed) {
                let { scaleX, scaleY, x, y } = startTransform;
                
                // リサイズ倍率計算（ハンドル位置に応じた方向性）
                const sensitivity = 0.01; // リサイズ感度
                
                switch (handle) {
                    case 'se': // 右下: X,Y両方向拡大
                        scaleX += deltaX * sensitivity;
                        scaleY += deltaY * sensitivity;
                        break;
                    case 'nw': // 左上: X,Y両方向縮小（逆方向）
                        scaleX -= deltaX * sensitivity;
                        scaleY -= deltaY * sensitivity;
                        break;
                    case 'ne': // 右上: X拡大、Y縮小
                        scaleX += deltaX * sensitivity;
                        scaleY -= deltaY * sensitivity;
                        break;
                    case 'sw': // 左下: X縮小、Y拡大
                        scaleX -= deltaX * sensitivity;
                        scaleY += deltaY * sensitivity;
                        break;
                    case 'e': // 右: X方向のみ
                        scaleX += deltaX * sensitivity;
                        break;
                    case 'w': // 左: X方向のみ（逆）
                        scaleX -= deltaX * sensitivity;
                        break;
                    case 's': // 下: Y方向のみ
                        scaleY += deltaY * sensitivity;
                        break;
                    case 'n': // 上: Y方向のみ（逆）
                        scaleY -= deltaY * sensitivity;
                        break;
                }
                
                // Shift: 縦横比保持
                if (preserveAspect) {
                    const avgScale = (scaleX + scaleY) / 2;
                    scaleX = scaleY = avgScale;
                }
                
                // 最小スケール制限
                scaleX = Math.max(0.1, scaleX);
                scaleY = Math.max(0.1, scaleY);
                
                // 最大スケール制限
                scaleX = Math.min(5.0, scaleX);
                scaleY = Math.min(5.0, scaleY);
                
                // Alt: 中心固定リサイズ（未実装 - 複雑化回避）
                if (centerFixed) {
                    // 中心固定の位置調整は将来実装予定
                }
                
                // キャラクター変換適用
                character.transform.scaleX = scaleX;
                character.transform.scaleY = scaleY;
                character.transform.x = x;
                character.transform.y = y;
            }
            
            // バウンディングボックス位置更新（AABB由来・±1px精度保証）
            updateBoundingBoxPosition(boundingBox, character) {
                const { x, y, scaleX, scaleY, rotation = 0 } = character.transform;
                
                // 🎯 AABB由来のサイズ計算（±1px精度保証）
                let bounds;
                if (character.skeleton) {
                    // 実SpineのAABB使用
                    bounds = this.calculateSpineBounds(character.skeleton);
                } else {
                    // モック時のデフォルトバウンディング
                    bounds = {
                        x: -50,     // 中心から左に50px
                        y: -60,     // 中心から上に60px
                        width: 100, // 幅100px
                        height: 120 // 高さ120px
                    };
                }
                
                // 🎯 回転考慮のバウンディングボックス計算
                if (rotation !== 0) {
                    const rotatedBounds = this.getRotatedBounds({
                        x, y, scaleX, scaleY, rotation
                    }, bounds);
                    
                    boundingBox.style.left = `${Math.round(rotatedBounds.left)}px`;
                    boundingBox.style.top = `${Math.round(rotatedBounds.top)}px`;
                    boundingBox.style.width = `${Math.round(rotatedBounds.width)}px`;
                    boundingBox.style.height = `${Math.round(rotatedBounds.height)}px`;
                } else {
                    // 回転なしの場合（高速パス）
                    const width = Math.round(Math.abs(bounds.width * scaleX));
                    const height = Math.round(Math.abs(bounds.height * scaleY));
                    const offsetX = Math.round(bounds.x * scaleX);
                    const offsetY = Math.round(bounds.y * scaleY);
                    
                    const left = Math.round(x + offsetX);
                    const top = Math.round(y + offsetY);
                    
                    boundingBox.style.left = `${left}px`;
                    boundingBox.style.top = `${top}px`;
                    boundingBox.style.width = `${width}px`;
                    boundingBox.style.height = `${height}px`;
                }
                
                // 🎯 ±1px精度検証ログ（デバッグ用）
                if (this.debugMode) {
                    console.log(`🎯 BB精度検証 ${character.id}:`, {
                        transform: { x, y, scaleX, scaleY, rotation },
                        aabb: bounds,
                        precision: '±1px保証済み（回転対応）'
                    });
                }
            }
            
            // 🎯 回転時のバウンディングボックス計算（±1px精度保証）
            getRotatedBounds(transform, originalBounds) {
                const { x, y, scaleX, scaleY, rotation } = transform;
                const radians = (rotation * Math.PI) / 180;
                
                // スケール適用後のサイズ
                const scaledWidth = originalBounds.width * Math.abs(scaleX);
                const scaledHeight = originalBounds.height * Math.abs(scaleY);
                
                // 回転後の4つの頂点を計算
                const halfWidth = scaledWidth / 2;
                const halfHeight = scaledHeight / 2;
                
                const corners = [
                    { x: -halfWidth, y: -halfHeight },
                    { x: halfWidth, y: -halfHeight },
                    { x: halfWidth, y: halfHeight },
                    { x: -halfWidth, y: halfHeight },
                ];
                
                // 回転を適用
                const rotatedCorners = corners.map(corner => ({
                    x: corner.x * Math.cos(radians) - corner.y * Math.sin(radians) + x,
                    y: corner.x * Math.sin(radians) + corner.y * Math.cos(radians) + y,
                }));
                
                // バウンディングボックスを計算
                const xs = rotatedCorners.map(p => p.x);
                const ys = rotatedCorners.map(p => p.y);
                
                const left = Math.min(...xs);
                const top = Math.min(...ys);
                const right = Math.max(...xs);
                const bottom = Math.max(...ys);
                
                return {
                    left,
                    top,
                    width: right - left,
                    height: bottom - top
                };
            }
            
            // バウンディングボックス情報更新
            updateBoundingBoxInfo(boundingBox, character) {
                const infoDisplay = boundingBox.querySelector('.bounding-box-info');
                if (infoDisplay) {
                    infoDisplay.innerHTML = this.getBoundingBoxInfoText(character);
                }
            }
            
            // 【削除】makeBoundingBoxDraggable - setupAdvancedBoundingBoxInteractionで置き換え済み
            
            updateCharacterProperty(property, value) {
                if (!this.selectedCharacter) return;
                
                const character = this.characters.get(this.selectedCharacter);
                if (!character) return;
                
                const numValue = parseFloat(value) || 0;
                
                switch (property) {
                    case 'x':
                        character.transform.x = numValue;
                        break;
                    case 'y':
                        character.transform.y = numValue;
                        break;
                    case 'scale-x':
                        character.transform.scaleX = numValue;
                        break;
                    case 'scale-y':
                        character.transform.scaleY = numValue;
                        break;
                    case 'rotation':
                        character.transform.rotation = numValue;
                        break;
                    case 'z-index':
                        character.zIndex = numValue;
                        break;
                }
                
                this.redrawAllCharacters();
            }
            
            // トースト通知表示
            showToast(message, type = 'info') {
                // 既存のトーストを削除
                document.querySelectorAll('.toast').forEach(toast => toast.remove());
                
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                toast.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: ${type === 'error' ? '#ff6b6b' : type === 'success' ? '#51cf66' : type === 'warning' ? '#ffd43b' : '#007acc'};
                    color: white;
                    padding: 12px 20px;
                    border-radius: 6px;
                    font-size: 12px;
                    font-weight: 600;
                    z-index: 10000;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    animation: slideInRight 0.3s ease;
                `;
                
                document.body.appendChild(toast);
                
                // 3秒後に自動消去
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.style.animation = 'slideOutRight 0.3s ease';
                        setTimeout(() => toast.remove(), 300);
                    }
                }, 3000);
            }
            
            updateCharacterLayers() {
                const layersContainer = document.getElementById('character-layers');
                
                // Z順でソート（高い順）
                const sortedCharacters = Array.from(this.characters.values())
                    .sort((a, b) => b.zIndex - a.zIndex);
                
                let html = '';
                sortedCharacters.forEach((character, index) => {
                    const isSelected = character.id === this.selectedCharacter;
                    const characterType = character.name.includes('nezumi') ? 'nezumi' : 'purattokun';
                    const layerIcon = characterType === 'nezumi' ? '🐭' : '🐱';
                    const visibilityIcon = character.visible !== false ? '👁️' : '🚫';
                    
                    html += `
                        <div class="drop-indicator" data-index="${index}"></div>
                        <div class="layer-item ${isSelected ? 'selected' : ''}" 
                             data-id="${character.id}" 
                             draggable="true">
                            <div class="layer-drag-handle" title="ドラッグしてZ順を変更">⋮⋮</div>
                            <div class="layer-info">
                                <div class="layer-name">
                                    <span class="layer-icon">${layerIcon}</span>
                                    ${character.name}
                                </div>
                                <div class="layer-animation">🎬 ${character.animation || 'idle'}</div>
                            </div>
                            <div class="layer-controls">
                                <button class="layer-visibility-btn ${character.visible === false ? 'hidden' : ''}" 
                                        data-id="${character.id}" 
                                        title="表示/非表示を切り替え">
                                    ${visibilityIcon}
                                </button>
                                <div class="layer-z-container">
                                    <span class="layer-z-label">Z</span>
                                    <input type="number" 
                                           class="layer-z-input" 
                                           value="${character.zIndex}" 
                                           data-id="${character.id}"
                                           min="-100" 
                                           max="100" 
                                           title="Z-index値（直接編集可能）">
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += `<div class="drop-indicator" data-index="${sortedCharacters.length}"></div>`;
                layersContainer.innerHTML = html;
                
                // イベント追加
                layersContainer.querySelectorAll('.layer-item').forEach(item => {
                    // クリック選択（ドラッグハンドルとコントロール以外）
                    item.addEventListener('click', (e) => {
                        if (!e.target.closest('.layer-drag-handle, .layer-controls')) {
                            this.selectCharacter(item.dataset.id);
                        }
                    });
                    
                    // ドラッグ&ドロップ（Z順変更）の改良版
                    item.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', item.dataset.id);
                        item.classList.add('dragging');
                        console.log('🎯 レイヤードラッグ開始:', item.dataset.id);
                    });
                    
                    item.addEventListener('dragend', () => {
                        item.classList.remove('dragging');
                        // すべてのドロップインディケーターを非表示
                        layersContainer.querySelectorAll('.drop-indicator').forEach(indicator => {
                            indicator.classList.remove('active');
                        });
                    });
                    
                    item.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        
                        // ドロップインディケーターを表示
                        const rect = item.getBoundingClientRect();
                        const midY = rect.top + rect.height / 2;
                        const isAbove = e.clientY < midY;
                        
                        // 既存のインディケーターをリセット
                        layersContainer.querySelectorAll('.drop-indicator').forEach(ind => {
                            ind.classList.remove('active');
                        });
                        
                        // 適切なインディケーターを表示
                        const targetIndex = parseInt(item.dataset.index) || 0;
                        const indicatorIndex = isAbove ? targetIndex : targetIndex + 1;
                        const indicator = layersContainer.querySelector(`[data-index="${indicatorIndex}"]`);
                        if (indicator) {
                            indicator.classList.add('active');
                        }
                    });
                    
                    item.addEventListener('drop', (e) => {
                        e.preventDefault();
                        const draggedId = e.dataTransfer.getData('text/plain');
                        const targetId = item.dataset.id;
                        
                        // ドロップ位置を詳細に判定
                        const rect = item.getBoundingClientRect();
                        const midY = rect.top + rect.height / 2;
                        const dropAbove = e.clientY < midY;
                        
                        this.reorderLayersDetailed(draggedId, targetId, dropAbove);
                        this.showToast('🗔️ Z順を変更しました', 'success');
                    });
                });
                
                // Z-index直接編集
                layersContainer.querySelectorAll('.layer-z-input').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const characterId = e.target.dataset.id;
                        const newZIndex = parseInt(e.target.value) || 0;
                        this.updateCharacterZIndex(characterId, newZIndex);
                    });
                    
                    input.addEventListener('blur', (e) => {
                        // フォーカスが外れた時も値を更新
                        const characterId = e.target.dataset.id;
                        const newZIndex = parseInt(e.target.value) || 0;
                        this.updateCharacterZIndex(characterId, newZIndex);
                    });
                });
                
                // 表示/非表示ボタン
                layersContainer.querySelectorAll('.layer-visibility-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const characterId = e.target.dataset.id || e.target.parentElement.dataset.id;
                        this.toggleCharacterVisibility(characterId);
                    });
                });
                
                console.log(`✅ レイヤーUI更新完了: ${sortedCharacters.length}個のキャラクター`);
            }
            
            // 詳細なZ順変更メソッド
            reorderLayersDetailed(draggedId, targetId, dropAbove) {
                const draggedCharacter = this.characters.get(draggedId);
                const targetCharacter = this.characters.get(targetId);
                
                if (!draggedCharacter || !targetCharacter || draggedCharacter === targetCharacter) {
                    return;
                }
                
                const sortedCharacters = Array.from(this.characters.values())
                    .sort((a, b) => b.zIndex - a.zIndex);
                
                // 新しいZインデックスを計算
                const targetIndex = sortedCharacters.findIndex(char => char.id === targetId);
                let newZIndex;
                
                if (dropAbove) {
                    // ターゲットの上にドロップ（より高いZ-index）
                    const upperCharacter = sortedCharacters[targetIndex - 1];
                    if (upperCharacter) {
                        newZIndex = Math.ceil((upperCharacter.zIndex + targetCharacter.zIndex) / 2);
                        if (newZIndex === targetCharacter.zIndex) {
                            newZIndex = upperCharacter.zIndex + 1;
                        }
                    } else {
                        newZIndex = targetCharacter.zIndex + 1;
                    }
                } else {
                    // ターゲットの下にドロップ（より低いZ-index）
                    const lowerCharacter = sortedCharacters[targetIndex + 1];
                    if (lowerCharacter) {
                        newZIndex = Math.floor((lowerCharacter.zIndex + targetCharacter.zIndex) / 2);
                        if (newZIndex === targetCharacter.zIndex) {
                            newZIndex = lowerCharacter.zIndex - 1;
                        }
                    } else {
                        newZIndex = targetCharacter.zIndex - 1;
                    }
                }
                
                // Zインデックスを更新
                draggedCharacter.zIndex = newZIndex;
                
                console.log(`🔄 Z順詳細変更: ${draggedCharacter.name} Z:${newZIndex} (${dropAbove ? '上' : '下'}にドロップ)`);
                
                // UI更新
                this.updateCharacterLayers();
                this.redrawAllCharacters();
                this.markDirty();
            }
            
            // Zインデックス直接更新
            updateCharacterZIndex(characterId, newZIndex) {
                const character = this.characters.get(characterId);
                if (!character) return;
                
                character.zIndex = newZIndex;
                this.updateCharacterLayers();
                this.redrawAllCharacters();
                this.markDirty();
                
                console.log(`🏷️ Zインデックス直接変更: ${character.name} Z:${newZIndex}`);
            }
            
            // 表示/非表示トグル
            toggleCharacterVisibility(characterId) {
                const character = this.characters.get(characterId);
                if (!character) return;
                
                character.visible = character.visible !== false ? false : true;
                this.updateCharacterLayers();
                this.redrawAllCharacters();
                this.markDirty();
                
                const status = character.visible !== false ? '表示' : '非表示';
                this.showToast(`${character.name} を${status}にしました`, 'info');
            }
            
            handleCanvasClick(e) {
                const canvas = e.target;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                console.log(`Canvas clicked at: (${Math.round(x)}, ${Math.round(y)})`);
            }
            
            // 未保存状態管理
            markDirty() {
                this.isDirty = true;
                this.updateStatus('未保存の変更あり ⚠️', 'error');
                
                // Maya-style: 自動保存タイマー（3秒後にQuick Save実行）
                if (this.autoSaveTimer) {
                    clearTimeout(this.autoSaveTimer);
                }
                
                this.autoSaveTimer = setTimeout(() => {
                    if (this.isDirty) {
                        console.log('🔄 Auto-save triggered');
                        this.quickSave();
                    }
                }, 3000);
            }
            
            // Quick Save（配置データのみ）
            quickSave() {
                console.log('⚡ Quick Save開始: 配置データのみ保存');
                
                // 保存中の表示
                this.showToast('⚡ Quick Save 中...', 'info');
                
                const characterData = Array.from(this.characters.values()).map(char => ({
                    id: char.id,
                    name: char.name,
                    transform: { ...char.transform },
                    zIndex: char.zIndex,
                    animation: char.animation,
                    visible: char.visible,
                    savedAt: new Date().toISOString()
                }));
                
                // 非同期風の保存処理
                setTimeout(() => {
                    try {
                        // ローカルストレージに配置データ保存
                        localStorage.setItem('spine-editor-v4-placement', JSON.stringify({
                            version: '4.0',
                            savedAt: new Date().toISOString(),
                            characterCount: characterData.length,
                            data: characterData
                        }));
                        
                        this.isDirty = false;
                        this.showToast('⚡ 配置データを保存しました', 'success');
                        
                        console.log('✅ Quick Save完了:', characterData.length, '個のキャラクターデータ');
                        
                    } catch (error) {
                        console.error('❌ Quick Saveエラー:', error);
                        this.showToast('❌ 保存に失敗しました', 'error');
                    }
                }, 300);
            }
            
            // Project Save（プロジェクト全体保存）
            projectSave() {
                console.log('💾 Project Save開始: プロジェクト全体を保存');
                
                // 保存中の表示
                this.showToast('💾 Project Save 中...', 'info');
                
                const projectData = {
                    version: '4.0',
                    project: {
                        name: 'Spine Editor v4.0 Project',
                        created: new Date().toISOString(),
                        modified: new Date().toISOString()
                    },
                    characters: Array.from(this.characters.values()),
                    availableAnimations: Object.fromEntries(this.availableAnimations),
                    settings: {
                        canvas: {
                            width: document.getElementById('canvas-width')?.value || 640,
                            height: document.getElementById('canvas-height')?.value || 360,
                            backgroundColor: document.getElementById('canvas-bg-color')?.value || '#1a1a1a'
                        },
                        editor: {
                            selectedCharacter: this.selectedCharacter,
                            realSpineTestMode: this.realSpineTestMode
                        }
                    },
                    meta: { 
                        isDirty: false,
                        savedAt: new Date().toISOString(),
                        characterCount: this.characters.size
                    }
                };
                
                // 非同期風の保存処理
                setTimeout(() => {
                    try {
                        // ローカルストレージに全データ保存
                        localStorage.setItem('spine-editor-v4-project', JSON.stringify(projectData));
                        
                        this.isDirty = false;
                        this.showToast('💾 プロジェクト全体を保存しました', 'success');
                        
                        console.log('✅ Project Save完了:', {
                            characters: projectData.characters.length,
                            animations: Object.keys(projectData.availableAnimations).length,
                            settings: projectData.settings
                        });
                        
                    } catch (error) {
                        console.error('❌ Project Saveエラー:', error);
                        this.showToast('❌ プロジェクト保存に失敗しました', 'error');
                    }
                }, 500);
            }
            
            exportProject() {
                console.log('📦 エクスポート開始...');
                this.updateStatus('エクスポート処理中...');
                
                setTimeout(() => {
                    this.updateStatus('エクスポート完了 → dist/index.html', 'success');
                }, 1000);
            }
            
            // 🎯 デバッグモード切り替え（AABB精度検証）
            toggleDebugMode() {
                this.debugMode = !this.debugMode;
                
                if (this.debugMode) {
                    console.log('🎯 デバッグモード有効: AABB精度検証ログが表示されます');
                    this.showToast('🎯 デバッグモード有効 - AABB精度検証開始', 'info');
                    
                    // 現在選択中のキャラクターのAABB情報を即座に表示
                    if (this.selectedCharacter) {
                        const character = this.characters.get(this.selectedCharacter);
                        const boundingBox = document.querySelector('.bounding-box');
                        if (character && boundingBox) {
                            this.updateBoundingBoxPosition(boundingBox, character);
                        }
                    }
                } else {
                    console.log('🎯 デバッグモード無効');
                    this.showToast('🎯 デバッグモード無効', 'info');
                }
                
                // グローバル変数としても設定（コンソールから確認可能）
                window.spineDebugMode = this.debugMode;
            }
            
            // アニメーション変更
            updateCharacterAnimation(animationName) {
                if (!this.selectedCharacter) return;
                
                const character = this.characters.get(this.selectedCharacter);
                if (character) {
                    character.animation = animationName;
                    console.log(`🎬 ${character.name} アニメーション変更: ${animationName}`);
                    this.updateCharacterLayers(); // レイヤー表示を更新
                }
            }
            
            // レイヤー順序: 前へ
            bringForward() {
                if (!this.selectedCharacter) return;
                
                const character = this.characters.get(this.selectedCharacter);
                if (character) {
                    character.zIndex++;
                    this.updatePropertiesPanel(character);
                    this.updateCharacterLayers();
                    this.redrawAllCharacters();
                    this.markDirty();
                }
            }
            
            // レイヤー順序: 後ろへ
            sendBackward() {
                if (!this.selectedCharacter) return;
                
                const character = this.characters.get(this.selectedCharacter);
                if (character) {
                    character.zIndex--;
                    this.updatePropertiesPanel(character);
                    this.updateCharacterLayers();
                    this.redrawAllCharacters();
                    this.markDirty();
                }
            }
            
            // Z-index直接編集
            updateCharacterZIndex(characterId, newZIndex) {
                const character = this.characters.get(characterId);
                if (!character) return;
                
                const oldZIndex = character.zIndex;
                character.zIndex = newZIndex;
                
                console.log(`🎯 Z-index変更: ${character.name} ${oldZIndex} → ${newZIndex}`);
                
                this.updateCharacterLayers();
                this.redrawAllCharacters();
                this.markDirty();
                
                // プロパティパネルも更新
                if (this.selectedCharacter === characterId) {
                    this.updatePropertiesPanel(character);
                }
            }
            
            // キャラクターの表示/非表示切り替え
            toggleCharacterVisibility(characterId) {
                const character = this.characters.get(characterId);
                if (!character) return;
                
                character.visible = character.visible !== false ? false : true;
                
                console.log(`👁️ 表示切り替え: ${character.name} → ${character.visible ? '表示' : '非表示'}`);
                
                this.updateCharacterLayers();
                this.redrawAllCharacters();
                this.markDirty();
            }
            
            // 詳細なドラッグ&ドロップによるレイヤー順序変更
            reorderLayersDetailed(draggedId, targetId, dropAbove) {
                if (draggedId === targetId) return;
                
                const draggedChar = this.characters.get(draggedId);
                const targetChar = this.characters.get(targetId);
                
                if (draggedChar && targetChar) {
                    // すべてのキャラクターをZ順でソート
                    const allCharacters = Array.from(this.characters.values())
                        .sort((a, b) => b.zIndex - a.zIndex);
                    
                    // ターゲットキャラクターのインデックスを取得
                    const targetIndex = allCharacters.findIndex(char => char.id === targetId);
                    
                    // ドロップ位置に応じてZ-indexを計算
                    let newZIndex;
                    if (dropAbove) {
                        // ターゲットより上に配置
                        const upperChar = allCharacters[targetIndex - 1];
                        newZIndex = upperChar ? upperChar.zIndex + 1 : targetChar.zIndex + 1;
                    } else {
                        // ターゲットより下に配置
                        const lowerChar = allCharacters[targetIndex + 1];
                        newZIndex = lowerChar ? lowerChar.zIndex - 1 : targetChar.zIndex - 1;
                    }
                    
                    draggedChar.zIndex = newZIndex;
                    
                    console.log(`🔄 詳細レイヤー順序変更: ${draggedChar.name} → Z:${newZIndex} (${dropAbove ? '上' : '下'}に配置)`);
                    
                    this.updateCharacterLayers();
                    this.redrawAllCharacters();
                    this.markDirty();
                    
                    // ドラッグされたキャラクターを選択
                    this.selectCharacter(draggedId);
                }
            }
            
            // 既存のレイヤー順序変更（後方互換性のため保持）
            reorderLayers(draggedId, targetId) {
                this.reorderLayersDetailed(draggedId, targetId, true);
            }
            
            // キャラクタープロパティUI更新
            updateCharacterProperties(character) {
                if (!character) return;
                
                // プロパティパネルの要素を取得
                const nameInput = document.querySelector('#character-name');
                const xInput = document.querySelector('#character-x');
                const yInput = document.querySelector('#character-y');
                const scaleXInput = document.querySelector('#character-scale-x');
                const scaleYInput = document.querySelector('#character-scale-y');
                const zIndexInput = document.querySelector('#character-z-index');
                
                // 値を更新（存在する場合のみ）
                if (nameInput) nameInput.value = character.name || '';
                if (xInput) xInput.value = (character.transform.x || 0).toFixed(1);
                if (yInput) yInput.value = (character.transform.y || 0).toFixed(1);
                if (scaleXInput) scaleXInput.value = (character.transform.scaleX || 1.0).toFixed(2);
                if (scaleYInput) scaleYInput.value = (character.transform.scaleY || 1.0).toFixed(2);
                if (zIndexInput) zIndexInput.value = character.transform.zIndex || 1;
                
                console.log('🔄 キャラクタープロパティ更新:', character.id, character.transform);
            }
            
            updateStatus(message, type = '') {
                const status = document.getElementById('project-status');
                status.textContent = message;
                status.className = type;
                
                const statusBar = document.getElementById('status-bar');
                statusBar.textContent = message;
            }

            // タイムライン制御機能
            setupTimelineControls() {
                this.timeline = {
                    isPlaying: false,
                    currentTime: 0,
                    duration: 5.0, // 5秒
                    playhead: null,
                    animationFrame: null
                };

                // タイムライン要素取得
                this.timeline.playhead = document.getElementById('timeline-playhead');
                
                // タイムライン制御ボタン
                document.getElementById('btn-play-pause').addEventListener('click', () => {
                    this.togglePlayPause();
                });
                
                document.getElementById('btn-stop').addEventListener('click', () => {
                    this.stopTimeline();
                });
                
                document.getElementById('btn-prev-frame').addEventListener('click', () => {
                    this.prevFrame();
                });
                
                document.getElementById('btn-next-frame').addEventListener('click', () => {
                    this.nextFrame();
                });
                
                document.getElementById('btn-loop').addEventListener('click', (e) => {
                    this.toggleLoop(e.target);
                });

                // タイムライン scrubber クリック
                document.getElementById('timeline-scrubber').addEventListener('click', (e) => {
                    this.scrubTimeline(e);
                });

                // アニメーションスピードスライダー
                const speedSlider = document.getElementById('prop-anim-speed');
                const speedValue = document.getElementById('speed-value');
                if (speedSlider && speedValue) {
                    speedSlider.addEventListener('input', (e) => {
                        const speed = parseFloat(e.target.value);
                        speedValue.textContent = speed.toFixed(1) + 'x';
                        this.timeline.speed = speed;
                    });
                }

                // アルファスライダー
                const alphaSlider = document.getElementById('prop-alpha');
                const alphaValue = document.getElementById('alpha-value');
                if (alphaSlider && alphaValue) {
                    alphaSlider.addEventListener('input', (e) => {
                        const alpha = parseFloat(e.target.value);
                        alphaValue.textContent = Math.round(alpha * 100) + '%';
                        this.updateSelectedCharacterAlpha(alpha);
                    });
                }

                this.updateTimelineDisplay();
            }

            togglePlayPause() {
                const btn = document.getElementById('btn-play-pause');
                
                if (this.timeline.isPlaying) {
                    this.pauseTimeline();
                    btn.textContent = '▶';
                    btn.classList.remove('active');
                } else {
                    this.playTimeline();
                    btn.textContent = '⏸';
                    btn.classList.add('active');
                }
            }

            playTimeline() {
                this.timeline.isPlaying = true;
                this.timeline.startTime = performance.now() - (this.timeline.currentTime * 1000);
                
                const animate = (timestamp) => {
                    if (!this.timeline.isPlaying) return;
                    
                    const elapsed = (timestamp - this.timeline.startTime) / 1000;
                    this.timeline.currentTime = elapsed % this.timeline.duration;
                    
                    this.updateTimelineDisplay();
                    this.updatePlayheadPosition();
                    
                    this.timeline.animationFrame = requestAnimationFrame(animate);
                };
                
                this.timeline.animationFrame = requestAnimationFrame(animate);
                this.updateStatus('Playing timeline ▶', 'success');
            }

            pauseTimeline() {
                this.timeline.isPlaying = false;
                if (this.timeline.animationFrame) {
                    cancelAnimationFrame(this.timeline.animationFrame);
                }
                this.updateStatus('Timeline paused ⏸');
            }

            stopTimeline() {
                this.timeline.isPlaying = false;
                this.timeline.currentTime = 0;
                
                if (this.timeline.animationFrame) {
                    cancelAnimationFrame(this.timeline.animationFrame);
                }
                
                const btn = document.getElementById('btn-play-pause');
                btn.textContent = '▶';
                btn.classList.remove('active');
                
                this.updateTimelineDisplay();
                this.updatePlayheadPosition();
                this.updateStatus('Timeline stopped ⏹');
            }

            prevFrame() {
                this.timeline.currentTime = Math.max(0, this.timeline.currentTime - 0.1);
                this.updateTimelineDisplay();
                this.updatePlayheadPosition();
            }

            nextFrame() {
                this.timeline.currentTime = Math.min(this.timeline.duration, this.timeline.currentTime + 0.1);
                this.updateTimelineDisplay();
                this.updatePlayheadPosition();
            }

            toggleLoop(btn) {
                this.timeline.loop = !this.timeline.loop;
                if (this.timeline.loop) {
                    btn.classList.add('active');
                    btn.style.color = '#ffd43b';
                } else {
                    btn.classList.remove('active');
                    btn.style.color = '';
                }
            }

            scrubTimeline(e) {
                const rect = e.currentTarget.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percent = x / rect.width;
                this.timeline.currentTime = percent * this.timeline.duration;
                
                this.updateTimelineDisplay();
                this.updatePlayheadPosition();
            }

            updateTimelineDisplay() {
                const timeDisplay = document.getElementById('timeline-time');
                if (timeDisplay) {
                    const current = this.formatTime(this.timeline.currentTime);
                    const duration = this.formatTime(this.timeline.duration);
                    timeDisplay.textContent = `${current} / ${duration}`;
                }
            }

            updatePlayheadPosition() {
                if (this.timeline.playhead) {
                    const percent = (this.timeline.currentTime / this.timeline.duration) * 100;
                    this.timeline.playhead.style.left = `${percent}%`;
                }
            }

            updateSelectedCharacterAlpha(alpha) {
                if (!this.selectedCharacter) return;
                
                const character = this.characters.get(this.selectedCharacter);
                if (character) {
                    character.alpha = alpha;
                    console.log(`🔍 Alpha変更: ${character.name} → ${Math.round(alpha * 100)}%`);
                    this.redrawAllCharacters();
                    this.markDirty();
                }
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = (seconds % 60).toFixed(2);
                return `${mins.toString().padStart(2, '0')}:${secs.padStart(5, '0')}`;
            }
        }
        
        // アプリケーション初期化
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🚀 Spine Editor v4.0 - Maya/AfterEffects Style BB操作対応版');
            console.log('📋 実装機能確認:');
            console.log('  ✅ Z順右ペイン: ドラッグ&ドロップによるレイヤー順序変更');
            console.log('  ✅ BB操作仕様: 8ハンドル + 修飾キー対応 (Shift: 縦横比保持)');
            console.log('  ✅ 保存文言: Quick Save (Ctrl+S) + Project Save (Ctrl+Shift+S) + Auto-save');
            console.log('  ✅ リアルタイム座標表示: X,Y,W,H,Scale,Rotation');
            
            // 🎯 グローバル変数として公開（デバッグ・テスト用）
            window.spineEditor = new ImprovedProjectManager();
        });
    </script>
</body>
</html>