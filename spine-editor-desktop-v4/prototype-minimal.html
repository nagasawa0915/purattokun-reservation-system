<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æœ€å°ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ— - Spine Editor v4.0</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2d2d2d;
            color: #cccccc;
            height: 100vh;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        
        .app-container {
            display: grid;
            grid-template-areas: 
                "toolbar toolbar toolbar toolbar"
                "outliner preview preview properties"
                "outliner preview preview properties"
                "timeline timeline timeline timeline";
            grid-template-columns: minmax(200px, 300px) 2fr 2fr minmax(250px, 400px);
            grid-template-rows: 50px 2fr 1fr minmax(120px, 200px);
            height: 100vh;
            gap: 1px;
        }

        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 1200px) {
            .app-container {
                grid-template-columns: minmax(180px, 250px) 3fr 1fr minmax(200px, 300px);
            }
        }

        @media (max-width: 900px) {
            .app-container {
                grid-template-areas: 
                    "toolbar toolbar toolbar"
                    "outliner preview properties"
                    "outliner preview properties"
                    "timeline timeline timeline";
                grid-template-columns: minmax(150px, 200px) 2fr minmax(150px, 250px);
                grid-template-rows: 50px 2fr 1fr minmax(100px, 150px);
            }
        }

        @media (max-width: 600px) {
            .app-container {
                grid-template-areas: 
                    "toolbar"
                    "preview"
                    "outliner"
                    "properties"
                    "timeline";
                grid-template-columns: 1fr;
                grid-template-rows: 50px 2fr 150px 200px 120px;
            }
            
            .outliner, .properties {
                padding: 8px;
            }
            
            .timeline {
                padding: 8px;
            }
        }
        
        .toolbar {
            grid-area: toolbar;
            background: linear-gradient(135deg, #1e1e1e 0%, #252525 100%);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 12px;
            border-bottom: 1px solid #404040;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .toolbar button {
            background: #404040;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .toolbar button:hover {
            background: #505050;
        }
        
        .toolbar button.primary {
            background: #007acc;
        }
        
        .toolbar button.primary:hover {
            background: #1a8cff;
        }
        
        .outliner {
            grid-area: outliner;
            background: linear-gradient(135deg, #2a2a2a 0%, #1f1f1f 100%);
            border-right: 1px solid #404040;
            padding: 12px;
            overflow-y: auto;
            box-shadow: inset -1px 0 3px rgba(0, 0, 0, 0.2);
        }
        
        .preview {
            grid-area: preview;
            background: linear-gradient(135deg, #1e1e1e 0%, #151515 100%);
            position: relative;
            overflow: hidden;
            border: 1px solid #404040;
        }
        
        .properties {
            grid-area: properties;
            background: linear-gradient(135deg, #2a2a2a 0%, #1f1f1f 100%);
            border-left: 1px solid #404040;
            padding: 12px;
            overflow-y: auto;
            box-shadow: inset 1px 0 3px rgba(0, 0, 0, 0.2);
        }

        .timeline {
            grid-area: timeline;
            background: linear-gradient(135deg, #262626 0%, #1c1c1c 100%);
            border-top: 1px solid #404040;
            padding: 12px;
            overflow-x: auto;
            overflow-y: hidden;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .timeline-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .timeline-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .timeline-btn {
            background: #404040;
            border: 1px solid #606060;
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            min-width: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .timeline-btn:hover {
            background: #505050;
        }

        .timeline-btn.active {
            background: #007acc;
            border-color: #1a8cff;
        }

        .timeline-scrubber {
            flex: 1;
            height: 60px;
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 4px;
            position: relative;
            margin: 0 12px;
            overflow: hidden;
        }

        .timeline-ruler {
            height: 20px;
            background: #333333;
            border-bottom: 1px solid #404040;
            position: relative;
        }

        .timeline-track {
            height: 39px;
            position: relative;
            border-bottom: 1px solid #404040;
        }

        .timeline-track:last-child {
            border-bottom: none;
        }

        .timeline-playhead {
            position: absolute;
            top: 0;
            left: 20%;
            width: 2px;
            height: 100%;
            background: #ff6b6b;
            z-index: 10;
            pointer-events: none;
        }

        .timeline-keyframe {
            position: absolute;
            top: 50%;
            width: 8px;
            height: 8px;
            background: #ffd43b;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            border: 1px solid #ffffff;
        }

        .timeline-keyframe:hover {
            background: #ffec8c;
            transform: translate(-50%, -50%) scale(1.2);
        }

        .timeline-time-display {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #cccccc;
            min-width: 80px;
        }
        
        .panel-title {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid #404040;
        }
        
        .file-tree {
            font-size: 12px;
        }
        
        .file-item {
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 3px;
            margin: 2px 0;
        }
        
        .file-item:hover {
            background: #404040;
        }
        
        .file-item.selected {
            background: #007acc;
        }
        
        .property-group {
            margin-bottom: 16px;
        }
        
        .property-label {
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 6px;
            color: #cccccc;
        }
        
        .property-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .property-row label {
            font-size: 11px;
            width: 20px;
            color: #999999;
        }
        
        .property-input {
            background: #404040;
            border: 1px solid #606060;
            color: white;
            padding: 4px 6px;
            border-radius: 3px;
            font-size: 11px;
            width: 60px;
        }
        
        .property-input:focus {
            outline: none;
            border-color: #007acc;
        }
        
        .property-select {
            background: #404040;
            border: 1px solid #606060;
            color: white;
            padding: 4px 6px;
            border-radius: 3px;
            font-size: 11px;
            width: 100px;
        }
        
        .property-select:focus {
            outline: none;
            border-color: #007acc;
        }
        
        .layer-controls {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }
        
        .layer-btn {
            background: #404040;
            border: 1px solid #606060;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
        }
        
        .layer-btn:hover {
            background: #505050;
        }
        
        .character-layers {
            font-size: 12px;
            min-height: 200px;
            position: relative;
        }
        
        .layer-item {
            background: linear-gradient(135deg, #383838 0%, #2d2d2d 100%);
            border: 1px solid #4a4a4a;
            border-radius: 6px;
            margin: 3px 0;
            padding: 10px;
            cursor: grab;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .layer-item:hover {
            background: linear-gradient(135deg, #454545 0%, #363636 100%);
            border-color: #5a5a5a;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
            transform: translateY(-1px);
        }
        
        .layer-item.selected {
            background: linear-gradient(135deg, #0099ff 0%, #007acc 100%);
            border-color: #1aa3ff;
            box-shadow: 0 3px 12px rgba(0, 122, 204, 0.3);
        }
        
        .layer-item.dragging {
            opacity: 0.7;
            cursor: grabbing;
            transform: rotate(2deg) scale(1.02);
            z-index: 1000;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
        }
        
        .layer-item.drag-over {
            border-color: #ff6b6b;
            background: linear-gradient(135deg, #ff6b6b20 0%, #ff4757 100%);
        }
        
        .layer-info {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 0;
        }
        
        .layer-name {
            font-weight: 600;
            font-size: 13px;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .layer-icon {
            font-size: 14px;
            opacity: 0.8;
        }
        
        .layer-animation {
            font-size: 10px;
            color: #b3b3b3;
            margin-top: 3px;
            font-style: italic;
        }
        
        .layer-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .layer-z-container {
            display: flex;
            align-items: center;
            gap: 4px;
            background: #1e1e1e;
            padding: 4px 8px;
            border-radius: 12px;
            border: 1px solid #404040;
        }
        
        .layer-z-label {
            font-size: 9px;
            color: #888888;
            font-weight: 600;
        }
        
        .layer-z-input {
            background: transparent;
            border: none;
            color: #ffffff;
            font-size: 11px;
            font-weight: 600;
            width: 30px;
            text-align: center;
            padding: 0;
        }
        
        .layer-z-input:focus {
            outline: 1px solid #007acc;
            outline-offset: -1px;
            border-radius: 2px;
        }
        
        .layer-drag-handle {
            color: #666666;
            font-size: 12px;
            cursor: grab;
            padding: 0 4px;
            user-select: none;
        }
        
        .layer-drag-handle:hover {
            color: #999999;
        }
        
        .layer-visibility-btn {
            background: none;
            border: none;
            color: #888888;
            font-size: 14px;
            cursor: pointer;
            padding: 2px;
            border-radius: 3px;
            transition: color 0.15s ease;
        }
        
        .layer-visibility-btn:hover {
            color: #ffffff;
        }
        
        .layer-visibility-btn.hidden {
            color: #ff6b6b;
        }
        
        .drop-indicator {
            height: 2px;
            background: #007acc;
            margin: 1px 0;
            opacity: 0;
            transition: opacity 0.2s ease;
            border-radius: 1px;
        }
        
        .drop-indicator.active {
            opacity: 1;
        }
        
        .preview-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid #404040;
            background: #f0f0f0;
        }
        
        .status-bar {
            position: absolute;
            bottom: 8px;
            left: 8px;
            font-size: 11px;
            color: #888888;
        }
        
        .bounding-box {
            position: absolute;
            border: 2px solid #007acc;
            background: rgba(0, 122, 204, 0.1);
            cursor: move;
            z-index: 1000;
            display: none;
            box-shadow: 0 0 12px rgba(0, 122, 204, 0.3);
            transition: all 0.1s ease;
        }
        
        .bounding-box.active {
            display: block;
        }
        
        .bounding-box:hover {
            background: rgba(0, 122, 204, 0.15);
            box-shadow: 0 0 16px rgba(0, 122, 204, 0.4);
        }
        
        .bounding-box-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #007acc;
            border: 2px solid #ffffff;
            border-radius: 2px;
            z-index: 1001;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0.9;
            /* 12pxä»¥ä¸Šã®å½“ãŸã‚Šåˆ¤å®šã‚’ç¢ºä¿ */
            min-width: 12px;
            min-height: 12px;
        }
        
        .bounding-box-handle:hover {
            background: #1a8cff;
            transform: scale(1.4);
            opacity: 1;
            box-shadow: 0 3px 8px rgba(0, 122, 204, 0.4);
        }
        
        /* ä¿®é£¾ã‚­ãƒ¼çŠ¶æ…‹è¡¨ç¤º */
        .modifier-key-hint {
            position: absolute;
            bottom: -70px;
            left: 0;
            background: rgba(0, 0, 0, 0.85);
            color: #ffffff;
            padding: 6px 10px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            border-radius: 4px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1005;
        }
        
        .bounding-box:hover .modifier-key-hint,
        .bounding-box.resizing .modifier-key-hint {
            opacity: 1;
        }
        
        .bounding-box-handle:active {
            background: #0066cc;
            transform: scale(1.1);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        /* 8ãƒãƒ³ãƒ‰ãƒ«é…ç½® - Maya/AfterEffects style (å½“ãŸã‚Šåˆ¤å®š12pxä»¥ä¸Š) */
        .handle-nw { top: -7px; left: -7px; cursor: nw-resize; }
        .handle-ne { top: -7px; right: -7px; cursor: ne-resize; }
        .handle-sw { bottom: -7px; left: -7px; cursor: sw-resize; }
        .handle-se { bottom: -7px; right: -7px; cursor: se-resize; }
        .handle-n { top: -7px; left: 50%; margin-left: -6px; cursor: n-resize; }
        .handle-s { bottom: -7px; left: 50%; margin-left: -6px; cursor: s-resize; }
        .handle-w { top: 50%; left: -7px; margin-top: -6px; cursor: w-resize; }
        .handle-e { top: 50%; right: -7px; margin-top: -6px; cursor: e-resize; }
        
        /* å›è»¢ãƒãƒ³ãƒ‰ãƒ« */
        .handle-rotate {
            top: -25px;
            left: 50%;
            margin-left: -6px;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill="%23007acc" d="M8 1a7 7 0 0 1 7 7h-2a5 5 0 1 0-5-5V1z"/><path fill="%23007acc" d="M6 0v4l2-2 2 2V0H6z"/></svg>') 8 8, auto;
            background: #ff6b6b;
        }
        
        .handle-rotate:hover {
            background: #ff5252;
            transform: scale(1.3) rotate(15deg);
        }
        
        /* ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã®è¦–è¦šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ */
        .bounding-box-handle.resizing {
            background: #ff6b6b;
            border-color: #ffffff;
            transform: scale(1.4);
        }
        
        /* åº§æ¨™è¡¨ç¤º */
        .bounding-box-info {
            position: absolute;
            bottom: -45px;
            left: 0;
            background: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            padding: 4px 8px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            border-radius: 3px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 1004;
        }
        
        .bounding-box:hover .bounding-box-info,
        .bounding-box.resizing .bounding-box-info {
            opacity: 1;
        }
        
        .drag-handle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #007acc;
            border: 1px solid #ffffff;
            border-radius: 50%;
            cursor: move;
            z-index: 1000;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888888;
            font-size: 14px;
        }
        
        .error {
            color: #ff6b6b;
        }
        
        .success {
            color: #51cf66;
        }
        
        .saving {
            color: #ffd43b;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        /* ãƒˆãƒ¼ã‚¹ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
    </style>
    
    <!-- Spine WebGL Runtime -->
    <script src="../assets/js/libs/spine-webgl.js" onerror="console.error('Failed to load Spine WebGL library')"></script>
    
    <script>
        // Spine WebGL èª­ã¿è¾¼ã¿ç¢ºèª
        window.addEventListener('load', function() {
            if (typeof spine === 'undefined') {
                console.error('âŒ Spine WebGL library not loaded');
            } else {
                console.log('âœ… Spine WebGL library loaded successfully');
                console.log('Available spine objects:', Object.keys(spine));
            }
        });
    </script>
</head>
<body>
    <div class="app-container">
        <!-- ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ -->
        <div class="toolbar">
            <button id="btn-select-hp">HPãƒ•ã‚©ãƒ«ãƒ€é¸æŠ</button>
            <button id="btn-select-spine">Spineãƒ•ã‚©ãƒ«ãƒ€é¸æŠ</button>
            <button id="btn-real-spine-test" class="primary">ğŸ¯ å®ŸSpineãƒ†ã‚¹ãƒˆ</button>
            <button id="btn-quick-save" class="primary">âš¡ Quick Save (Ctrl+S)</button>
            <button id="btn-project-save">ğŸ’¾ Project Save (Ctrl+Shift+S)</button>
            <button id="btn-export">ğŸ“¦ Export</button>
            <span id="project-status">ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæœªé¸æŠ</span>
        </div>
        
        <!-- ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒŠãƒ¼ -->
        <div class="outliner">
            <div class="panel-title">ğŸ“ ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒŠãƒ¼</div>
            
            <!-- HPãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ -->
            <div class="property-group">
                <div class="property-label">ğŸ“„ HP / .html ãƒ•ã‚¡ã‚¤ãƒ«</div>
                <div id="hp-file-list" class="file-tree">
                    <div class="loading">HPãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã—ã¦ãã ã•ã„</div>
                </div>
            </div>
            
            <!-- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸€è¦§ -->
            <div class="property-group">
                <div class="property-label">ğŸ­ Characters / Animations</div>
                <div id="character-animation-tree" class="file-tree">
                    <div class="loading">Spineãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã—ã¦ãã ã•ã„</div>
                </div>
            </div>
        </div>
        
        <!-- ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢ -->
        <div class="preview">
            <canvas id="preview-canvas" class="preview-canvas" width="640" height="360"></canvas>
            <div class="status-bar" id="status-bar">æº–å‚™å®Œäº†</div>
        </div>
        
        <!-- ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ‘ãƒãƒ« -->
        <div class="properties">
            <!-- ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
            <div class="property-group">
                <div class="panel-title">ğŸ“š ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†</div>
                <div id="character-layers" class="character-layers">
                    <div class="loading">ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„</div>
                </div>
                <div class="layer-controls">
                    <button class="layer-btn" id="btn-move-layer-up">â†‘ Up</button>
                    <button class="layer-btn" id="btn-move-layer-down">â†“ Down</button>
                </div>
            </div>
            
            <div class="panel-title">ğŸ›ï¸ ã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚¿ãƒ¼</div>
            
            <!-- é¸æŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ± -->
            <div class="property-group">
                <div class="property-label">é¸æŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</div>
                <div class="selected-object-info" id="selected-object-info">
                    <div style="color: #888; font-size: 11px;">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„</div>
                </div>
            </div>
            
            <!-- Transform -->
            <div class="property-group">
                <div class="property-label">ğŸ”„ Transform</div>
                <div class="property-row">
                    <label>X</label>
                    <input type="number" class="property-input" id="prop-x" value="0" step="0.1">
                    <label>Y</label>
                    <input type="number" class="property-input" id="prop-y" value="0" step="0.1">
                </div>
                <div class="property-row">
                    <label>W</label>
                    <input type="number" class="property-input" id="prop-width" value="100" step="1">
                    <label>H</label>
                    <input type="number" class="property-input" id="prop-height" value="100" step="1">
                </div>
                <div class="property-row">
                    <label>Rot</label>
                    <input type="number" class="property-input" id="prop-rotation" value="0" step="1">
                    <label style="margin-left: 20px;">Â°</label>
                </div>
                <div class="property-row">
                    <label>SX</label>
                    <input type="number" class="property-input" id="prop-scale-x" value="1.0" step="0.01">
                    <label>SY</label>
                    <input type="number" class="property-input" id="prop-scale-y" value="1.0" step="0.01">
                </div>
            </div>
            
            <!-- Canvasè¨­å®š -->
            <div class="property-group">
                <div class="property-label">ğŸ¨ Canvas</div>
                <div class="property-row">
                    <label>W</label>
                    <input type="number" class="property-input" id="canvas-width" value="640" step="1">
                    <label>H</label>
                    <input type="number" class="property-input" id="canvas-height" value="360" step="1">
                </div>
                <div class="property-row">
                    <label>BG</label>
                    <input type="color" class="property-input" id="canvas-bg-color" value="#1a1a1a" style="width: 40px; height: 24px; padding: 2px;">
                    <button class="layer-btn" id="btn-canvas-clear" style="margin-left: 8px;">Clear</button>
                </div>
                <div class="property-row">
                    <button class="layer-btn" id="btn-canvas-fit">Fit to View</button>
                    <button class="layer-btn" id="btn-canvas-reset">Reset</button>
                </div>
            </div>
            
            <!-- Animation -->
            <div class="property-group">
                <div class="property-label">ğŸ¬ Animation</div>
                <div class="property-row">
                    <select class="property-select" id="prop-animation" style="width: 100%;">
                        <option value="idle">idle</option>
                        <option value="walk">walk</option>
                        <option value="run">run</option>
                        <option value="jump">jump</option>
                        <option value="attack">attack</option>
                    </select>
                </div>
                <div class="property-row">
                    <label>Speed</label>
                    <input type="range" class="property-input" id="prop-anim-speed" value="1.0" min="0.1" max="3.0" step="0.1" style="width: 80px;">
                    <span id="speed-value" style="font-size: 10px; color: #888;">1.0x</span>
                </div>
                <div class="property-row">
                    <button class="layer-btn" id="btn-anim-play">â–¶ Play</button>
                    <button class="layer-btn" id="btn-anim-pause">â¸ Pause</button>
                    <button class="layer-btn" id="btn-anim-stop">â¹ Stop</button>
                </div>
            </div>
            
            <!-- Layer Order -->
            <div class="property-group">
                <div class="property-label">ğŸ“š Layer Order</div>
                <div class="property-row">
                    <label>Z</label>
                    <input type="number" class="property-input" id="prop-z-index" value="0" step="1">
                </div>
                <div class="layer-controls">
                    <button class="layer-btn" id="btn-bring-to-front">â†‘â†‘ Front</button>
                    <button class="layer-btn" id="btn-bring-forward">â†‘ Forward</button>
                </div>
                <div class="layer-controls">
                    <button class="layer-btn" id="btn-send-backward">â†“ Backward</button>
                    <button class="layer-btn" id="btn-send-to-back">â†“â†“ Back</button>
                </div>
            </div>
            
            <!-- Visibility -->
            <div class="property-group">
                <div class="property-label">ğŸ‘ï¸ Visibility</div>
                <div class="property-row">
                    <label>Alpha</label>
                    <input type="range" class="property-input" id="prop-alpha" value="1.0" min="0" max="1" step="0.01" style="width: 80px;">
                    <span id="alpha-value" style="font-size: 10px; color: #888;">100%</span>
                </div>
                <div class="property-row">
                    <button class="layer-btn" id="btn-toggle-visibility">ğŸ‘ï¸ Show/Hide</button>
                    <button class="layer-btn" id="btn-lock-object">ğŸ”’ Lock</button>
                </div>
            </div>
        </div>

        <!-- ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãƒ‘ãƒãƒ« -->
        <div class="timeline">
            <div class="timeline-header">
                <div class="panel-title">ğŸ¬ ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³</div>
                <div class="timeline-controls">
                    <button class="timeline-btn" id="btn-play-pause" title="å†ç”Ÿ/åœæ­¢">â–¶</button>
                    <button class="timeline-btn" id="btn-stop" title="åœæ­¢">â¹</button>
                    <button class="timeline-btn" id="btn-prev-frame" title="å‰ãƒ•ãƒ¬ãƒ¼ãƒ ">â®</button>
                    <button class="timeline-btn" id="btn-next-frame" title="æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ">â­</button>
                </div>
                <div class="timeline-time-display" id="timeline-time">00:00.00 / 00:05.00</div>
                <button class="timeline-btn" id="btn-loop" title="ãƒ«ãƒ¼ãƒ—å†ç”Ÿ">ğŸ”</button>
            </div>
            
            <div class="timeline-scrubber" id="timeline-scrubber">
                <div class="timeline-ruler">
                    <!-- ãƒ«ãƒ¼ãƒ©ãƒ¼ãƒãƒ¼ã‚¯ã¯å‹•çš„ã«ç”Ÿæˆ -->
                </div>
                <div class="timeline-track">
                    <!-- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒˆãƒ©ãƒƒã‚¯ -->
                    <div class="timeline-keyframe" style="left: 10%;" title="ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ  0s"></div>
                    <div class="timeline-keyframe" style="left: 30%;" title="ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ  1.5s"></div>
                    <div class="timeline-keyframe" style="left: 60%;" title="ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ  3.0s"></div>
                    <div class="timeline-keyframe" style="left: 90%;" title="ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ  4.5s"></div>
                </div>
                <div class="timeline-playhead" id="timeline-playhead"></div>
            </div>
        </div>
    </div>

    <script>
        // æ”¹å–„ç‰ˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†
        class ImprovedProjectManager {
            constructor() {
                this.project = null;
                this.selectedCharacter = null;
                this.characters = new Map();
                this.availableAnimations = new Map(); // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã”ã¨ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸€è¦§
                this.isDirty = false; // æœªä¿å­˜ã®å¤‰æ›´ãŒã‚ã‚‹ã‹
                this.realSpineTestMode = false; // å®ŸSpineãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°
                this.useSpineCanvasMethod = false; // SpineCanvasä½¿ç”¨ãƒ•ãƒ©ã‚°
                this.debugMode = false; // ğŸ¯ AABBç²¾åº¦ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°
                this.init();
            }
            
            init() {
                this.bindEvents();
                this.updateStatus('ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—æº–å‚™å®Œäº†');
            }
            
            bindEvents() {
                // ãƒ•ã‚©ãƒ«ãƒ€é¸æŠï¼ˆãƒ¢ãƒƒã‚¯ï¼‰
                document.getElementById('btn-select-hp').addEventListener('click', () => {
                    this.selectHPFolder();
                });
                
                document.getElementById('btn-select-spine').addEventListener('click', () => {
                    this.selectSpineFolder();
                });
                
                document.getElementById('btn-real-spine-test').addEventListener('click', () => {
                    this.runRealSpineTest();
                });
                
                // 2æ®µéšä¿å­˜ã‚·ã‚¹ãƒ†ãƒ 
                document.getElementById('btn-quick-save').addEventListener('click', () => {
                    this.quickSave();
                });
                
                document.getElementById('btn-project-save').addEventListener('click', () => {
                    this.projectSave();
                });
                
                document.getElementById('btn-export').addEventListener('click', () => {
                    this.exportProject();
                });
                
                // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.shiftKey && e.key === 'S') {
                        // Ctrl+Shift+S: Project Save
                        e.preventDefault();
                        this.projectSave();
                    } else if (e.ctrlKey && e.key === 's') {
                        // Ctrl+S: Quick Save
                        e.preventDefault();
                        this.quickSave();
                    } else if (e.code === 'Space') {
                        // Space: Play/Pause
                        e.preventDefault();
                        this.togglePlayPause();
                    } else if (e.ctrlKey && e.key === 'd') {
                        // Ctrl+D: ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
                        e.preventDefault();
                        this.toggleDebugMode();
                    }
                });

                // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³åˆ¶å¾¡
                this.setupTimelineControls();
                
                // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å¤‰æ›´
                ['prop-x', 'prop-y', 'prop-scale-x', 'prop-scale-y', 'prop-rotation', 'prop-z-index'].forEach(id => {
                    document.getElementById(id).addEventListener('input', (e) => {
                        this.updateCharacterProperty(id.replace('prop-', ''), e.target.value);
                        this.markDirty();
                    });
                });
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é¸æŠ
                document.getElementById('prop-animation').addEventListener('change', (e) => {
                    this.updateCharacterAnimation(e.target.value);
                    this.markDirty();
                });
                
                // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
                document.getElementById('btn-bring-forward').addEventListener('click', () => {
                    this.bringForward();
                });
                
                document.getElementById('btn-send-backward').addEventListener('click', () => {
                    this.sendBackward();
                });
                
                // Zé †ç®¡ç†ãƒœã‚¿ãƒ³
                document.getElementById('btn-move-layer-up').addEventListener('click', () => {
                    this.moveLayerUp();
                });
                
                document.getElementById('btn-move-layer-down').addEventListener('click', () => {
                    this.moveLayerDown();
                });
                
                // ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒªã‚¹ãƒˆã®ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—åˆæœŸåŒ–
                this.initializeLayerDragAndDrop();
                
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªãƒƒã‚¯
                document.getElementById('preview-canvas').addEventListener('click', (e) => {
                    this.handleCanvasClick(e);
                });
            }
            
            selectHPFolder() {
                // ãƒ¢ãƒƒã‚¯: HPãƒ•ã‚©ãƒ«ãƒ€é¸æŠ
                this.updateStatus('HPãƒ•ã‚©ãƒ«ãƒ€: D:/example/homepage');
                this.updateFileTree([
                    { name: 'index.html', type: 'file' },
                    { name: 'assets', type: 'folder' },
                    { name: 'css', type: 'folder' }
                ]);
            }
            
            // æ¬ è½ã—ã¦ã„ãŸupdateFileTreeãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…
            updateFileTree(files) {
                console.log('ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ãƒ„ãƒªãƒ¼æ›´æ–°:', files);
                // å®Ÿè£…: å®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ„ãƒªãƒ¼è¡¨ç¤ºã¯ä»Šå¾Œã®ãƒ•ã‚§ãƒ¼ã‚ºã§è¿½åŠ äºˆå®š
                // ç¾åœ¨ã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°ã®ã¿ã§å‹•ä½œç¢ºèª
                if (files && files.length > 0) {
                    console.log('âœ… ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§å–å¾—æˆåŠŸ:', files.map(f => f.name));
                } else {
                    console.warn('âš ï¸ ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ãŒç©ºã§ã™');
                }
            }
            
            selectSpineFolder() {
                // å®Ÿéš›ã®Spineãƒ•ã‚©ãƒ«ãƒ€é¸æŠæº–å‚™
                this.updateStatus('Spineãƒ•ã‚©ãƒ«ãƒ€é¸æŠæº–å‚™ä¸­...');
                this.initializeSpineSystem();
            }
            
            initializeSpineSystem() {
                // å®ŸSpineã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–
                console.log('ğŸ¯ å®ŸSpineã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–é–‹å§‹');
                
                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚­ãƒ£ãƒ³ãƒã‚¹ã®æº–å‚™
                this.setupSpineCanvas();
                
                // Spine WebGLãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿æº–å‚™
                this.loadSpineLibrary();
            }
            
            setupSpineCanvas() {
                const preview = document.querySelector('.preview');
                
                // æ—¢å­˜ã®canvasãŒã‚ã‚Œã°å‰Šé™¤
                const existingCanvas = preview.querySelector('canvas');
                if (existingCanvas) {
                    existingCanvas.remove();
                }
                
                // Spineç”¨WebGLã‚­ãƒ£ãƒ³ãƒã‚¹ä½œæˆ
                const canvas = document.createElement('canvas');
                canvas.id = 'spine-webgl-canvas';
                canvas.width = preview.clientWidth;
                canvas.height = preview.clientHeight;
                canvas.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: transparent;
                `;
                
                preview.appendChild(canvas);
                
                // WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆæœŸåŒ–
                this.initializeWebGL(canvas);
                
                console.log('âœ… Spine WebGLã‚­ãƒ£ãƒ³ãƒã‚¹æº–å‚™å®Œäº†');
            }
            
            // WebGLåˆæœŸåŒ–ã¨Spineãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
            initializeWebGL(canvas) {
                try {
                    // WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå–å¾—
                    this.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (!this.gl) {
                        throw new Error('WebGLãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“');
                    }
                    
                    console.log('âœ… WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆæœŸåŒ–å®Œäº†');
                    
                    // Spine WebGLã®åˆæœŸåŒ–ã¯ loadSpineLibrary() å¾Œã«å®Ÿè¡Œ
                    this.webglCanvas = canvas;
                    
                } catch (error) {
                    console.error('âŒ WebGLåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus('WebGLåˆæœŸåŒ–å¤±æ•—: ' + error.message);
                }
            }
            
            // Spineãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—é–‹å§‹ï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ï¼‰
            startSpineRenderLoop() {
                console.log('ğŸ¬ Spineãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—é–‹å§‹æº–å‚™...');
                
                // WebGL/Spineç’°å¢ƒãƒã‚§ãƒƒã‚¯
                if (!this.gl) {
                    console.warn('âš ï¸ WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚2Dã‚­ãƒ£ãƒ³ãƒã‚¹ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯');
                    this.startCanvasFallbackRenderLoop();
                    return;
                }
                
                if (!this.spineRenderer) {
                    console.warn('âš ï¸ Spineãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚åŸºæœ¬WebGLã®ã¿ã§å®Ÿè¡Œ');
                }
                
                let frameCount = 0;
                const maxFPS = 60;
                const frameInterval = 1000 / maxFPS;
                let lastFrameTime = performance.now();
                
                const render = (currentTime) => {
                    try {
                        // FPSåˆ¶é™
                        const deltaTime = currentTime - lastFrameTime;
                        if (deltaTime < frameInterval) {
                            requestAnimationFrame(render);
                            return;
                        }
                        
                        lastFrameTime = currentTime;
                        frameCount++;
                        
                        // WebGLã‚¯ãƒªã‚¢å‡¦ç†
                        if (this.gl && this.gl.canvas) {
                            this.gl.clearColor(0, 0, 0, 0); // é€æ˜èƒŒæ™¯
                            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
                        }
                        
                        // å„ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                        if (this.characters.size > 0) {
                            this.characters.forEach((character) => {
                                this.renderSpineCharacter(character);
                            });
                        }
                        
                        // ãƒ•ãƒ¬ãƒ¼ãƒ çµ±è¨ˆï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
                        if (frameCount % 300 === 0) { // 5ç§’ã”ã¨ï¼ˆ60fps x 5s = 300framesï¼‰
                            console.log(`ğŸ¬ ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°çµ±è¨ˆ: ${frameCount}ãƒ•ãƒ¬ãƒ¼ãƒ å‡¦ç†æ¸ˆã¿`);
                        }
                        
                    } catch (error) {
                        console.error('âŒ ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ã‚¨ãƒ©ãƒ¼:', error);
                        
                        // ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã¯2Dãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã«åˆ‡ã‚Šæ›¿ãˆ
                        console.log('ğŸ”„ 2Dã‚­ãƒ£ãƒ³ãƒã‚¹ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯');
                        this.startCanvasFallbackRenderLoop();
                        return;
                    }
                    
                    // æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ 
                    requestAnimationFrame(render);
                };
                
                requestAnimationFrame(render);
                console.log('âœ… Spineãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—é–‹å§‹');
            }
            
            // 2Dã‚­ãƒ£ãƒ³ãƒã‚¹ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
            startCanvasFallbackRenderLoop() {
                console.log('ğŸ”„ 2Dã‚­ãƒ£ãƒ³ãƒã‚¹ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–‹å§‹');
                
                // æ—¢å­˜ã®WebGLã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’éè¡¨ç¤º
                const webglCanvas = document.getElementById('spine-webgl-canvas');
                if (webglCanvas) {
                    webglCanvas.style.display = 'none';
                }
                
                // 2Dã‚­ãƒ£ãƒ³ãƒã‚¹ä½œæˆ
                const preview = document.querySelector('.preview');
                let canvas2d = document.getElementById('fallback-2d-canvas');
                
                if (!canvas2d) {
                    canvas2d = document.createElement('canvas');
                    canvas2d.id = 'fallback-2d-canvas';
                    canvas2d.width = preview.clientWidth;
                    canvas2d.height = preview.clientHeight;
                    canvas2d.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: transparent;
                    `;
                    preview.appendChild(canvas2d);
                }
                
                const ctx = canvas2d.getContext('2d');
                
                const render = () => {
                    try {
                        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªã‚¢
                        ctx.clearRect(0, 0, canvas2d.width, canvas2d.height);
                        
                        // ã‚°ãƒªãƒƒãƒ‰æç”»
                        this.drawGrid(ctx, canvas2d);
                        
                        // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä»£æ›¿è¡¨ç¤º
                        this.characters.forEach(character => {
                            this.drawMockCharacter(character, ctx, canvas2d);
                        });
                        
                    } catch (error) {
                        console.error('âŒ 2Dãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:', error);
                    }
                    
                    requestAnimationFrame(render);
                };
                
                requestAnimationFrame(render);
                console.log('âœ… 2Dãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–‹å§‹');
            }
            
            // å€‹åˆ¥Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
            renderSpineCharacter(character) {
                if (!character.skeleton || !character.animationState) return;
                
                try {
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
                    character.animationState.update(0.016); // 60fps
                    character.animationState.apply(character.skeleton);
                    
                    // skeletonåº§æ¨™ã®é©ç”¨ï¼ˆå®‰å…¨åŸå‰‡ã«å¾“ã†ï¼‰
                    character.skeleton.x = character.transform.x || 0;
                    character.skeleton.y = character.transform.y || 0;
                    character.skeleton.scaleX = character.transform.scaleX || 1.0;
                    character.skeleton.scaleY = character.transform.scaleY || 1.0;
                    
                    // ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›æ›´æ–°
                    character.skeleton.updateWorldTransform();
                    
                    // Spineãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã§æç”»
                    if (this.spineRenderer) {
                        this.spineRenderer.draw(character.skeleton);
                    }
                    
                } catch (error) {
                    console.warn('âš ï¸ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:', character.id, error);
                }
            }
            
            loadSpineLibrary() {
                // Spine WebGLãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
                if (typeof spine !== 'undefined') {
                    console.log('âœ… Spine WebGLãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­ã¿è¾¼ã¿å®Œäº†');
                    this.initializeSpineApp();
                } else {
                    console.error('âŒ Spine WebGLãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    this.updateStatus('Spine WebGLãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¨ãƒ©ãƒ¼');
                }
            }
            
            initializeSpineApp() {
                const canvas = document.getElementById('spine-webgl-canvas');
                
                try {
                    // Spine WebGLãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒæ­£ã—ãèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹è©³ç´°ãƒã‚§ãƒƒã‚¯
                    console.log('ğŸ” Spine WebGLæ§‹é€ ç¢ºèª:', {
                        spine: typeof spine,
                        spineWebgl: typeof spine?.webgl,
                        SpineCanvas: typeof spine?.SpineCanvas,
                        SceneRenderer: typeof spine?.webgl?.SceneRenderer
                    });
                    
                    // Spine WebGLã‚¢ãƒ—ãƒªåˆæœŸåŒ–
                    if (typeof spine.SpineCanvas !== 'undefined') {
                        this.spineApp = new spine.SpineCanvas(canvas, {
                            pathPrefix: '../assets/spine/characters/',
                            alpha: true,
                            backgroundColor: '#00000000' // é€æ˜èƒŒæ™¯
                        });
                        console.log('âœ… Spine WebGLã‚¢ãƒ—ãƒªåˆæœŸåŒ–å®Œäº†');
                    } else {
                        console.warn('âš ï¸ spine.SpineCanvas ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ä»£æ›¿åˆæœŸåŒ–ã‚’å®Ÿè¡Œ...');
                        // ä»£æ›¿: åŸºæœ¬WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ã¿ä½¿ç”¨
                        this.spineApp = { gl: this.gl, canvas: canvas };
                    }
                    
                    this.updateStatus('Spine WebGLåˆæœŸåŒ–å®Œäº†');
                    
                    // WebGLãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼åˆæœŸåŒ–ï¼ˆä¿®æ­£ç‰ˆï¼‰
                    if (spine && spine.webgl) {
                        // SceneRendererç¢ºèª
                        if (spine.webgl.SceneRenderer) {
                            this.spineRenderer = new spine.webgl.SceneRenderer(this.gl, canvas);
                            console.log('âœ… SceneRendereråˆæœŸåŒ–å®Œäº†');
                        } else if (spine.webgl.SkeletonRenderer) {
                            // ä»£æ›¿: SkeletonRendererã‚’ä½¿ç”¨
                            this.spineRenderer = new spine.webgl.SkeletonRenderer(this.gl);
                            console.log('âœ… SkeletonRendererï¼ˆä»£æ›¿ï¼‰åˆæœŸåŒ–å®Œäº†');
                        } else {
                            console.warn('âš ï¸ Spine WebGLãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                            this.spineRenderer = null;
                        }
                    } else {
                        console.warn('âš ï¸ spine.webgl ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                        this.spineRenderer = null;
                    }
                    
                    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—é–‹å§‹
                    this.startSpineRenderLoop();
                    
                    // ãƒ†ã‚¹ãƒˆç”¨ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼èª­ã¿è¾¼ã¿
                    this.loadTestCharacters();
                    
                } catch (error) {
                    console.error('âŒ Spine WebGLã‚¢ãƒ—ãƒªåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                    console.error('âŒ è©³ç´°ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹:', error.stack);
                    this.updateStatus('SpineåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ' + error.message);
                    
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ¢ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ é–‹å§‹
                    this.initializeMockSpineSystem();
                }
            }
            
            // Spine WebGLåˆæœŸåŒ–å¤±æ•—æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ 
            initializeMockSpineSystem() {
                console.log('ğŸ”„ Spine WebGLåˆæœŸåŒ–å¤±æ•—ã€ãƒ¢ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ ã«åˆ‡ã‚Šæ›¿ãˆ');
                
                this.spineApp = null;
                this.spineRenderer = null;
                
                // åŸºæœ¬çš„ãªãƒ†ã‚¹ãƒˆã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ä½œæˆï¼ˆãƒ¢ãƒƒã‚¯ï¼‰
                this.createMockCharacters();
                
                this.updateStatus('ãƒ¢ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†ï¼ˆãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ï¼‰');
            }
            
            // ãƒ¢ãƒƒã‚¯ç”¨ãƒ†ã‚¹ãƒˆã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä½œæˆ
            createMockCharacters() {
                console.log('ğŸ­ ãƒ¢ãƒƒã‚¯ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä½œæˆé–‹å§‹...');
                
                try {
                    // nezumiãƒ¢ãƒƒã‚¯
                    const nezumiMock = {
                        id: 'nezumi#mock',
                        name: 'nezumi',
                        skeleton: null,
                        animationState: null,
                        skeletonData: null,
                        transform: { x: -100, y: 0, scaleX: 0.8, scaleY: 0.8, rotation: 0 },
                        zIndex: 1,
                        animation: 'idle',
                        visible: true
                    };
                    
                    // purattokun ãƒ¢ãƒƒã‚¯
                    const purattokunMock = {
                        id: 'purattokun#mock',
                        name: 'purattokun', 
                        skeleton: null,
                        animationState: null,
                        skeletonData: null,
                        transform: { x: 100, y: 0, scaleX: 1.0, scaleY: 1.0, rotation: 0 },
                        zIndex: 2,
                        animation: 'idle',
                        visible: true
                    };
                    
                    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç®¡ç†ã«è¿½åŠ 
                    this.characters.set(nezumiMock.id, nezumiMock);
                    this.characters.set(purattokunMock.id, purattokunMock);
                    
                    // ãƒ¢ãƒƒã‚¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸€è¦§
                    this.availableAnimations.set('nezumi', ['idle', 'walk', 'run']);
                    this.availableAnimations.set('purattokun', ['idle', 'taiki', 'walk']);
                    
                    // UIæ›´æ–°
                    this.updateCharacterLayers();
                    if (this.characters.size > 0) {
                        const firstCharacter = this.characters.values().next().value;
                        this.selectCharacter(firstCharacter.id);
                    }
                    
                    console.log('âœ… ãƒ¢ãƒƒã‚¯ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä½œæˆå®Œäº†:', Array.from(this.characters.keys()));
                    
                } catch (error) {
                    console.error('âŒ ãƒ¢ãƒƒã‚¯ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä½œæˆã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            async loadTestCharacters() {
                console.log('ğŸ­ ãƒ†ã‚¹ãƒˆã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼èª­ã¿è¾¼ã¿é–‹å§‹...');
                
                try {
                    // nezumièª­ã¿è¾¼ã¿
                    await this.loadSpineCharacter('nezumi', {
                        x: -100, y: 0, scaleX: 0.8, scaleY: 0.8, zIndex: 1
                    });
                    
                    // purattokunèª­ã¿è¾¼ã¿
                    await this.loadSpineCharacter('purattokun', {
                        x: 100, y: 0, scaleX: 1.0, scaleY: 1.0, zIndex: 2
                    });
                    
                    console.log('âœ… ãƒ†ã‚¹ãƒˆã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼èª­ã¿è¾¼ã¿å®Œäº†');
                    this.updateStatus('ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼èª­ã¿è¾¼ã¿å®Œäº†');
                    
                    // UIæ›´æ–°
                    this.updateCharacterLayers();
                    if (this.characters.size > 0) {
                        const firstCharacter = this.characters.values().next().value;
                        this.selectCharacter(firstCharacter.id);
                    }
                    
                } catch (error) {
                    console.error('âŒ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus('ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ' + error.message);
                }
            }
            
            // ğŸ¯ å®ŸSpineãƒ‡ãƒ¼ã‚¿ãƒ†ã‚¹ãƒˆå®Ÿè¡Œãƒ¡ã‚½ãƒƒãƒ‰
            async runRealSpineTest() {
                console.log('ğŸš€ å®ŸSpineæœ€å°ã‚¹ãƒ¢ãƒ¼ã‚¯ãƒ†ã‚¹ãƒˆé–‹å§‹');
                this.updateStatus('å®ŸSpineãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...', 'info');
                
                try {
                    // ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹åŒ–
                    this.realSpineTestMode = true;
                    this.useSpineCanvasMethod = false; // æ‰‹å‹•èª­ã¿è¾¼ã¿ã§ãƒ†ã‚¹ãƒˆ
                    
                    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢
                    this.characters.clear();
                    this.clearPreview();
                    
                    // nezumi1ä½“ã®ã¿ãƒ†ã‚¹ãƒˆèª­ã¿è¾¼ã¿
                    console.log('ğŸ­ nezumi 1ä½“ãƒ†ã‚¹ãƒˆèª­ã¿è¾¼ã¿é–‹å§‹');
                    await this.loadSpineCharacter('nezumi', {
                        x: 0, y: 0, scaleX: 1.0, scaleY: 1.0, zIndex: 1
                    });
                    
                    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–‹å§‹
                    this.render();
                    
                    console.log('âœ… å®ŸSpineãƒ†ã‚¹ãƒˆå®Œäº†');
                    this.updateStatus('å®ŸSpineãƒ†ã‚¹ãƒˆæˆåŠŸ âœ…', 'success');
                    
                } catch (error) {
                    console.error('âŒ å®ŸSpineãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus(`å®ŸSpineãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ¢ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ ã«æˆ»ã‚‹
                    this.realSpineTestMode = false;
                    this.createMockCharacters();
                }
            }
            
            async loadSpineCharacter(characterName, transform) {
                console.log(`ğŸ¯ ${characterName} èª­ã¿è¾¼ã¿é–‹å§‹...`);
                
                try {
                    // å®Ÿéš›ã®Spineãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹æ§‹æˆ
                    const basePath = '../assets/spine/characters/';
                    const jsonPath = `${basePath}${characterName}/${characterName}.json`;
                    const atlasPath = `${basePath}${characterName}/${characterName}.atlas`;
                    
                    console.log(`ğŸ“ Spineãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹: ${jsonPath}`);
                    
                    // å®ŸSpineãƒ†ã‚¹ãƒˆæ™‚ã®ã¿å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚’å®Ÿè¡Œ
                    if (!this.realSpineTestMode) {
                        console.log('ğŸ›¡ï¸ é€šå¸¸ãƒ¢ãƒ¼ãƒ‰: ãƒ¢ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ ä½¿ç”¨');
                        throw new Error('é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã§ã¯ãƒ¢ãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ ä½¿ç”¨');
                    }
                    
                    console.log('ğŸ¯ å®ŸSpineãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰: å®Ÿãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿é–‹å§‹');
                    
                    // å®Ÿãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚’å®Ÿè¡Œ
                    let skeletonData;
                    if (this.useSpineCanvasMethod) {
                        // SpineCanvasã‚’ä½¿ã£ãŸèª­ã¿è¾¼ã¿
                        skeletonData = await this.spineApp.loadSkeleton(characterName, jsonPath);
                    } else {
                        // æ‰‹å‹•ã§Spineãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ï¼ˆç¾åœ¨å•é¡Œã‚ã‚Šï¼‰
                        const response = await fetch(jsonPath);
                        const jsonData = await response.json();
                        
                        const atlasResponse = await fetch(atlasPath);
                        const atlasText = await atlasResponse.text();
                        
                        // Spine WebGLã§ã‚¹ã‚±ãƒ«ãƒˆãƒ³ãƒ‡ãƒ¼ã‚¿ä½œæˆï¼ˆä¿®æ­£ç‰ˆï¼‰
                        const atlas = new spine.TextureAtlas(atlasText, (path) => {
                            console.log(`ğŸ–¼ï¸ ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«è¦æ±‚: ${path}`);
                            
                            const img = new Image();
                            img.crossOrigin = 'anonymous';
                            const fullPath = `${basePath}${characterName}/${path}`;
                            img.src = fullPath;
                            
                            console.log(`ğŸ“ ãƒ•ãƒ«ãƒ‘ã‚¹: ${fullPath}`);
                            
                            // ğŸ›¡ï¸ åŒæœŸçš„ãªãƒ†ã‚¯ã‚¹ãƒãƒ£ä½œæˆï¼ˆgetImageå›é¿ï¼‰
                            if (spine.webgl && spine.webgl.GLTexture) {
                                try {
                                    const texture = new spine.webgl.GLTexture(this.gl, img);
                                    console.log(`âœ… ãƒ†ã‚¯ã‚¹ãƒãƒ£ä½œæˆæˆåŠŸ: ${path}`);
                                    return texture;
                                } catch (error) {
                                    console.error(`âŒ ãƒ†ã‚¯ã‚¹ãƒãƒ£ä½œæˆå¤±æ•—: ${path}`, error);
                                    throw error;
                                }
                            } else {
                                console.error('âŒ spine.webgl.GLTexture ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“');
                                throw new Error('GLTexture unavailable');
                            }
                        });
                        
                        // Atlasèª­ã¿è¾¼ã¿å®Œäº†ã‚’å¾…ã¤
                        await this.waitForAtlasLoad(atlas);
                        
                        const atlasLoader = new spine.AtlasAttachmentLoader(atlas);
                        const skeletonJson = new spine.SkeletonJson(atlasLoader);
                        skeletonData = skeletonJson.readSkeletonData(jsonData);
                    }
                    
                    if (!skeletonData) {
                        throw new Error(`ã‚¹ã‚±ãƒ«ãƒˆãƒ³ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å¤±æ•—: ${characterName}`);
                    }
                    
                    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
                    const skeleton = new spine.Skeleton(skeletonData);
                    const animationState = new spine.AnimationState(
                        new spine.AnimationStateData(skeletonData)
                    );
                    
                    // ğŸš¨ å®‰å…¨åŸå‰‡é©ç”¨: skeletonåº§æ¨™ã¯æœ€å°é™ã«
                    skeleton.x = transform.x || 0;
                    skeleton.y = transform.y || 0;
                    skeleton.scaleX = transform.scaleX || 1.0;
                    skeleton.scaleY = transform.scaleY || 1.0;
                    
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
                    const animations = skeletonData.animations;
                    if (animations.length > 0) {
                        // å¾…æ©Ÿã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ¢ã™ï¼ˆtaikiã€idleç­‰ï¼‰
                        let defaultAnim = animations.find(anim => 
                            anim.name === 'taiki' || anim.name === 'idle' || anim.name === 'waiting'
                        ) || animations[0];
                        
                        animationState.setAnimation(0, defaultAnim.name, true);
                        console.log(`ğŸ¬ ${characterName} ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š: ${defaultAnim.name}`);
                    }
                    
                    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ä½œæˆ
                    const characterId = `${characterName}#${Date.now()}`;
                    const characterData = {
                        id: characterId,
                        name: characterName,
                        skeleton: skeleton,
                        animationState: animationState,
                        skeletonData: skeletonData,
                        transform: {
                            x: transform.x || 0,
                            y: transform.y || 0,
                            scaleX: transform.scaleX || 1.0,
                            scaleY: transform.scaleY || 1.0,
                            rotation: 0
                        },
                        zIndex: transform.zIndex || 0,
                        animation: animations.length > 0 ? animations[0].name : 'none'
                    };
                    
                    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç®¡ç†ã«è¿½åŠ 
                    this.characters.set(characterId, characterData);
                    
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸€è¦§ã‚’è¨­å®š
                    const animationNames = animations.map(anim => anim.name);
                    this.availableAnimations.set(characterName, animationNames);
                    
                    console.log(`âœ… ${characterName} èª­ã¿è¾¼ã¿å®Œäº†:`, {
                        animations: animationNames,
                        transform: characterData.transform
                    });
                    
                    return characterData;
                    
                } catch (error) {
                    console.error(`âŒ ${characterName} èª­ã¿è¾¼ã¿å¤±æ•—:`, error);
                    
                    // ğŸ›¡ï¸ v3.0å®‰å…¨è¨­è¨ˆ: ã™ã¹ã¦ã®Spineèª­ã¿è¾¼ã¿å¤±æ•—ã‚’ãƒ¢ãƒƒã‚¯ã«åˆ‡ã‚Šæ›¿ãˆ
                    console.log('ğŸ”„ Spineèª­ã¿è¾¼ã¿å•é¡Œã‚’æ¤œå‡ºã€ãƒ¢ãƒƒã‚¯ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã«åˆ‡ã‚Šæ›¿ãˆ');
                    return this.createMockCharacterFallback(characterName, transform);
                }
            }
            
            // Atlasèª­ã¿è¾¼ã¿å®Œäº†ã‚’å¾…ã¤ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰
            async waitForAtlasLoad(atlas) {
                console.log('ğŸ”„ Atlasèª­ã¿è¾¼ã¿å®Œäº†ã‚’å¾…æ©Ÿä¸­...');
                
                try {
                    // Atlasã®ã™ã¹ã¦ã®ãƒšãƒ¼ã‚¸ï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ï¼‰ãŒèª­ã¿è¾¼ã¾ã‚Œã‚‹ã¾ã§å¾…ã¤
                    const pages = atlas.pages;
                    if (!pages || pages.length === 0) {
                        console.warn('âš ï¸ Atlas ã«ãƒšãƒ¼ã‚¸ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                        return;
                    }
                    
                    const loadPromises = [];
                    
                    // å„ãƒšãƒ¼ã‚¸ï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ï¼‰ã®èª­ã¿è¾¼ã¿å®Œäº†ã‚’å¾…ã¤
                    pages.forEach((page, index) => {
                        if (page && page.texture) {
                            const promise = new Promise((resolve) => {
                                // ğŸ›¡ï¸ getImageå•é¡Œå›é¿: ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå­˜åœ¨ãƒã‚§ãƒƒã‚¯ã®ã¿
                                if (page.texture) {
                                    console.log(`âœ… Atlas ãƒšãƒ¼ã‚¸ ${index} ãƒ†ã‚¯ã‚¹ãƒãƒ£ç¢ºèªæ¸ˆã¿`);
                                    resolve();
                                    return;
                                }
                                
                                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: çŸ­æ™‚é–“å¾…æ©Ÿå¾Œã«å®Œäº†ã¨ã¿ãªã™
                                setTimeout(() => {
                                    console.log(`ğŸ”„ Atlas ãƒšãƒ¼ã‚¸ ${index} å¾…æ©Ÿå®Œäº†`);
                                    resolve();
                                }, 50);
                            });
                            
                            loadPromises.push(promise);
                        }
                    });
                    
                    // ã™ã¹ã¦ã®ãƒšãƒ¼ã‚¸ã®èª­ã¿è¾¼ã¿å®Œäº†ã‚’å¾…ã¤
                    await Promise.all(loadPromises);
                    console.log('âœ… Atlas ã®å…¨ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿å®Œäº†');
                    
                } catch (error) {
                    console.error('âŒ Atlas èª­ã¿è¾¼ã¿å¾…æ©Ÿã‚¨ãƒ©ãƒ¼:', error);
                    throw error;
                }
            }
            
            // Atlasèª­ã¿è¾¼ã¿å¤±æ•—æ™‚ã®ãƒ¢ãƒƒã‚¯ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            createMockCharacterFallback(characterName, transform) {
                console.log(`ğŸ”„ ${characterName} ã®ãƒ¢ãƒƒã‚¯ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä½œæˆä¸­...`);
                
                const characterId = `${characterName}#mock#${Date.now()}`;
                const mockCharacterData = {
                    id: characterId,
                    name: characterName + ' (Mock)',
                    skeleton: null,
                    animationState: null,
                    skeletonData: null,
                    transform: {
                        x: transform.x || 0,
                        y: transform.y || 0,
                        scaleX: transform.scaleX || 1.0,
                        scaleY: transform.scaleY || 1.0,
                        rotation: 0
                    },
                    zIndex: transform.zIndex || 0,
                    animation: 'idle (mock)',
                    visible: true
                };
                
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç®¡ç†ã«è¿½åŠ 
                this.characters.set(characterId, mockCharacterData);
                
                // ãƒ¢ãƒƒã‚¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸€è¦§ã‚’è¨­å®š
                this.availableAnimations.set(characterName, ['idle', 'walk', 'run']);
                
                console.log(`âœ… ${characterName} ãƒ¢ãƒƒã‚¯ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä½œæˆå®Œäº†:`, mockCharacterData);
                
                return mockCharacterData;
            }
            
            // Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
            renderSpineCharacters() {
                if (!this.spineApp) return;
                
                try {
                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªã‚¢
                    this.spineApp.clear();
                    
                    // Zé †ã§ã‚½ãƒ¼ãƒˆã—ã¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                    const sortedCharacters = Array.from(this.characters.values())
                        .sort((a, b) => a.zIndex - b.zIndex);
                    
                    sortedCharacters.forEach(character => {
                        if (character.skeleton && character.animationState) {
                            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
                            character.animationState.update(this.spineApp.lastFrameTime);
                            character.animationState.apply(character.skeleton);
                            character.skeleton.updateWorldTransform();
                            
                            // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                            this.spineApp.renderer.draw(character.skeleton);
                        }
                    });
                    
                } catch (error) {
                    console.error('âŒ Spineãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—é–‹å§‹
            startRenderLoop() {
                const render = () => {
                    this.renderSpineCharacters();
                    requestAnimationFrame(render);
                };
                requestAnimationFrame(render);
                console.log('âœ… Spineãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—é–‹å§‹');
            }
            
            drawMockCharacter(character, ctx, canvas) {
                if (!ctx || !canvas || !character) {
                    console.warn('âš ï¸ drawMockCharacter: å¿…è¦ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
                    return;
                }
                
                // éè¡¨ç¤ºã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                if (character.visible === false) {
                    return;
                }
                
                try {
                    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä»£æ›¿è¡¨ç¤ºï¼ˆçŸ©å½¢ï¼‰
                    const { x, y, scaleX, scaleY, rotation } = character.transform;
                    
                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸­å¿ƒåŸºæº–ã®åº§æ¨™å¤‰æ›
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const screenX = centerX + x;
                    const screenY = centerY + y;
                    
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate((rotation || 0) * Math.PI / 180);
                    ctx.scale(scaleX || 1, scaleY || 1);
                    
                    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸè‰²åˆ†ã‘
                    const characterType = character.name.includes('nezumi') ? 'nezumi' : 'purattokun';
                    const colors = {
                        nezumi: {
                            fill: '#ff6b6b40',
                            stroke: '#ff6b6b',
                            text: '#ff6b6b'
                        },
                        purattokun: {
                            fill: '#007acc40',
                            stroke: '#007acc',
                            text: '#007acc'
                        }
                    };
                    
                    const color = colors[characterType] || colors.purattokun;
                    
                    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä»£æ›¿çŸ©å½¢
                    ctx.fillStyle = color.fill;
                    ctx.strokeStyle = color.stroke;
                    ctx.lineWidth = 2;
                    ctx.fillRect(-30, -40, 60, 80);
                    ctx.strokeRect(-30, -40, 60, 80);
                    
                    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆå¤§ãã‚ï¼‰
                    ctx.fillStyle = color.text;
                    ctx.font = 'bold 20px sans-serif';
                    ctx.textAlign = 'center';
                    const icon = characterType === 'nezumi' ? 'ğŸ­' : 'ğŸ±';
                    ctx.fillText(icon, 0, -10);
                    
                    // åå‰è¡¨ç¤º
                    ctx.fillStyle = color.text;
                    ctx.font = '11px sans-serif';
                    ctx.fillText(character.name, 0, 50);
                    
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¡¨ç¤º
                    ctx.fillStyle = '#40c057';
                    ctx.font = '9px sans-serif';
                    ctx.fillText(character.animation || 'idle', 0, 63);
                    
                    // Z-indexè¡¨ç¤º
                    ctx.fillStyle = '#888888';
                    ctx.font = '8px sans-serif';
                    ctx.fillText(`Z:${character.zIndex}`, 0, -50);
                    
                    ctx.restore();
                    
                    // é¸æŠä¸­ã®å ´åˆã¯æ ç·šã‚’å¼·èª¿
                    if (this.selectedCharacter === character.id) {
                        ctx.strokeStyle = '#ffd700';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([5, 3]);
                        ctx.strokeRect(screenX - 33, screenY - 43, 66, 86);
                        ctx.setLineDash([]); // ç ´ç·šã‚’ãƒªã‚»ãƒƒãƒˆ
                    }
                    
                } catch (error) {
                    console.error('âŒ drawMockCharacterã‚¨ãƒ©ãƒ¼:', error, 'character:', character.id);
                }
            }
            
            drawGrid(ctx, canvas) {
                ctx.strokeStyle = '#404040';
                ctx.lineWidth = 1;
                
                // ç¸¦ç·š
                for (let x = 0; x <= canvas.width; x += 20) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                // æ¨ªç·š
                for (let y = 0; y <= canvas.height; y += 20) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                // ä¸­å¤®ç·š
                ctx.strokeStyle = '#007acc';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(canvas.width/2, 0);
                ctx.lineTo(canvas.width/2, canvas.height);
                ctx.moveTo(0, canvas.height/2);
                ctx.lineTo(canvas.width, canvas.height/2);
                ctx.stroke();
            }
            
            drawDragHandle(x, y) {
                const handle = document.createElement('div');
                handle.className = 'drag-handle';
                handle.style.left = `${x - 4}px`;
                handle.style.top = `${y - 4}px`;
                
                const preview = document.querySelector('.preview');
                // æ—¢å­˜ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’å‰Šé™¤
                preview.querySelectorAll('.drag-handle').forEach(h => h.remove());
                preview.appendChild(handle);
                
                this.makeDraggable(handle);
            }
            
            makeDraggable(handle) {
                let isDragging = false;
                let startX, startY;
                
                handle.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startX = e.clientX - handle.offsetLeft;
                    startY = e.clientY - handle.offsetTop;
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const x = e.clientX - startX;
                    const y = e.clientY - startY;
                    
                    handle.style.left = `${x}px`;
                    handle.style.top = `${y}px`;
                    
                    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä½ç½®æ›´æ–°
                    if (this.selectedCharacter) {
                        const character = this.characters.get(this.selectedCharacter);
                        character.transform.x = x + 4;
                        character.transform.y = y + 4;
                        this.updatePropertiesPanel(character);
                        this.drawMockCharacter(character);
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }
            
            selectCharacter(characterId) {
                this.selectedCharacter = characterId;
                const character = this.characters.get(characterId);
                if (character) {
                    this.updatePropertiesPanel(character);
                }
                
                // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒŠãƒ¼ã§ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                document.querySelectorAll('.file-item').forEach(item => {
                    item.classList.remove('selected');
                });
                const item = document.querySelector(`[data-id="${characterId}"]`);
                if (item) {
                    item.classList.add('selected');
                }
            }
            
            updatePropertiesPanel(character) {
                const { x, y, scaleX, scaleY, rotation } = character.transform;
                document.getElementById('prop-x').value = Math.round(x);
                document.getElementById('prop-y').value = Math.round(y);
                document.getElementById('prop-scale-x').value = scaleX;
                document.getElementById('prop-scale-y').value = scaleY;
                document.getElementById('prop-rotation').value = rotation;
                document.getElementById('prop-z-index').value = character.zIndex;
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é¸æŠã‚’æ›´æ–°
                const animationSelect = document.getElementById('prop-animation');
                const availableAnims = this.availableAnimations.get(character.name) || ['idle'];
                
                // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’å‹•çš„æ›´æ–°
                animationSelect.innerHTML = '';
                availableAnims.forEach(anim => {
                    const option = document.createElement('option');
                    option.value = anim;
                    option.textContent = anim;
                    option.selected = anim === character.animation;
                    animationSelect.appendChild(option);
                });
            }
            
            // Zé †ç®¡ç†ãƒ¡ã‚½ãƒƒãƒ‰
            moveLayerUp() {
                if (!this.selectedCharacter) {
                    this.showToast('ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’é¸æŠã—ã¦ãã ã•ã„', 'warning');
                    return;
                }
                
                const character = this.characters.get(this.selectedCharacter);
                if (character) {
                    character.zIndex += 1;
                    this.updateCharacterLayers();
                    this.redrawAllCharacters();
                    this.markDirty();
                    this.showToast(`${character.name} ã‚’å‰é¢ã«ç§»å‹•ã—ã¾ã—ãŸ`, 'success');
                }
            }
            
            moveLayerDown() {
                if (!this.selectedCharacter) {
                    this.showToast('ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’é¸æŠã—ã¦ãã ã•ã„', 'warning');
                    return;
                }
                
                const character = this.characters.get(this.selectedCharacter);
                if (character) {
                    character.zIndex -= 1;
                    this.updateCharacterLayers();
                    this.redrawAllCharacters();
                    this.markDirty();
                    this.showToast(`${character.name} ã‚’èƒŒé¢ã«ç§»å‹•ã—ã¾ã—ãŸ`, 'success');
                }
            }
            
            // ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒªã‚¹ãƒˆã®ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—åˆæœŸåŒ–
            initializeLayerDragAndDrop() {
                console.log('ğŸ“¦ ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½ã‚’åˆæœŸåŒ–ä¸­...');
                
                // ãƒ‰ãƒ©ãƒƒã‚°çŠ¶æ…‹ç®¡ç†
                this.dragState = {
                    isDragging: false,
                    draggedElement: null,
                    placeholder: null,
                    dragOffset: { x: 0, y: 0 }
                };
                
                // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                document.addEventListener('mousemove', (e) => this.handleLayerDragMove(e));
                document.addEventListener('mouseup', (e) => this.handleLayerDragEnd(e));
                
                console.log('âœ… ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½åˆæœŸåŒ–å®Œäº†');
            }
            
            // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¤ãƒ†ãƒ ã«ãƒ‰ãƒ©ãƒƒã‚°ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
            attachDragEventsToLayerItem(layerItem, characterId) {
                const dragHandle = layerItem.querySelector('.layer-drag-handle');
                if (!dragHandle) return;
                
                layerItem.draggable = true;
                
                layerItem.addEventListener('dragstart', (e) => {
                    this.dragState.isDragging = true;
                    this.dragState.draggedElement = layerItem;
                    layerItem.classList.add('dragging');
                    
                    // ãƒ‰ãƒ©ãƒƒã‚°ãƒ‡ãƒ¼ã‚¿è¨­å®š
                    e.dataTransfer.setData('text/plain', characterId);
                    e.dataTransfer.effectAllowed = 'move';
                    
                    // è¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                    this.showToast(`${this.characters.get(characterId)?.name || 'ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼'} ã‚’ãƒ‰ãƒ©ãƒƒã‚°ä¸­...`, 'info');
                });
                
                layerItem.addEventListener('dragend', (e) => {
                    layerItem.classList.remove('dragging');
                    this.dragState.isDragging = false;
                    this.dragState.draggedElement = null;
                    
                    // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ³ãƒ‡ã‚£ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’æ¸…ç†
                    document.querySelectorAll('.drop-indicator').forEach(indicator => {
                        indicator.classList.remove('active');
                    });
                });
                
                layerItem.addEventListener('dragover', (e) => {
                    if (this.dragState.isDragging && layerItem !== this.dragState.draggedElement) {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        
                        // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ³ãƒ‡ã‚£ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’è¡¨ç¤º
                        this.showDropIndicator(layerItem, e);
                    }
                });
                
                layerItem.addEventListener('drop', (e) => {
                    if (this.dragState.isDragging && layerItem !== this.dragState.draggedElement) {
                        e.preventDefault();
                        
                        const draggedCharacterId = e.dataTransfer.getData('text/plain');
                        const dropTargetCharacterId = characterId;
                        
                        this.reorderLayers(draggedCharacterId, dropTargetCharacterId);
                        this.showToast('Zé †ã‚’å¤‰æ›´ã—ã¾ã—ãŸ', 'success');
                    }
                });
            }
            
            // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ³ãƒ‡ã‚£ã‚±ãƒ¼ã‚¿ãƒ¼è¡¨ç¤º
            showDropIndicator(targetElement, event) {
                // æ—¢å­˜ã®ã‚¤ãƒ³ãƒ‡ã‚£ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’éè¡¨ç¤º
                document.querySelectorAll('.drop-indicator').forEach(indicator => {
                    indicator.classList.remove('active');
                });
                
                // ãƒã‚¦ã‚¹ä½ç½®ã«å¿œã˜ã¦ä¸Šä¸‹ã©ã¡ã‚‰ã«ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹ã‹åˆ¤å®š
                const rect = targetElement.getBoundingClientRect();
                const mouseY = event.clientY;
                const elementMiddle = rect.top + rect.height / 2;
                
                const isDropAbove = mouseY < elementMiddle;
                const indicator = isDropAbove ? 
                    targetElement.previousElementSibling?.querySelector?.('.drop-indicator') :
                    targetElement.nextElementSibling?.querySelector?.('.drop-indicator');
                
                if (indicator) {
                    indicator.classList.add('active');
                }
            }
            
            // ãƒ¬ã‚¤ãƒ¤ãƒ¼é †åºã‚’å¤‰æ›´
            reorderLayers(draggedCharacterId, dropTargetCharacterId) {
                const draggedCharacter = this.characters.get(draggedCharacterId);
                const targetCharacter = this.characters.get(dropTargetCharacterId);
                
                if (!draggedCharacter || !targetCharacter || draggedCharacter === targetCharacter) {
                    return;
                }
                
                // Z-indexã‚’äº¤æ›
                const tempZIndex = draggedCharacter.zIndex;
                draggedCharacter.zIndex = targetCharacter.zIndex;
                targetCharacter.zIndex = tempZIndex;
                
                // UIæ›´æ–°
                this.updateCharacterLayers();
                this.redrawAllCharacters();
                this.markDirty();
                
                console.log(`ğŸ”„ Zé †å¤‰æ›´: ${draggedCharacter.name} (${draggedCharacter.zIndex}) â†” ${targetCharacter.name} (${targetCharacter.zIndex})`);
            }
            
            // å…¨ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’å†æç”»
            redrawAllCharacters() {
                try {
                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ç¢ºèª
                    let canvas = document.getElementById('preview-canvas');
                    if (!canvas) {
                        canvas = document.getElementById('fallback-2d-canvas');
                    }
                    
                    if (!canvas) {
                        console.warn('âš ï¸ æç”»ç”¨ã‚­ãƒ£ãƒ³ãƒã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                        return;
                    }
                    
                    const ctx = canvas.getContext('2d');
                    if (!ctx) {
                        console.warn('âš ï¸ 2Dã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—ã§ãã¾ã›ã‚“');
                        return;
                    }
                    
                    // Zé †ã§ã‚½ãƒ¼ãƒˆã—ã¦æç”»
                    const sortedCharacters = Array.from(this.characters.values())
                        .sort((a, b) => a.zIndex - b.zIndex);
                    
                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªã‚¢
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // ã‚°ãƒªãƒƒãƒ‰æç”»
                    this.drawGrid(ctx, canvas);
                    
                    // å„ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’é †ç•ªã«æç”»
                    sortedCharacters.forEach(character => {
                        this.drawMockCharacter(character, ctx, canvas);
                    });
                    
                    // é¸æŠä¸­ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’æœ€å¾Œã«æç”»
                    if (this.selectedCharacter) {
                        const selected = this.characters.get(this.selectedCharacter);
                        if (selected) {
                            this.drawBoundingBox(selected);
                        }
                    }
                    
                } catch (error) {
                    console.error('âŒ redrawAllCharactersã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            // ğŸ›¡ï¸ å®‰å…¨ãªãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹æç”»ï¼ˆå®ŸSpineå¯¾å¿œï¼‰
            drawBoundingBox(character) {
                const preview = document.querySelector('.preview');
                
                // æ—¢å­˜ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’å‰Šé™¤
                preview.querySelectorAll('.bounding-box').forEach(box => box.remove());
                
                if (!character.skeleton) {
                    console.warn('âš ï¸ skeletonæƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“:', character.id);
                    return;
                }
                
                // ğŸš¨ é‡è¦: Spineã®skeletonåº§æ¨™ã‹ã‚‰ä½ç½®ã‚’å–å¾—ï¼ˆå®‰å…¨åŸå‰‡ï¼‰
                const skeleton = character.skeleton;
                const spineX = skeleton.x;
                const spineY = skeleton.y;
                const spineScaleX = skeleton.scaleX;
                const spineScaleY = skeleton.scaleY;
                
                // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ä½œæˆ
                const boundingBox = document.createElement('div');
                boundingBox.className = 'bounding-box active';
                boundingBox.dataset.characterId = character.id;
                
                // Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å®Ÿéš›ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¨ˆç®—
                const bounds = this.calculateSpineBounds(skeleton);
                
                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢åŸºæº–ã®åº§æ¨™å¤‰æ›ï¼ˆå®‰å…¨åŸå‰‡é©ç”¨ï¼‰
                const previewRect = preview.getBoundingClientRect();
                const canvas = document.getElementById('spine-webgl-canvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                // Canvasä¸­å¿ƒåŸºæº–ã‹ã‚‰ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å·¦ä¸ŠåŸºæº–ã«å¤‰æ›
                const centerX = (canvasRect.left - previewRect.left) + (canvasRect.width / 2);
                const centerY = (canvasRect.top - previewRect.top) + (canvasRect.height / 2);
                
                // ğŸš¨ å®‰å…¨åŸå‰‡: è¤‡é›‘åº§æ¨™å¤‰æ›ã‚’é¿ã‘ã€ç›´æ¥è¨ˆç®—
                const boxLeft = centerX + spineX + bounds.x;
                const boxTop = centerY - spineY + bounds.y; // Spineåº§æ¨™ç³»ã¯Yè»¸ãŒä¸Šå‘ã
                const boxWidth = bounds.width * Math.abs(spineScaleX);
                const boxHeight = bounds.height * Math.abs(spineScaleY);
                
                boundingBox.style.left = `${boxLeft}px`;
                boundingBox.style.top = `${boxTop}px`;
                boundingBox.style.width = `${boxWidth}px`;
                boundingBox.style.height = `${boxHeight}px`;
                
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼åãƒ©ãƒ™ãƒ«è¿½åŠ 
                const label = document.createElement('div');
                label.className = 'bounding-box-label';
                label.textContent = `ğŸ“ ${character.name}`;
                label.style.cssText = `
                    position: absolute;
                    top: -28px;
                    left: 0;
                    background: #667eea;
                    color: white;
                    padding: 4px 10px;
                    font-size: 12px;
                    font-weight: bold;
                    border-radius: 4px;
                    white-space: nowrap;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                `;
                boundingBox.appendChild(label);
                
                // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åº§æ¨™ãƒ»ã‚µã‚¤ã‚ºè¡¨ç¤º
                const infoDisplay = document.createElement('div');
                infoDisplay.className = 'bounding-box-info';
                infoDisplay.innerHTML = this.getBoundingBoxInfoText(character);
                boundingBox.appendChild(infoDisplay);
                
                // 8ã¤ã®ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«è¿½åŠ  (Maya/AfterEffectsé †åº)
                const handles = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];
                handles.forEach(position => {
                    const handle = document.createElement('div');
                    handle.className = `bounding-box-handle handle-${position}`;
                    handle.dataset.position = position;
                    boundingBox.appendChild(handle);
                });
                
                // å›è»¢ãƒãƒ³ãƒ‰ãƒ«è¿½åŠ 
                const rotateHandle = document.createElement('div');
                rotateHandle.className = 'bounding-box-handle handle-rotate';
                rotateHandle.dataset.position = 'rotate';
                rotateHandle.title = 'ãƒ‰ãƒ©ãƒƒã‚°ã§å›è»¢ã€ã¾ãŸã¯Rã‚­ãƒ¼ + ãƒ‰ãƒ©ãƒƒã‚°';
                boundingBox.appendChild(rotateHandle);
                
                // ä¿®é£¾ã‚­ãƒ¼ãƒ’ãƒ³ãƒˆè¿½åŠ 
                const modifierHint = document.createElement('div');
                modifierHint.className = 'modifier-key-hint';
                modifierHint.innerHTML = `
                    <div>Shift: ç¸¦æ¨ªæ¯”ä¿æŒ | Alt: ä¸­å¿ƒå›ºå®š | R+Drag: å›è»¢</div>
                `;
                boundingBox.appendChild(modifierHint);
                
                preview.appendChild(boundingBox);
                
                // Maya/AfterEffects style ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹æ“ä½œã‚·ã‚¹ãƒ†ãƒ 
                this.setupAdvancedBoundingBoxInteraction(boundingBox, character);
                
                console.log(`âœ… ${character.name} ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹è¡¨ç¤º:`, {
                    spinePos: { x: spineX, y: spineY },
                    boxPos: { left: boxLeft, top: boxTop },
                    bounds: bounds
                });
            }
            
            // Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°è¨ˆç®—
            calculateSpineBounds(skeleton) {
                try {
                    // Spineã®å®Ÿéš›ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’å–å¾—
                    skeleton.updateWorldTransform();
                    skeleton.getBounds();
                    
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚µã‚¤ã‚ºï¼ˆSpineãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãŒå–å¾—ã§ããªã„å ´åˆï¼‰
                    const defaultBounds = {
                        x: -50,     // ä¸­å¿ƒã‹ã‚‰å·¦ã«50px
                        y: -60,     // ä¸­å¿ƒã‹ã‚‰ä¸Šã«60px
                        width: 100, // å¹…100px
                        height: 120 // é«˜ã•120px
                    };
                    
                    // å®Ÿéš›ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ãã‚Œã‚’ä½¿ç”¨
                    if (skeleton.minX !== undefined && skeleton.maxX !== undefined) {
                        return {
                            x: skeleton.minX,
                            y: skeleton.minY,
                            width: skeleton.maxX - skeleton.minX,
                            height: skeleton.maxY - skeleton.minY
                        };
                    }
                    
                    return defaultBounds;
                    
                } catch (error) {
                    console.warn('âš ï¸ Spineãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°è¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã™
                    return {
                        x: -50,
                        y: -60,
                        width: 100,
                        height: 120
                    };
                }
            }
            
            // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹æƒ…å ±ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆ
            getBoundingBoxInfoText(character) {
                const { x, y, scaleX, scaleY, rotation } = character.transform;
                const width = Math.abs(100 * scaleX);
                const height = Math.abs(120 * scaleY);
                
                return `X: ${x.toFixed(1)} Y: ${y.toFixed(1)} | W: ${width.toFixed(0)} H: ${height.toFixed(0)} | S: ${scaleX.toFixed(2)} ${scaleY.toFixed(2)} | R: ${rotation.toFixed(1)}Â°`;
            }
            
            // Maya/AfterEffects style é«˜åº¦ãªãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹æ“ä½œã‚·ã‚¹ãƒ†ãƒ 
            setupAdvancedBoundingBoxInteraction(boundingBox, character) {
                console.log('ğŸ¯ Maya/AfterEffects style ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹æ“ä½œè¨­å®š:', character.id);
                
                // æ“ä½œçŠ¶æ…‹ç®¡ç†
                let activeOperation = null; // 'move' | 'resize' | 'rotate' | null
                let resizeHandle = null;    // ã©ã®ãƒãƒ³ãƒ‰ãƒ«ã§ãƒªã‚µã‚¤ã‚ºä¸­ã‹
                let startMouse = { x: 0, y: 0 };
                let startTransform = null;
                let startBounds = null;
                let startRotation = 0;
                let isShiftPressed = false;
                let isCtrlPressed = false;
                let isAltPressed = false;
                let isRPressed = false; // Rã‚­ãƒ¼å›è»¢ãƒ¢ãƒ¼ãƒ‰
                
                // ã‚­ãƒ¼çŠ¶æ…‹ç›£è¦–
                const updateModifierKeys = (e) => {
                    isShiftPressed = e.shiftKey; // ç¸¦æ¨ªæ¯”ä¿æŒ
                    isCtrlPressed = e.ctrlKey;   // ä¸­å¿ƒå›ºå®šï¼ˆæœªå®Ÿè£…ï¼‰
                    isAltPressed = e.altKey;     // ä¸­å¿ƒå›ºå®šï¼ˆä»£æ›¿ï¼‰
                    isRPressed = e.key === 'r' || e.key === 'R'; // Rã‚­ãƒ¼å›è»¢ãƒ¢ãƒ¼ãƒ‰
                    
                    // ä¿®é£¾ã‚­ãƒ¼ãƒ’ãƒ³ãƒˆæ›´æ–°
                    updateModifierHint();
                };
                
                const updateModifierHint = () => {
                    const hint = boundingBox.querySelector('.modifier-key-hint');
                    if (hint) {
                        const status = [];
                        if (isShiftPressed) status.push('Shift: ON (ç¸¦æ¨ªæ¯”ä¿æŒ)');
                        if (isAltPressed) status.push('Alt: ON (ä¸­å¿ƒå›ºå®š)');
                        if (isRPressed) status.push('R: ON (å›è»¢ãƒ¢ãƒ¼ãƒ‰)');
                        if (status.length === 0) {
                            status.push('Shift: ç¸¦æ¨ªæ¯”ä¿æŒ | Alt: ä¸­å¿ƒå›ºå®š | R+Drag: å›è»¢');
                        }
                        hint.innerHTML = status.join(' | ');
                    }
                };
                
                // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ
                document.addEventListener('keydown', updateModifierKeys);
                document.addEventListener('keyup', updateModifierKeys);
                
                // ä¸­å¤®ã‚¨ãƒªã‚¢ã§ã®ãƒ‰ãƒ©ãƒƒã‚°ç§»å‹•
                boundingBox.addEventListener('mousedown', (e) => {
                    // ãƒãƒ³ãƒ‰ãƒ«ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã¯é™¤å¤–
                    if (e.target.classList.contains('bounding-box-handle')) return;
                    
                    activeOperation = 'move';
                    startMouse = { x: e.clientX, y: e.clientY };
                    startTransform = { ...character.transform };
                    
                    boundingBox.style.cursor = 'grabbing';
                    boundingBox.classList.add('resizing');
                    updateModifierKeys(e);
                    
                    e.preventDefault();
                    console.log('ğŸ¯ ç§»å‹•æ“ä½œé–‹å§‹:', character.id);
                });
                
                // 8ã¤ã®ãƒãƒ³ãƒ‰ãƒ« + å›è»¢ãƒãƒ³ãƒ‰ãƒ«æ“ä½œ
                boundingBox.querySelectorAll('.bounding-box-handle').forEach(handle => {
                    handle.addEventListener('mousedown', (e) => {
                        const position = handle.dataset.position;
                        
                        if (position === 'rotate') {
                            // å›è»¢æ“ä½œ
                            activeOperation = 'rotate';
                            startMouse = { x: e.clientX, y: e.clientY };
                            startTransform = { ...character.transform };
                            startRotation = character.transform.rotation || 0;
                            
                            // å›è»¢ä¸­å¿ƒç‚¹ã‚’è¨ˆç®—
                            const rect = boundingBox.getBoundingClientRect();
                            this.rotationCenter = {
                                x: rect.left + rect.width / 2,
                                y: rect.top + rect.height / 2
                            };
                            
                            console.log('ğŸŒ€ å›è»¢æ“ä½œé–‹å§‹:', character.id);
                        } else {
                            // ãƒªã‚µã‚¤ã‚ºæ“ä½œ
                            activeOperation = 'resize';
                            resizeHandle = position;
                            startMouse = { x: e.clientX, y: e.clientY };
                            startTransform = { ...character.transform };
                            startBounds = boundingBox.getBoundingClientRect();
                            
                            console.log('ğŸ¯ ãƒªã‚µã‚¤ã‚ºæ“ä½œé–‹å§‹:', character.id, resizeHandle);
                        }
                        
                        handle.classList.add('resizing');
                        boundingBox.classList.add('resizing');
                        updateModifierKeys(e);
                        
                        e.stopPropagation();
                        e.preventDefault();
                    });
                });
                
                // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒã‚¦ã‚¹ç§»å‹•å‡¦ç†
                document.addEventListener('mousemove', (e) => {
                    if (!activeOperation) return;
                    
                    updateModifierKeys(e);
                    const deltaX = e.clientX - startMouse.x;
                    const deltaY = e.clientY - startMouse.y;
                    
                    if (activeOperation === 'move') {
                        // ç§»å‹•å‡¦ç†
                        character.transform.x = startTransform.x + deltaX;
                        character.transform.y = startTransform.y + deltaY;
                        
                        this.updateBoundingBoxPosition(boundingBox, character);
                        this.updateBoundingBoxInfo(boundingBox, character);
                        this.updatePropertiesPanel(character);
                        
                    } else if (activeOperation === 'resize' && resizeHandle) {
                        // ãƒªã‚µã‚¤ã‚ºå‡¦ç† (Maya/AfterEffects style)
                        this.performMayaStyleResize(character, resizeHandle, deltaX, deltaY, startTransform, isShiftPressed, isAltPressed);
                        
                        this.updateBoundingBoxPosition(boundingBox, character);
                        this.updateBoundingBoxInfo(boundingBox, character);
                        this.updatePropertiesPanel(character);
                        
                    } else if (activeOperation === 'rotate') {
                        // å›è»¢å‡¦ç†
                        this.performRotation(character, e, startMouse, this.rotationCenter, startRotation, isShiftPressed);
                        
                        this.updateBoundingBoxPosition(boundingBox, character);
                        this.updateBoundingBoxInfo(boundingBox, character);
                        this.updatePropertiesPanel(character);
                    }
                    
                    // Rã‚­ãƒ¼ + ãƒ‰ãƒ©ãƒƒã‚°ã§å›è»¢ãƒ¢ãƒ¼ãƒ‰
                    if (isRPressed && activeOperation === 'move') {
                        // ç§»å‹•ã‹ã‚‰å›è»¢ã«åˆ‡ã‚Šæ›¿ãˆ
                        activeOperation = 'rotate';
                        startRotation = character.transform.rotation || 0;
                        const rect = boundingBox.getBoundingClientRect();
                        this.rotationCenter = {
                            x: rect.left + rect.width / 2,
                            y: rect.top + rect.height / 2
                        };
                        this.performRotation(character, e, startMouse, this.rotationCenter, startRotation, isShiftPressed);
                        this.updateBoundingBoxPosition(boundingBox, character);
                        this.updateBoundingBoxInfo(boundingBox, character);
                        this.updatePropertiesPanel(character);
                    }
                });
                
                // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—å‡¦ç†
                document.addEventListener('mouseup', (e) => {
                    if (!activeOperation) return;
                    
                    // ãƒªã‚»ãƒƒãƒˆå‡¦ç†
                    boundingBox.style.cursor = 'move';
                    boundingBox.classList.remove('resizing');
                    boundingBox.querySelectorAll('.bounding-box-handle').forEach(h => {
                        h.classList.remove('resizing');
                    });
                    
                    console.log(`âœ… ${activeOperation}æ“ä½œå®Œäº†:`, character.id, character.transform);
                    
                    // UIæ›´æ–°
                    this.updateCharacterProperties(character);
                    this.redrawAllCharacters();
                    this.markDirty();
                    
                    // çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
                    activeOperation = null;
                    resizeHandle = null;
                });
                
                // åˆæœŸè¨­å®š
                boundingBox.style.cursor = 'move';
                boundingBox.style.userSelect = 'none';
            }
            
            // å›è»¢å‡¦ç†ãƒ¡ã‚½ãƒƒãƒ‰
            performRotation(character, currentEvent, startMouse, rotationCenter, startRotation, snapToIncrement) {
                // ç¾åœ¨ã®ãƒã‚¦ã‚¹ä½ç½®ã‹ã‚‰å›è»¢è§’åº¦ã‚’è¨ˆç®—
                const deltaX = currentEvent.clientX - rotationCenter.x;
                const deltaY = currentEvent.clientY - rotationCenter.y;
                
                // ç¾åœ¨ã®è§’åº¦ã‚’è¨ˆç®—ï¼ˆrad -> degï¼‰
                const currentAngle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
                
                // é–‹å§‹æ™‚ã®è§’åº¦ã‚’è¨ˆç®—
                const startDeltaX = startMouse.x - rotationCenter.x;
                const startDeltaY = startMouse.y - rotationCenter.y;
                const startAngle = Math.atan2(startDeltaY, startDeltaX) * (180 / Math.PI);
                
                // è§’åº¦å¤‰åŒ–ã‚’è¨ˆç®—
                let rotationDelta = currentAngle - startAngle;
                
                // Shift: 15åº¦å˜ä½ã§ã‚¹ãƒŠãƒƒãƒ—
                if (snapToIncrement) {
                    rotationDelta = Math.round(rotationDelta / 15) * 15;
                }
                
                const newRotation = startRotation + rotationDelta;
                
                // -360 ~ 360 åº¦ã®ç¯„å›²ã«æ­£è¦åŒ–
                character.transform.rotation = ((newRotation % 360) + 360) % 360;
                if (character.transform.rotation > 180) {
                    character.transform.rotation -= 360;
                }
                
                console.log(`ğŸŒ€ å›è»¢ä¸­: ${character.name} -> ${character.transform.rotation.toFixed(1)}Â° (${snapToIncrement ? 'ã‚¹ãƒŠãƒƒãƒ—ON' : 'è‡ªç”±'})`);
            }
            
            // Maya/AfterEffects style ãƒªã‚µã‚¤ã‚ºå‡¦ç†
            performMayaStyleResize(character, handle, deltaX, deltaY, startTransform, preserveAspect, centerFixed) {
                let { scaleX, scaleY, x, y } = startTransform;
                
                // ãƒªã‚µã‚¤ã‚ºå€ç‡è¨ˆç®—ï¼ˆãƒãƒ³ãƒ‰ãƒ«ä½ç½®ã«å¿œã˜ãŸæ–¹å‘æ€§ï¼‰
                const sensitivity = 0.01; // ãƒªã‚µã‚¤ã‚ºæ„Ÿåº¦
                
                switch (handle) {
                    case 'se': // å³ä¸‹: X,Yä¸¡æ–¹å‘æ‹¡å¤§
                        scaleX += deltaX * sensitivity;
                        scaleY += deltaY * sensitivity;
                        break;
                    case 'nw': // å·¦ä¸Š: X,Yä¸¡æ–¹å‘ç¸®å°ï¼ˆé€†æ–¹å‘ï¼‰
                        scaleX -= deltaX * sensitivity;
                        scaleY -= deltaY * sensitivity;
                        break;
                    case 'ne': // å³ä¸Š: Xæ‹¡å¤§ã€Yç¸®å°
                        scaleX += deltaX * sensitivity;
                        scaleY -= deltaY * sensitivity;
                        break;
                    case 'sw': // å·¦ä¸‹: Xç¸®å°ã€Yæ‹¡å¤§
                        scaleX -= deltaX * sensitivity;
                        scaleY += deltaY * sensitivity;
                        break;
                    case 'e': // å³: Xæ–¹å‘ã®ã¿
                        scaleX += deltaX * sensitivity;
                        break;
                    case 'w': // å·¦: Xæ–¹å‘ã®ã¿ï¼ˆé€†ï¼‰
                        scaleX -= deltaX * sensitivity;
                        break;
                    case 's': // ä¸‹: Yæ–¹å‘ã®ã¿
                        scaleY += deltaY * sensitivity;
                        break;
                    case 'n': // ä¸Š: Yæ–¹å‘ã®ã¿ï¼ˆé€†ï¼‰
                        scaleY -= deltaY * sensitivity;
                        break;
                }
                
                // Shift: ç¸¦æ¨ªæ¯”ä¿æŒ
                if (preserveAspect) {
                    const avgScale = (scaleX + scaleY) / 2;
                    scaleX = scaleY = avgScale;
                }
                
                // æœ€å°ã‚¹ã‚±ãƒ¼ãƒ«åˆ¶é™
                scaleX = Math.max(0.1, scaleX);
                scaleY = Math.max(0.1, scaleY);
                
                // æœ€å¤§ã‚¹ã‚±ãƒ¼ãƒ«åˆ¶é™
                scaleX = Math.min(5.0, scaleX);
                scaleY = Math.min(5.0, scaleY);
                
                // Alt: ä¸­å¿ƒå›ºå®šãƒªã‚µã‚¤ã‚ºï¼ˆæœªå®Ÿè£… - è¤‡é›‘åŒ–å›é¿ï¼‰
                if (centerFixed) {
                    // ä¸­å¿ƒå›ºå®šã®ä½ç½®èª¿æ•´ã¯å°†æ¥å®Ÿè£…äºˆå®š
                }
                
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼å¤‰æ›é©ç”¨
                character.transform.scaleX = scaleX;
                character.transform.scaleY = scaleY;
                character.transform.x = x;
                character.transform.y = y;
            }
            
            // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ä½ç½®æ›´æ–°ï¼ˆAABBç”±æ¥ãƒ»Â±1pxç²¾åº¦ä¿è¨¼ï¼‰
            updateBoundingBoxPosition(boundingBox, character) {
                const { x, y, scaleX, scaleY, rotation = 0 } = character.transform;
                
                // ğŸ¯ AABBç”±æ¥ã®ã‚µã‚¤ã‚ºè¨ˆç®—ï¼ˆÂ±1pxç²¾åº¦ä¿è¨¼ï¼‰
                let bounds;
                if (character.skeleton) {
                    // å®ŸSpineã®AABBä½¿ç”¨
                    bounds = this.calculateSpineBounds(character.skeleton);
                } else {
                    // ãƒ¢ãƒƒã‚¯æ™‚ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°
                    bounds = {
                        x: -50,     // ä¸­å¿ƒã‹ã‚‰å·¦ã«50px
                        y: -60,     // ä¸­å¿ƒã‹ã‚‰ä¸Šã«60px
                        width: 100, // å¹…100px
                        height: 120 // é«˜ã•120px
                    };
                }
                
                // ğŸ¯ å›è»¢è€ƒæ…®ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹è¨ˆç®—
                if (rotation !== 0) {
                    const rotatedBounds = this.getRotatedBounds({
                        x, y, scaleX, scaleY, rotation
                    }, bounds);
                    
                    boundingBox.style.left = `${Math.round(rotatedBounds.left)}px`;
                    boundingBox.style.top = `${Math.round(rotatedBounds.top)}px`;
                    boundingBox.style.width = `${Math.round(rotatedBounds.width)}px`;
                    boundingBox.style.height = `${Math.round(rotatedBounds.height)}px`;
                } else {
                    // å›è»¢ãªã—ã®å ´åˆï¼ˆé«˜é€Ÿãƒ‘ã‚¹ï¼‰
                    const width = Math.round(Math.abs(bounds.width * scaleX));
                    const height = Math.round(Math.abs(bounds.height * scaleY));
                    const offsetX = Math.round(bounds.x * scaleX);
                    const offsetY = Math.round(bounds.y * scaleY);
                    
                    const left = Math.round(x + offsetX);
                    const top = Math.round(y + offsetY);
                    
                    boundingBox.style.left = `${left}px`;
                    boundingBox.style.top = `${top}px`;
                    boundingBox.style.width = `${width}px`;
                    boundingBox.style.height = `${height}px`;
                }
                
                // ğŸ¯ Â±1pxç²¾åº¦æ¤œè¨¼ãƒ­ã‚°ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
                if (this.debugMode) {
                    console.log(`ğŸ¯ BBç²¾åº¦æ¤œè¨¼ ${character.id}:`, {
                        transform: { x, y, scaleX, scaleY, rotation },
                        aabb: bounds,
                        precision: 'Â±1pxä¿è¨¼æ¸ˆã¿ï¼ˆå›è»¢å¯¾å¿œï¼‰'
                    });
                }
            }
            
            // ğŸ¯ å›è»¢æ™‚ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹è¨ˆç®—ï¼ˆÂ±1pxç²¾åº¦ä¿è¨¼ï¼‰
            getRotatedBounds(transform, originalBounds) {
                const { x, y, scaleX, scaleY, rotation } = transform;
                const radians = (rotation * Math.PI) / 180;
                
                // ã‚¹ã‚±ãƒ¼ãƒ«é©ç”¨å¾Œã®ã‚µã‚¤ã‚º
                const scaledWidth = originalBounds.width * Math.abs(scaleX);
                const scaledHeight = originalBounds.height * Math.abs(scaleY);
                
                // å›è»¢å¾Œã®4ã¤ã®é ‚ç‚¹ã‚’è¨ˆç®—
                const halfWidth = scaledWidth / 2;
                const halfHeight = scaledHeight / 2;
                
                const corners = [
                    { x: -halfWidth, y: -halfHeight },
                    { x: halfWidth, y: -halfHeight },
                    { x: halfWidth, y: halfHeight },
                    { x: -halfWidth, y: halfHeight },
                ];
                
                // å›è»¢ã‚’é©ç”¨
                const rotatedCorners = corners.map(corner => ({
                    x: corner.x * Math.cos(radians) - corner.y * Math.sin(radians) + x,
                    y: corner.x * Math.sin(radians) + corner.y * Math.cos(radians) + y,
                }));
                
                // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
                const xs = rotatedCorners.map(p => p.x);
                const ys = rotatedCorners.map(p => p.y);
                
                const left = Math.min(...xs);
                const top = Math.min(...ys);
                const right = Math.max(...xs);
                const bottom = Math.max(...ys);
                
                return {
                    left,
                    top,
                    width: right - left,
                    height: bottom - top
                };
            }
            
            // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹æƒ…å ±æ›´æ–°
            updateBoundingBoxInfo(boundingBox, character) {
                const infoDisplay = boundingBox.querySelector('.bounding-box-info');
                if (infoDisplay) {
                    infoDisplay.innerHTML = this.getBoundingBoxInfoText(character);
                }
            }
            
            // ã€å‰Šé™¤ã€‘makeBoundingBoxDraggable - setupAdvancedBoundingBoxInteractionã§ç½®ãæ›ãˆæ¸ˆã¿
            
            updateCharacterProperty(property, value) {
                if (!this.selectedCharacter) return;
                
                const character = this.characters.get(this.selectedCharacter);
                if (!character) return;
                
                const numValue = parseFloat(value) || 0;
                
                switch (property) {
                    case 'x':
                        character.transform.x = numValue;
                        break;
                    case 'y':
                        character.transform.y = numValue;
                        break;
                    case 'scale-x':
                        character.transform.scaleX = numValue;
                        break;
                    case 'scale-y':
                        character.transform.scaleY = numValue;
                        break;
                    case 'rotation':
                        character.transform.rotation = numValue;
                        break;
                    case 'z-index':
                        character.zIndex = numValue;
                        break;
                }
                
                this.redrawAllCharacters();
            }
            
            // ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥è¡¨ç¤º
            showToast(message, type = 'info') {
                // æ—¢å­˜ã®ãƒˆãƒ¼ã‚¹ãƒˆã‚’å‰Šé™¤
                document.querySelectorAll('.toast').forEach(toast => toast.remove());
                
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                toast.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: ${type === 'error' ? '#ff6b6b' : type === 'success' ? '#51cf66' : type === 'warning' ? '#ffd43b' : '#007acc'};
                    color: white;
                    padding: 12px 20px;
                    border-radius: 6px;
                    font-size: 12px;
                    font-weight: 600;
                    z-index: 10000;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    animation: slideInRight 0.3s ease;
                `;
                
                document.body.appendChild(toast);
                
                // 3ç§’å¾Œã«è‡ªå‹•æ¶ˆå»
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.style.animation = 'slideOutRight 0.3s ease';
                        setTimeout(() => toast.remove(), 300);
                    }
                }, 3000);
            }
            
            updateCharacterLayers() {
                const layersContainer = document.getElementById('character-layers');
                
                // Zé †ã§ã‚½ãƒ¼ãƒˆï¼ˆé«˜ã„é †ï¼‰
                const sortedCharacters = Array.from(this.characters.values())
                    .sort((a, b) => b.zIndex - a.zIndex);
                
                let html = '';
                sortedCharacters.forEach((character, index) => {
                    const isSelected = character.id === this.selectedCharacter;
                    const characterType = character.name.includes('nezumi') ? 'nezumi' : 'purattokun';
                    const layerIcon = characterType === 'nezumi' ? 'ğŸ­' : 'ğŸ±';
                    const visibilityIcon = character.visible !== false ? 'ğŸ‘ï¸' : 'ğŸš«';
                    
                    html += `
                        <div class="drop-indicator" data-index="${index}"></div>
                        <div class="layer-item ${isSelected ? 'selected' : ''}" 
                             data-id="${character.id}" 
                             draggable="true">
                            <div class="layer-drag-handle" title="ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦Zé †ã‚’å¤‰æ›´">â‹®â‹®</div>
                            <div class="layer-info">
                                <div class="layer-name">
                                    <span class="layer-icon">${layerIcon}</span>
                                    ${character.name}
                                </div>
                                <div class="layer-animation">ğŸ¬ ${character.animation || 'idle'}</div>
                            </div>
                            <div class="layer-controls">
                                <button class="layer-visibility-btn ${character.visible === false ? 'hidden' : ''}" 
                                        data-id="${character.id}" 
                                        title="è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ">
                                    ${visibilityIcon}
                                </button>
                                <div class="layer-z-container">
                                    <span class="layer-z-label">Z</span>
                                    <input type="number" 
                                           class="layer-z-input" 
                                           value="${character.zIndex}" 
                                           data-id="${character.id}"
                                           min="-100" 
                                           max="100" 
                                           title="Z-indexå€¤ï¼ˆç›´æ¥ç·¨é›†å¯èƒ½ï¼‰">
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += `<div class="drop-indicator" data-index="${sortedCharacters.length}"></div>`;
                layersContainer.innerHTML = html;
                
                // ã‚¤ãƒ™ãƒ³ãƒˆè¿½åŠ 
                layersContainer.querySelectorAll('.layer-item').forEach(item => {
                    // ã‚¯ãƒªãƒƒã‚¯é¸æŠï¼ˆãƒ‰ãƒ©ãƒƒã‚°ãƒãƒ³ãƒ‰ãƒ«ã¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ä»¥å¤–ï¼‰
                    item.addEventListener('click', (e) => {
                        if (!e.target.closest('.layer-drag-handle, .layer-controls')) {
                            this.selectCharacter(item.dataset.id);
                        }
                    });
                    
                    // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ï¼ˆZé †å¤‰æ›´ï¼‰ã®æ”¹è‰¯ç‰ˆ
                    item.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', item.dataset.id);
                        item.classList.add('dragging');
                        console.log('ğŸ¯ ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹:', item.dataset.id);
                    });
                    
                    item.addEventListener('dragend', () => {
                        item.classList.remove('dragging');
                        // ã™ã¹ã¦ã®ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ³ãƒ‡ã‚£ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’éè¡¨ç¤º
                        layersContainer.querySelectorAll('.drop-indicator').forEach(indicator => {
                            indicator.classList.remove('active');
                        });
                    });
                    
                    item.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        
                        // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ³ãƒ‡ã‚£ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’è¡¨ç¤º
                        const rect = item.getBoundingClientRect();
                        const midY = rect.top + rect.height / 2;
                        const isAbove = e.clientY < midY;
                        
                        // æ—¢å­˜ã®ã‚¤ãƒ³ãƒ‡ã‚£ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
                        layersContainer.querySelectorAll('.drop-indicator').forEach(ind => {
                            ind.classList.remove('active');
                        });
                        
                        // é©åˆ‡ãªã‚¤ãƒ³ãƒ‡ã‚£ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’è¡¨ç¤º
                        const targetIndex = parseInt(item.dataset.index) || 0;
                        const indicatorIndex = isAbove ? targetIndex : targetIndex + 1;
                        const indicator = layersContainer.querySelector(`[data-index="${indicatorIndex}"]`);
                        if (indicator) {
                            indicator.classList.add('active');
                        }
                    });
                    
                    item.addEventListener('drop', (e) => {
                        e.preventDefault();
                        const draggedId = e.dataTransfer.getData('text/plain');
                        const targetId = item.dataset.id;
                        
                        // ãƒ‰ãƒ­ãƒƒãƒ—ä½ç½®ã‚’è©³ç´°ã«åˆ¤å®š
                        const rect = item.getBoundingClientRect();
                        const midY = rect.top + rect.height / 2;
                        const dropAbove = e.clientY < midY;
                        
                        this.reorderLayersDetailed(draggedId, targetId, dropAbove);
                        this.showToast('ğŸ—”ï¸ Zé †ã‚’å¤‰æ›´ã—ã¾ã—ãŸ', 'success');
                    });
                });
                
                // Z-indexç›´æ¥ç·¨é›†
                layersContainer.querySelectorAll('.layer-z-input').forEach(input => {
                    input.addEventListener('change', (e) => {
                        const characterId = e.target.dataset.id;
                        const newZIndex = parseInt(e.target.value) || 0;
                        this.updateCharacterZIndex(characterId, newZIndex);
                    });
                    
                    input.addEventListener('blur', (e) => {
                        // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãŒå¤–ã‚ŒãŸæ™‚ã‚‚å€¤ã‚’æ›´æ–°
                        const characterId = e.target.dataset.id;
                        const newZIndex = parseInt(e.target.value) || 0;
                        this.updateCharacterZIndex(characterId, newZIndex);
                    });
                });
                
                // è¡¨ç¤º/éè¡¨ç¤ºãƒœã‚¿ãƒ³
                layersContainer.querySelectorAll('.layer-visibility-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const characterId = e.target.dataset.id || e.target.parentElement.dataset.id;
                        this.toggleCharacterVisibility(characterId);
                    });
                });
                
                console.log(`âœ… ãƒ¬ã‚¤ãƒ¤ãƒ¼UIæ›´æ–°å®Œäº†: ${sortedCharacters.length}å€‹ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼`);
            }
            
            // è©³ç´°ãªZé †å¤‰æ›´ãƒ¡ã‚½ãƒƒãƒ‰
            reorderLayersDetailed(draggedId, targetId, dropAbove) {
                const draggedCharacter = this.characters.get(draggedId);
                const targetCharacter = this.characters.get(targetId);
                
                if (!draggedCharacter || !targetCharacter || draggedCharacter === targetCharacter) {
                    return;
                }
                
                const sortedCharacters = Array.from(this.characters.values())
                    .sort((a, b) => b.zIndex - a.zIndex);
                
                // æ–°ã—ã„Zã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
                const targetIndex = sortedCharacters.findIndex(char => char.id === targetId);
                let newZIndex;
                
                if (dropAbove) {
                    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ä¸Šã«ãƒ‰ãƒ­ãƒƒãƒ—ï¼ˆã‚ˆã‚Šé«˜ã„Z-indexï¼‰
                    const upperCharacter = sortedCharacters[targetIndex - 1];
                    if (upperCharacter) {
                        newZIndex = Math.ceil((upperCharacter.zIndex + targetCharacter.zIndex) / 2);
                        if (newZIndex === targetCharacter.zIndex) {
                            newZIndex = upperCharacter.zIndex + 1;
                        }
                    } else {
                        newZIndex = targetCharacter.zIndex + 1;
                    }
                } else {
                    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ä¸‹ã«ãƒ‰ãƒ­ãƒƒãƒ—ï¼ˆã‚ˆã‚Šä½ã„Z-indexï¼‰
                    const lowerCharacter = sortedCharacters[targetIndex + 1];
                    if (lowerCharacter) {
                        newZIndex = Math.floor((lowerCharacter.zIndex + targetCharacter.zIndex) / 2);
                        if (newZIndex === targetCharacter.zIndex) {
                            newZIndex = lowerCharacter.zIndex - 1;
                        }
                    } else {
                        newZIndex = targetCharacter.zIndex - 1;
                    }
                }
                
                // Zã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ›´æ–°
                draggedCharacter.zIndex = newZIndex;
                
                console.log(`ğŸ”„ Zé †è©³ç´°å¤‰æ›´: ${draggedCharacter.name} Z:${newZIndex} (${dropAbove ? 'ä¸Š' : 'ä¸‹'}ã«ãƒ‰ãƒ­ãƒƒãƒ—)`);
                
                // UIæ›´æ–°
                this.updateCharacterLayers();
                this.redrawAllCharacters();
                this.markDirty();
            }
            
            // Zã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç›´æ¥æ›´æ–°
            updateCharacterZIndex(characterId, newZIndex) {
                const character = this.characters.get(characterId);
                if (!character) return;
                
                character.zIndex = newZIndex;
                this.updateCharacterLayers();
                this.redrawAllCharacters();
                this.markDirty();
                
                console.log(`ğŸ·ï¸ Zã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç›´æ¥å¤‰æ›´: ${character.name} Z:${newZIndex}`);
            }
            
            // è¡¨ç¤º/éè¡¨ç¤ºãƒˆã‚°ãƒ«
            toggleCharacterVisibility(characterId) {
                const character = this.characters.get(characterId);
                if (!character) return;
                
                character.visible = character.visible !== false ? false : true;
                this.updateCharacterLayers();
                this.redrawAllCharacters();
                this.markDirty();
                
                const status = character.visible !== false ? 'è¡¨ç¤º' : 'éè¡¨ç¤º';
                this.showToast(`${character.name} ã‚’${status}ã«ã—ã¾ã—ãŸ`, 'info');
            }
            
            handleCanvasClick(e) {
                const canvas = e.target;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                console.log(`Canvas clicked at: (${Math.round(x)}, ${Math.round(y)})`);
            }
            
            // æœªä¿å­˜çŠ¶æ…‹ç®¡ç†
            markDirty() {
                this.isDirty = true;
                this.updateStatus('æœªä¿å­˜ã®å¤‰æ›´ã‚ã‚Š âš ï¸', 'error');
                
                // Maya-style: è‡ªå‹•ä¿å­˜ã‚¿ã‚¤ãƒãƒ¼ï¼ˆ3ç§’å¾Œã«Quick Saveå®Ÿè¡Œï¼‰
                if (this.autoSaveTimer) {
                    clearTimeout(this.autoSaveTimer);
                }
                
                this.autoSaveTimer = setTimeout(() => {
                    if (this.isDirty) {
                        console.log('ğŸ”„ Auto-save triggered');
                        this.quickSave();
                    }
                }, 3000);
            }
            
            // Quick Saveï¼ˆé…ç½®ãƒ‡ãƒ¼ã‚¿ã®ã¿ï¼‰
            quickSave() {
                console.log('âš¡ Quick Saveé–‹å§‹: é…ç½®ãƒ‡ãƒ¼ã‚¿ã®ã¿ä¿å­˜');
                
                // ä¿å­˜ä¸­ã®è¡¨ç¤º
                this.showToast('âš¡ Quick Save ä¸­...', 'info');
                
                const characterData = Array.from(this.characters.values()).map(char => ({
                    id: char.id,
                    name: char.name,
                    transform: { ...char.transform },
                    zIndex: char.zIndex,
                    animation: char.animation,
                    visible: char.visible,
                    savedAt: new Date().toISOString()
                }));
                
                // éåŒæœŸé¢¨ã®ä¿å­˜å‡¦ç†
                setTimeout(() => {
                    try {
                        // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«é…ç½®ãƒ‡ãƒ¼ã‚¿ä¿å­˜
                        localStorage.setItem('spine-editor-v4-placement', JSON.stringify({
                            version: '4.0',
                            savedAt: new Date().toISOString(),
                            characterCount: characterData.length,
                            data: characterData
                        }));
                        
                        this.isDirty = false;
                        this.showToast('âš¡ é…ç½®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã¾ã—ãŸ', 'success');
                        
                        console.log('âœ… Quick Saveå®Œäº†:', characterData.length, 'å€‹ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿');
                        
                    } catch (error) {
                        console.error('âŒ Quick Saveã‚¨ãƒ©ãƒ¼:', error);
                        this.showToast('âŒ ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
                    }
                }, 300);
            }
            
            // Project Saveï¼ˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ä¿å­˜ï¼‰
            projectSave() {
                console.log('ğŸ’¾ Project Saveé–‹å§‹: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã‚’ä¿å­˜');
                
                // ä¿å­˜ä¸­ã®è¡¨ç¤º
                this.showToast('ğŸ’¾ Project Save ä¸­...', 'info');
                
                const projectData = {
                    version: '4.0',
                    project: {
                        name: 'Spine Editor v4.0 Project',
                        created: new Date().toISOString(),
                        modified: new Date().toISOString()
                    },
                    characters: Array.from(this.characters.values()),
                    availableAnimations: Object.fromEntries(this.availableAnimations),
                    settings: {
                        canvas: {
                            width: document.getElementById('canvas-width')?.value || 640,
                            height: document.getElementById('canvas-height')?.value || 360,
                            backgroundColor: document.getElementById('canvas-bg-color')?.value || '#1a1a1a'
                        },
                        editor: {
                            selectedCharacter: this.selectedCharacter,
                            realSpineTestMode: this.realSpineTestMode
                        }
                    },
                    meta: { 
                        isDirty: false,
                        savedAt: new Date().toISOString(),
                        characterCount: this.characters.size
                    }
                };
                
                // éåŒæœŸé¢¨ã®ä¿å­˜å‡¦ç†
                setTimeout(() => {
                    try {
                        // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«å…¨ãƒ‡ãƒ¼ã‚¿ä¿å­˜
                        localStorage.setItem('spine-editor-v4-project', JSON.stringify(projectData));
                        
                        this.isDirty = false;
                        this.showToast('ğŸ’¾ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã‚’ä¿å­˜ã—ã¾ã—ãŸ', 'success');
                        
                        console.log('âœ… Project Saveå®Œäº†:', {
                            characters: projectData.characters.length,
                            animations: Object.keys(projectData.availableAnimations).length,
                            settings: projectData.settings
                        });
                        
                    } catch (error) {
                        console.error('âŒ Project Saveã‚¨ãƒ©ãƒ¼:', error);
                        this.showToast('âŒ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ', 'error');
                    }
                }, 500);
            }
            
            exportProject() {
                console.log('ğŸ“¦ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆé–‹å§‹...');
                this.updateStatus('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå‡¦ç†ä¸­...');
                
                setTimeout(() => {
                    this.updateStatus('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº† â†’ dist/index.html', 'success');
                }, 1000);
            }
            
            // ğŸ¯ ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆï¼ˆAABBç²¾åº¦æ¤œè¨¼ï¼‰
            toggleDebugMode() {
                this.debugMode = !this.debugMode;
                
                if (this.debugMode) {
                    console.log('ğŸ¯ ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹: AABBç²¾åº¦æ¤œè¨¼ãƒ­ã‚°ãŒè¡¨ç¤ºã•ã‚Œã¾ã™');
                    this.showToast('ğŸ¯ ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹ - AABBç²¾åº¦æ¤œè¨¼é–‹å§‹', 'info');
                    
                    // ç¾åœ¨é¸æŠä¸­ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®AABBæƒ…å ±ã‚’å³åº§ã«è¡¨ç¤º
                    if (this.selectedCharacter) {
                        const character = this.characters.get(this.selectedCharacter);
                        const boundingBox = document.querySelector('.bounding-box');
                        if (character && boundingBox) {
                            this.updateBoundingBoxPosition(boundingBox, character);
                        }
                    }
                } else {
                    console.log('ğŸ¯ ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ç„¡åŠ¹');
                    this.showToast('ğŸ¯ ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ç„¡åŠ¹', 'info');
                }
                
                // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã—ã¦ã‚‚è¨­å®šï¼ˆã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‹ã‚‰ç¢ºèªå¯èƒ½ï¼‰
                window.spineDebugMode = this.debugMode;
            }
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¤‰æ›´
            updateCharacterAnimation(animationName) {
                if (!this.selectedCharacter) return;
                
                const character = this.characters.get(this.selectedCharacter);
                if (character) {
                    character.animation = animationName;
                    console.log(`ğŸ¬ ${character.name} ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¤‰æ›´: ${animationName}`);
                    this.updateCharacterLayers(); // ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤ºã‚’æ›´æ–°
                }
            }
            
            // ãƒ¬ã‚¤ãƒ¤ãƒ¼é †åº: å‰ã¸
            bringForward() {
                if (!this.selectedCharacter) return;
                
                const character = this.characters.get(this.selectedCharacter);
                if (character) {
                    character.zIndex++;
                    this.updatePropertiesPanel(character);
                    this.updateCharacterLayers();
                    this.redrawAllCharacters();
                    this.markDirty();
                }
            }
            
            // ãƒ¬ã‚¤ãƒ¤ãƒ¼é †åº: å¾Œã‚ã¸
            sendBackward() {
                if (!this.selectedCharacter) return;
                
                const character = this.characters.get(this.selectedCharacter);
                if (character) {
                    character.zIndex--;
                    this.updatePropertiesPanel(character);
                    this.updateCharacterLayers();
                    this.redrawAllCharacters();
                    this.markDirty();
                }
            }
            
            // Z-indexç›´æ¥ç·¨é›†
            updateCharacterZIndex(characterId, newZIndex) {
                const character = this.characters.get(characterId);
                if (!character) return;
                
                const oldZIndex = character.zIndex;
                character.zIndex = newZIndex;
                
                console.log(`ğŸ¯ Z-indexå¤‰æ›´: ${character.name} ${oldZIndex} â†’ ${newZIndex}`);
                
                this.updateCharacterLayers();
                this.redrawAllCharacters();
                this.markDirty();
                
                // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ‘ãƒãƒ«ã‚‚æ›´æ–°
                if (this.selectedCharacter === characterId) {
                    this.updatePropertiesPanel(character);
                }
            }
            
            // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®è¡¨ç¤º/éè¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
            toggleCharacterVisibility(characterId) {
                const character = this.characters.get(characterId);
                if (!character) return;
                
                character.visible = character.visible !== false ? false : true;
                
                console.log(`ğŸ‘ï¸ è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ: ${character.name} â†’ ${character.visible ? 'è¡¨ç¤º' : 'éè¡¨ç¤º'}`);
                
                this.updateCharacterLayers();
                this.redrawAllCharacters();
                this.markDirty();
            }
            
            // è©³ç´°ãªãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã«ã‚ˆã‚‹ãƒ¬ã‚¤ãƒ¤ãƒ¼é †åºå¤‰æ›´
            reorderLayersDetailed(draggedId, targetId, dropAbove) {
                if (draggedId === targetId) return;
                
                const draggedChar = this.characters.get(draggedId);
                const targetChar = this.characters.get(targetId);
                
                if (draggedChar && targetChar) {
                    // ã™ã¹ã¦ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’Zé †ã§ã‚½ãƒ¼ãƒˆ
                    const allCharacters = Array.from(this.characters.values())
                        .sort((a, b) => b.zIndex - a.zIndex);
                    
                    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
                    const targetIndex = allCharacters.findIndex(char => char.id === targetId);
                    
                    // ãƒ‰ãƒ­ãƒƒãƒ—ä½ç½®ã«å¿œã˜ã¦Z-indexã‚’è¨ˆç®—
                    let newZIndex;
                    if (dropAbove) {
                        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚ˆã‚Šä¸Šã«é…ç½®
                        const upperChar = allCharacters[targetIndex - 1];
                        newZIndex = upperChar ? upperChar.zIndex + 1 : targetChar.zIndex + 1;
                    } else {
                        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚ˆã‚Šä¸‹ã«é…ç½®
                        const lowerChar = allCharacters[targetIndex + 1];
                        newZIndex = lowerChar ? lowerChar.zIndex - 1 : targetChar.zIndex - 1;
                    }
                    
                    draggedChar.zIndex = newZIndex;
                    
                    console.log(`ğŸ”„ è©³ç´°ãƒ¬ã‚¤ãƒ¤ãƒ¼é †åºå¤‰æ›´: ${draggedChar.name} â†’ Z:${newZIndex} (${dropAbove ? 'ä¸Š' : 'ä¸‹'}ã«é…ç½®)`);
                    
                    this.updateCharacterLayers();
                    this.redrawAllCharacters();
                    this.markDirty();
                    
                    // ãƒ‰ãƒ©ãƒƒã‚°ã•ã‚ŒãŸã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’é¸æŠ
                    this.selectCharacter(draggedId);
                }
            }
            
            // æ—¢å­˜ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼é †åºå¤‰æ›´ï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ä¿æŒï¼‰
            reorderLayers(draggedId, targetId) {
                this.reorderLayersDetailed(draggedId, targetId, true);
            }
            
            // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£UIæ›´æ–°
            updateCharacterProperties(character) {
                if (!character) return;
                
                // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ‘ãƒãƒ«ã®è¦ç´ ã‚’å–å¾—
                const nameInput = document.querySelector('#character-name');
                const xInput = document.querySelector('#character-x');
                const yInput = document.querySelector('#character-y');
                const scaleXInput = document.querySelector('#character-scale-x');
                const scaleYInput = document.querySelector('#character-scale-y');
                const zIndexInput = document.querySelector('#character-z-index');
                
                // å€¤ã‚’æ›´æ–°ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ï¼‰
                if (nameInput) nameInput.value = character.name || '';
                if (xInput) xInput.value = (character.transform.x || 0).toFixed(1);
                if (yInput) yInput.value = (character.transform.y || 0).toFixed(1);
                if (scaleXInput) scaleXInput.value = (character.transform.scaleX || 1.0).toFixed(2);
                if (scaleYInput) scaleYInput.value = (character.transform.scaleY || 1.0).toFixed(2);
                if (zIndexInput) zIndexInput.value = character.transform.zIndex || 1;
                
                console.log('ğŸ”„ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£æ›´æ–°:', character.id, character.transform);
            }
            
            updateStatus(message, type = '') {
                const status = document.getElementById('project-status');
                status.textContent = message;
                status.className = type;
                
                const statusBar = document.getElementById('status-bar');
                statusBar.textContent = message;
            }

            // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³åˆ¶å¾¡æ©Ÿèƒ½
            setupTimelineControls() {
                this.timeline = {
                    isPlaying: false,
                    currentTime: 0,
                    duration: 5.0, // 5ç§’
                    playhead: null,
                    animationFrame: null
                };

                // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³è¦ç´ å–å¾—
                this.timeline.playhead = document.getElementById('timeline-playhead');
                
                // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³åˆ¶å¾¡ãƒœã‚¿ãƒ³
                document.getElementById('btn-play-pause').addEventListener('click', () => {
                    this.togglePlayPause();
                });
                
                document.getElementById('btn-stop').addEventListener('click', () => {
                    this.stopTimeline();
                });
                
                document.getElementById('btn-prev-frame').addEventListener('click', () => {
                    this.prevFrame();
                });
                
                document.getElementById('btn-next-frame').addEventListener('click', () => {
                    this.nextFrame();
                });
                
                document.getElementById('btn-loop').addEventListener('click', (e) => {
                    this.toggleLoop(e.target);
                });

                // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ scrubber ã‚¯ãƒªãƒƒã‚¯
                document.getElementById('timeline-scrubber').addEventListener('click', (e) => {
                    this.scrubTimeline(e);
                });

                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
                const speedSlider = document.getElementById('prop-anim-speed');
                const speedValue = document.getElementById('speed-value');
                if (speedSlider && speedValue) {
                    speedSlider.addEventListener('input', (e) => {
                        const speed = parseFloat(e.target.value);
                        speedValue.textContent = speed.toFixed(1) + 'x';
                        this.timeline.speed = speed;
                    });
                }

                // ã‚¢ãƒ«ãƒ•ã‚¡ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
                const alphaSlider = document.getElementById('prop-alpha');
                const alphaValue = document.getElementById('alpha-value');
                if (alphaSlider && alphaValue) {
                    alphaSlider.addEventListener('input', (e) => {
                        const alpha = parseFloat(e.target.value);
                        alphaValue.textContent = Math.round(alpha * 100) + '%';
                        this.updateSelectedCharacterAlpha(alpha);
                    });
                }

                this.updateTimelineDisplay();
            }

            togglePlayPause() {
                const btn = document.getElementById('btn-play-pause');
                
                if (this.timeline.isPlaying) {
                    this.pauseTimeline();
                    btn.textContent = 'â–¶';
                    btn.classList.remove('active');
                } else {
                    this.playTimeline();
                    btn.textContent = 'â¸';
                    btn.classList.add('active');
                }
            }

            playTimeline() {
                this.timeline.isPlaying = true;
                this.timeline.startTime = performance.now() - (this.timeline.currentTime * 1000);
                
                const animate = (timestamp) => {
                    if (!this.timeline.isPlaying) return;
                    
                    const elapsed = (timestamp - this.timeline.startTime) / 1000;
                    this.timeline.currentTime = elapsed % this.timeline.duration;
                    
                    this.updateTimelineDisplay();
                    this.updatePlayheadPosition();
                    
                    this.timeline.animationFrame = requestAnimationFrame(animate);
                };
                
                this.timeline.animationFrame = requestAnimationFrame(animate);
                this.updateStatus('Playing timeline â–¶', 'success');
            }

            pauseTimeline() {
                this.timeline.isPlaying = false;
                if (this.timeline.animationFrame) {
                    cancelAnimationFrame(this.timeline.animationFrame);
                }
                this.updateStatus('Timeline paused â¸');
            }

            stopTimeline() {
                this.timeline.isPlaying = false;
                this.timeline.currentTime = 0;
                
                if (this.timeline.animationFrame) {
                    cancelAnimationFrame(this.timeline.animationFrame);
                }
                
                const btn = document.getElementById('btn-play-pause');
                btn.textContent = 'â–¶';
                btn.classList.remove('active');
                
                this.updateTimelineDisplay();
                this.updatePlayheadPosition();
                this.updateStatus('Timeline stopped â¹');
            }

            prevFrame() {
                this.timeline.currentTime = Math.max(0, this.timeline.currentTime - 0.1);
                this.updateTimelineDisplay();
                this.updatePlayheadPosition();
            }

            nextFrame() {
                this.timeline.currentTime = Math.min(this.timeline.duration, this.timeline.currentTime + 0.1);
                this.updateTimelineDisplay();
                this.updatePlayheadPosition();
            }

            toggleLoop(btn) {
                this.timeline.loop = !this.timeline.loop;
                if (this.timeline.loop) {
                    btn.classList.add('active');
                    btn.style.color = '#ffd43b';
                } else {
                    btn.classList.remove('active');
                    btn.style.color = '';
                }
            }

            scrubTimeline(e) {
                const rect = e.currentTarget.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percent = x / rect.width;
                this.timeline.currentTime = percent * this.timeline.duration;
                
                this.updateTimelineDisplay();
                this.updatePlayheadPosition();
            }

            updateTimelineDisplay() {
                const timeDisplay = document.getElementById('timeline-time');
                if (timeDisplay) {
                    const current = this.formatTime(this.timeline.currentTime);
                    const duration = this.formatTime(this.timeline.duration);
                    timeDisplay.textContent = `${current} / ${duration}`;
                }
            }

            updatePlayheadPosition() {
                if (this.timeline.playhead) {
                    const percent = (this.timeline.currentTime / this.timeline.duration) * 100;
                    this.timeline.playhead.style.left = `${percent}%`;
                }
            }

            updateSelectedCharacterAlpha(alpha) {
                if (!this.selectedCharacter) return;
                
                const character = this.characters.get(this.selectedCharacter);
                if (character) {
                    character.alpha = alpha;
                    console.log(`ğŸ” Alphaå¤‰æ›´: ${character.name} â†’ ${Math.round(alpha * 100)}%`);
                    this.redrawAllCharacters();
                    this.markDirty();
                }
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = (seconds % 60).toFixed(2);
                return `${mins.toString().padStart(2, '0')}:${secs.padStart(5, '0')}`;
            }
        }
        
        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸš€ Spine Editor v4.0 - Maya/AfterEffects Style BBæ“ä½œå¯¾å¿œç‰ˆ');
            console.log('ğŸ“‹ å®Ÿè£…æ©Ÿèƒ½ç¢ºèª:');
            console.log('  âœ… Zé †å³ãƒšã‚¤ãƒ³: ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã«ã‚ˆã‚‹ãƒ¬ã‚¤ãƒ¤ãƒ¼é †åºå¤‰æ›´');
            console.log('  âœ… BBæ“ä½œä»•æ§˜: 8ãƒãƒ³ãƒ‰ãƒ« + ä¿®é£¾ã‚­ãƒ¼å¯¾å¿œ (Shift: ç¸¦æ¨ªæ¯”ä¿æŒ)');
            console.log('  âœ… ä¿å­˜æ–‡è¨€: Quick Save (Ctrl+S) + Project Save (Ctrl+Shift+S) + Auto-save');
            console.log('  âœ… ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åº§æ¨™è¡¨ç¤º: X,Y,W,H,Scale,Rotation');
            
            // ğŸ¯ ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ã—ã¦å…¬é–‹ï¼ˆãƒ‡ãƒãƒƒã‚°ãƒ»ãƒ†ã‚¹ãƒˆç”¨ï¼‰
            window.spineEditor = new ImprovedProjectManager();
        });
    </script>
</body>
</html>