<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>仕様書準拠 Spineキャラクター - ぷらっとくん</title>
    <style>
        /* 基本リセット */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #f0f0f0;
            font-family: Arial, sans-serif;
        }

        /* 🔑 重要：シーンコンテナ（レスポンシブ基準） */
        .scene-container {
            position: relative;           /* 子要素の絶対位置基準 */
            width: 100%;                 /* 画面幅に合わせる */
            max-width: 1200px;           /* 最大幅制限 */
            margin: 0 auto;              /* 中央寄せ */
            background: white;           
            border-radius: 10px;         
            overflow: hidden;            /* はみ出し防止 */
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        /* 🎯 重要：背景画像（基準となる要素） */
        .background-image {
            width: 100%;                 /* コンテナ幅に合わせる */
            height: auto;                /* 縦横比維持 */
            display: block;              /* inline要素の隙間除去 */
        }

        /* 🎮 重要：Spineキャラクター用Canvas（ぷらっとくん） */
        #purattokun-canvas {
            position: absolute;          /* 背景画像上に重ねる */
            left: 35%;                   /* 背景画像基準の位置（調整可能） */
            top: 75%;                    /* 背景画像基準の位置（調整可能） */
            transform: translate(-50%, -50%); /* 中央寄せ */
            width: 25%;                  /* 🔑 背景画像と同じ比例拡縮 */
            aspect-ratio: 3/2;           /* 🔑 縦横比固定（潰れ防止） */
            z-index: 10;                 /* 前面表示 */
            display: none;               /* 初期は非表示（JS読み込み後に表示） */
            cursor: pointer;             /* クリック可能表示 */
            data-character-name: "purattokun"; /* キャラクター識別用 */
        }

        /* 🎮 重要：Spineキャラクター用Canvas（ねずみ） */
        #nezumi-canvas {
            position: absolute;
            left: 60%;
            top: 45%;
            transform: translate(-50%, -50%);
            width: 20%;
            aspect-ratio: 3/2;
            z-index: 11;
            display: none;
            cursor: pointer;
            data-character-name: "nezumi";
        }

        /* 💫 フォールバック画像（ぷらっとくん） */
        #purattokun-fallback {
            position: absolute;          /* Canvas位置と同期 */
            left: 35%;                   /* Canvasと同じ位置 */
            top: 75%;                    /* Canvasと同じ位置 */
            transform: translate(-50%, -50%);
            width: 10%;                  /* 🔑 背景画像と同じ比例拡縮 */
            aspect-ratio: 1/1;           /* 正方形維持 */
            object-fit: contain;         /* 画像比率維持 */
            z-index: 10;
            display: block;              /* 初期表示（Spine成功時に非表示化） */
            cursor: pointer;
            data-character-name: "purattokun";
        }

        /* 💫 フォールバック画像（ねずみ） */
        #nezumi-fallback {
            position: absolute;
            left: 60%;
            top: 45%;
            transform: translate(-50%, -50%);
            width: 8%;
            aspect-ratio: 1/1;
            object-fit: contain;
            z-index: 11;
            display: block;
            cursor: pointer;
            data-character-name: "nezumi";
        }
    </style>
</head>
<body>
    <div class="scene-container">
        <!-- 背景画像（基準となる要素） -->
        <img src="assets/images/クラウドパートナーTOP.png" alt="背景" class="background-image">
        
        <!-- Spineキャラクター（ぷらっとくん） -->
        <canvas id="purattokun-canvas" width="300" height="200" data-spine-character="true" data-character-name="purattokun"></canvas>
        
        <!-- Spineキャラクター（ねずみ） -->
        <canvas id="nezumi-canvas" width="300" height="200" data-spine-character="true" data-character-name="nezumi" style="
            position: absolute;
            left: 60%;
            top: 45%;
            transform: translate(-50%, -50%);
            width: 20%;
            aspect-ratio: 3/2;
            z-index: 11;
            display: none;
            cursor: pointer;
        "></canvas>
        
        <!-- フォールバック画像（ぷらっとくん） -->
        <img src="assets/images/purattokunn.png" alt="ぷらっとくん" id="purattokun-fallback" data-spine-character="true" data-character-name="purattokun">
        
        <!-- フォールバック画像（ねずみ） -->
        <img src="assets/images/nezumi.png" alt="ねずみ" id="nezumi-fallback" data-spine-character="true" data-character-name="nezumi" style="
            position: absolute;
            left: 60%;
            top: 45%;
            transform: translate(-50%, -50%);
            width: 8%;
            aspect-ratio: 1/1;
            object-fit: contain;
            z-index: 11;
            display: block;
            cursor: pointer;
        ">
    </div>

    <!-- Spine WebGL Runtime -->
    <script src="https://unpkg.com/@esotericsoftware/spine-webgl@4.1.24/dist/iife/spine-webgl.js"></script>
    
    <!-- SkeletonBounds境界ボックスシステム -->
    <!-- PureBoundingBox v5.0との競合を避けるため一時的に無効化 -->
    <!-- <script src="assets/spine/spine-skeleton-bounds.js"></script> -->
    <!-- <script src="spine-bounds-integration.js"></script> -->
    
    <script>
        // 🎯 URLパラメータで編集モード起動（1行追加機能）
        const urlParams = new URLSearchParams(window.location.search);
        const editMode = urlParams.get('edit') === 'true';

        // 編集モード時の動的ファイル読み込み
        if (editMode) {
            console.log('🎯 編集モード起動');
            
            // 編集システム用CSS動的読み込み
            const editCSS = document.createElement('link');
            editCSS.rel = 'stylesheet';
            editCSS.href = 'spine-positioning-system-explanation.css';
            document.head.appendChild(editCSS);
            
            // 🎯 分割された編集システム用JS動的読み込み
            const moduleFiles = [
                'spine-package-export.js',  // ← PackageExportSystemを最初に読み込み
                'spine-ui-manager.js',
                'spine-multi-character-manager.js',
                // 🎯 PureBoundingBox v5.0 マイクロモジュール統合
                'micromodules/experimental/bounding-box/PureBoundingBoxCore.js',
                'micromodules/experimental/bounding-box/PureBoundingBoxBounds.js',
                'micromodules/experimental/bounding-box/PureBoundingBoxUI.js',
                'micromodules/experimental/bounding-box/PureBoundingBoxEvents.js',
                'micromodules/experimental/bounding-box/PureBoundingBox.js',
                // 'spine-bounding-box-module.js', // ← 旧バウンディングボックスを無効化
                'spine-state-manager.js',
                'spine-layer-editor.js',
                'spine-debug-tools.js',
                'spine-positioning-main.js'
            ];
            
            let loadedModules = 0;
            const totalModules = moduleFiles.length;
            
            const loadModule = (src, index) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = () => {
                    loadedModules++;
                    console.log(`✅ モジュール読み込み完了: ${src} (${loadedModules}/${totalModules})`);
                    
                    // 全モジュール読み込み完了時
                    if (loadedModules === totalModules) {
                        console.log('🎯 全編集システムモジュール読み込み完了（新中央制御統合版）');
                        console.log('🔍 システム確認:', {
                            // 新システム
                            SpineEditController: typeof SpineEditController,
                            SpineEditIntegration: typeof SpineEditIntegration,
                            spineEditController: !!window.spineEditController,
                            spineEditIntegration: !!window.spineEditIntegration,
                            // 統合API
                            spineEditUnified: !!window.spineEditUnified,
                            // 既存システム
                            initializeSpineEditSystem: typeof initializeSpineEditSystem,
                            createEditStartUI: typeof createEditStartUI,
                            SpineEditingSystem: typeof SpineEditingSystem
                        });
                        
                        // 統合システムの初期化待機（自動初期化される）
                        console.log('🚀 v2.0中央制御システム統合版 準備完了');
                        console.log('🔗 統合完了後は window.spineEditUnified でアクセス可能');
                        
                        // PureBoundingBox v5.0読み込み確認
                        setTimeout(() => {
                            console.log('🎯 PureBoundingBox v5.0モジュール読み込み状況:');
                            console.log('  - PureBoundingBoxCore:', typeof window.PureBoundingBoxCore);
                            console.log('  - PureBoundingBoxBounds:', typeof window.PureBoundingBoxBounds);
                            console.log('  - PureBoundingBoxUI:', typeof window.PureBoundingBoxUI);
                            console.log('  - PureBoundingBoxEvents:', typeof window.PureBoundingBoxEvents);
                            console.log('  - PureBoundingBox:', typeof window.PureBoundingBox);
                            if (typeof window.PureBoundingBox !== 'undefined') {
                                console.log('✅ PureBoundingBox v5.0 マイクロモジュール統合完了');
                            } else {
                                console.warn('❌ PureBoundingBox v5.0 読み込み失敗 - フォールバックシステム使用');
                            }
                        }, 100);
                    }
                };
                script.onerror = () => {
                    console.warn(`⚠️ モジュール読み込み失敗: ${src} - 継続します`);
                    loadedModules++;
                };
                document.head.appendChild(script);
            };
            
            // 順次読み込み
            moduleFiles.forEach((file, index) => {
                setTimeout(() => loadModule(file, index), index * 50); // 50ms間隔で順次読み込み
            });
        }

        // 🎯 メイン：複数Spineキャラクター初期化システム
        const spineCharacters = {};
        
        // SkeletonBounds統合システム用のグローバル変数
        let indexBoundsManager = null;
        
        /**
         * SkeletonBoundsシステムの初期化
         */
        async function initializeBounds() {
            try {
                console.log('🔗 SkeletonBounds統合システム初期化中...');
                
                // IndexSkeletonBoundsManagerのインスタンス作成
                if (typeof IndexSkeletonBoundsManager !== 'undefined') {
                    indexBoundsManager = new IndexSkeletonBoundsManager();
                    const initialized = await indexBoundsManager.initialize();
                    
                    if (initialized) {
                        console.log('✅ SkeletonBounds統合システム初期化完了');
                        return true;
                    } else {
                        console.warn('⚠️ SkeletonBounds統合システム初期化失敗');
                        return false;
                    }
                } else {
                    console.warn('⚠️ IndexSkeletonBoundsManager クラスが見つかりません');
                    return false;
                }
            } catch (error) {
                console.error('❌ SkeletonBounds統合システム初期化エラー:', error);
                return false;
            }
        }
        
        /**
         * キャラクター別SkeletonBounds統合処理
         */
        function integrateBoundsForCharacter(characterId, characterData) {
            if (!indexBoundsManager) {
                console.warn(`⚠️ ${characterId}: SkeletonBounds統合システムが未初期化`);
                return false;
            }
            
            try {
                return indexBoundsManager.integrateCharacter(characterId, characterData);
            } catch (error) {
                console.error(`❌ ${characterId}: SkeletonBounds統合エラー:`, error);
                return false;
            }
        }
        
        async function initSpineCharacters() {
            // キャラクター設定
            const characterConfigs = [
                {
                    id: 'purattokun',
                    canvasId: 'purattokun-canvas',
                    fallbackId: 'purattokun-fallback',
                    basePath: './assets/spine/characters/purattokun/',
                    atlasFile: 'purattokun.atlas',
                    jsonFile: 'purattokun.json',
                    scale: 0.55,
                    positionY: -100,
                    clickConfig: {
                        centerX: 0.5, centerY: 0.6,
                        radiusX: 0.15, radiusY: 0.2,
                        showDebugArea: false
                    }
                },
                {
                    id: 'nezumi',
                    canvasId: 'nezumi-canvas',
                    fallbackId: 'nezumi-fallback',
                    basePath: './assets/spine/characters/nezumi/',
                    atlasFile: 'nezumi.atlas',
                    jsonFile: 'nezumi.json',
                    scale: 0.45,
                    positionY: -80,
                    clickConfig: {
                        centerX: 0.5, centerY: 0.6,
                        radiusX: 0.2, radiusY: 0.25,
                        showDebugArea: false
                    }
                }
            ];

            // Spine WebGLの読み込み待ち
            await waitForSpine();
            
            // SkeletonBoundsシステム初期化
            console.log('🔗 SkeletonBounds初期化開始...');
            const boundsInitialized = await initializeBounds();
            console.log('🔗 SkeletonBounds初期化結果:', boundsInitialized);
            
            // 各キャラクターを並列初期化
            const initPromises = characterConfigs.map(config => initSingleCharacter(config));
            await Promise.allSettled(initPromises);
            
            console.log('✅ 全キャラクター初期化完了');
            console.log('🎯 利用可能なキャラクター:', Object.keys(spineCharacters));
            console.log('🎯 キャラクター数:', Object.keys(spineCharacters).length);
            
            // SkeletonBoundsとキャラクターを統合
            if (boundsInitialized) {
                console.log('🔗 SkeletonBounds統合開始...');
                console.log('🔗 統合対象キャラクター:', Object.keys(spineCharacters));
                
                for (const characterId of Object.keys(spineCharacters)) {
                    const character = spineCharacters[characterId];
                    console.log(`🔗 ${characterId} 統合処理開始:`, {
                        hasCanvas: !!character.canvas,
                        hasSkeleton: !!character.skeleton,
                        hasAnimationState: !!character.animationState
                    });
                    
                    // 統合用データ構造を作成
                    const characterData = {
                        canvas: character.canvas,
                        spine: {
                            skeleton: character.skeleton,
                            animationState: character.animationState
                        }
                    };
                    
                    console.log(`🔗 ${characterId} integrateBoundsForCharacter 呼び出し...`);
                    const integrated = integrateBoundsForCharacter(characterId, characterData);
                    console.log(`🔗 ${characterId} 統合結果:`, integrated);
                    
                    if (integrated) {
                        console.log(`✅ ${characterId}: SkeletonBounds統合完了`);
                    } else {
                        console.warn(`⚠️ ${characterId}: SkeletonBounds統合失敗`);
                    }
                }
                
                console.log('🎯 SkeletonBounds統合完了 - 境界ボックス機能有効');
                console.log('🛠️ 利用可能なデバッグ機能:');
                console.log('  - toggleBoundsDebug() : デバッグ表示ON/OFF');
                console.log('  - showBoundsInfo(キャラクター名) : 境界ボックス情報表示');
                console.log('  - updateAllBounds() : 境界ボックス更新');
            } else {
                console.warn('⚠️ SkeletonBounds初期化失敗 - 統合スキップ');
            }
            
            // 手動統合テスト機能をグローバルに追加
            window.manualIntegrationTest = function() {
                console.log('🔗 手動統合テスト開始...');
                console.log('🎯 boundsManager存在:', !!window.boundsManager);
                console.log('🎯 spineSkeletonBounds存在:', !!window.spineSkeletonBounds);
                console.log('🎯 spineCharacters:', Object.keys(spineCharacters));
                
                if (!window.boundsManager || !window.spineSkeletonBounds) {
                    console.error('❌ boundsManagerまたはspineSkeletonBoundsが初期化されていません');
                    return false;
                }
                
                let successCount = 0;
                for (const characterId of Object.keys(spineCharacters)) {
                    const character = spineCharacters[characterId];
                    const characterData = {
                        canvas: character.canvas,
                        spine: {
                            skeleton: character.skeleton,
                            animationState: character.animationState
                        }
                    };
                    
                    console.log(`🔗 手動統合: ${characterId}`);
                    const integrated = integrateBoundsForCharacter(characterId, characterData);
                    if (integrated) {
                        console.log(`✅ 手動統合成功: ${characterId}`);
                        successCount++;
                    } else {
                        console.warn(`⚠️ 手動統合失敗: ${characterId}`);
                    }
                }
                
                console.log(`🎯 手動統合結果: ${successCount}/${Object.keys(spineCharacters).length}`);
                console.log('🎯 統合後キャラクター数:', Object.keys(window.boundsManager.characters || {}).length);
                return successCount > 0;
            };
            
            console.log('🛠️ 手動統合テスト機能追加完了: window.manualIntegrationTest()');
            
            // UIパネルは削除済み - シンプルな2キャラクター環境
        }

        async function initSingleCharacter(config) {
            try {
                console.log(`🎬 ${config.id}キャラクター初期化開始`);
                
                const canvas = document.getElementById(config.canvasId);
                const fallback = document.getElementById(config.fallbackId);
                
                if (!canvas || !fallback) {
                    throw new Error(`要素が見つかりません: ${config.canvasId} または ${config.fallbackId}`);
                }

                const gl = canvas.getContext("webgl", { alpha: true });
                if (!gl) {
                    throw new Error("WebGL未対応");
                }

                // アセットマネージャー
                const assetManager = new spine.AssetManager(gl, config.basePath);
                assetManager.loadTextureAtlas(config.atlasFile);
                assetManager.loadJson(config.jsonFile);

                await waitForAssets(assetManager);

                // Spineスケルトン構築
                const atlas = assetManager.get(config.atlasFile);
                const atlasLoader = new spine.AtlasAttachmentLoader(atlas);
                const skeletonJson = new spine.SkeletonJson(atlasLoader);
                const skeletonData = skeletonJson.readSkeletonData(
                    assetManager.get(config.jsonFile)
                );

                const skeleton = new spine.Skeleton(skeletonData);
                
                // キャラクター位置設定
                skeleton.x = 0;
                skeleton.y = config.positionY;
                skeleton.scaleX = skeleton.scaleY = config.scale;

                // アニメーション設定
                const animationStateData = new spine.AnimationStateData(skeleton.data);
                const animationState = new spine.AnimationState(animationStateData);

                // デフォルトアニメーション開始
                startDefaultAnimation(animationState, skeleton, config.id);

                // レンダラー
                const renderer = new spine.SceneRenderer(canvas, gl);

                // 描画ループ
                let lastTime = Date.now() / 1000;
                function render() {
                    const now = Date.now() / 1000;
                    const delta = now - lastTime;
                    lastTime = now;

                    animationState.update(delta);
                    animationState.apply(skeleton);
                    skeleton.updateWorldTransform();

                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.viewport(0, 0, canvas.width, canvas.height);

                    renderer.begin();
                    renderer.drawSkeleton(skeleton, true);
                    renderer.end();

                    requestAnimationFrame(render);
                }
                render();

                // クリック範囲設定
                setupClickHandler(canvas, skeleton, animationState, config);

                // 成功時：Canvas表示、フォールバック非表示
                canvas.style.display = "block";
                fallback.style.display = "none";

                // キャラクター情報を保存
                spineCharacters[config.id] = {
                    canvas, fallback, skeleton, animationState, renderer, config,
                    animations: skeleton.data.animations.map(anim => anim.name)
                };

                console.log(`✅ ${config.id}初期化完了`);
                console.log(`📋 ${config.id}利用可能アニメーション:`, spineCharacters[config.id].animations);

            } catch (error) {
                console.error(`❌ ${config.id}初期化失敗:`, error);
            }
        }

        function startDefaultAnimation(animationState, skeleton, characterId) {
            // キャラクター別デフォルトアニメーション設定
            let defaultAnimation = null;
            
            if (characterId === 'purattokun') {
                // ぷらっとくん: 登場→待機のシーケンス
                if (skeleton.data.findAnimation("syutugen") && skeleton.data.findAnimation("taiki")) {
                    console.log(`🎬 ${characterId}: syutugen（登場）→taiki（待機）シーケンス開始`);
                    animationState.setAnimation(0, "syutugen", false);
                    animationState.addAnimation(0, "taiki", true, 0);
                    return;
                } else if (skeleton.data.findAnimation("taiki")) {
                    defaultAnimation = "taiki";
                }
            } else if (characterId === 'nezumi') {
                // ねずみ: searchをデフォルトに設定
                if (skeleton.data.findAnimation("search")) {
                    defaultAnimation = "search";
                } else if (skeleton.data.findAnimation("kettei")) {
                    defaultAnimation = "kettei";
                }
            }
            
            if (defaultAnimation) {
                console.log(`🎬 ${characterId}: ${defaultAnimation}（デフォルト）アニメーション開始`);
                animationState.setAnimation(0, defaultAnimation, true);
            } else {
                console.log(`⚠️ ${characterId}: 利用可能なアニメーションが見つかりません`);
            }
        }

        function setupClickHandler(canvas, skeleton, animationState, config) {
            const clickConfig = config.clickConfig;
            
            // デバッグエリア表示
            if (clickConfig.showDebugArea) {
                const debugArea = document.createElement('div');
                debugArea.style.cssText = `
                    position: absolute;
                    left: ${(clickConfig.centerX - clickConfig.radiusX) * 100}%;
                    top: ${(clickConfig.centerY - clickConfig.radiusY) * 100}%;
                    width: ${clickConfig.radiusX * 2 * 100}%;
                    height: ${clickConfig.radiusY * 2 * 100}%;
                    border: 2px dashed ${config.id === 'purattokun' ? 'red' : 'blue'};
                    background: rgba(${config.id === 'purattokun' ? '255, 0, 0' : '0, 0, 255'}, 0.1);
                    pointer-events: none;
                    z-index: 1000;
                `;
                canvas.parentElement.appendChild(debugArea);
            }

            const originalClickHandler = (event) => {
                const rect = canvas.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const clickY = event.clientY - rect.top;
                
                const normalizedX = clickX / rect.width;
                const normalizedY = clickY / rect.height;
                
                console.log(`🔍 ${config.id}クリック座標: (${normalizedX.toFixed(3)}, ${normalizedY.toFixed(3)})`);
                
                const deltaX = Math.abs(normalizedX - clickConfig.centerX);
                const deltaY = Math.abs(normalizedY - clickConfig.centerY);
                
                const inRangeX = deltaX <= clickConfig.radiusX;
                const inRangeY = deltaY <= clickConfig.radiusY;
                
                if (inRangeX && inRangeY) {
                    console.log(`🎯 ${config.id}範囲内ヒット: ΔX=${deltaX.toFixed(3)}, ΔY=${deltaY.toFixed(3)}`);
                    
                    // キャラクター別アニメーション再生
                    let clickAnimation = null;
                    
                    if (config.id === 'purattokun') {
                        // ぷらっとくん: yarareアニメーション
                        if (skeleton.data.findAnimation("yarare")) {
                            clickAnimation = "yarare";
                        } else if (skeleton.data.findAnimation("syutugen")) {
                            clickAnimation = "syutugen";
                        }
                    } else if (config.id === 'nezumi') {
                        // ねずみ: ketteiまたはsearchアニメーション
                        if (skeleton.data.findAnimation("kettei")) {
                            clickAnimation = "kettei";
                        } else if (skeleton.data.findAnimation("search")) {
                            clickAnimation = "search";
                        }
                    }
                    
                    if (clickAnimation) {
                        console.log(`🎯 ${config.id}: ${clickAnimation}アニメーション開始`);
                        animationState.setAnimation(0, clickAnimation, false);
                        
                        // アニメーション完了後の復帰設定
                        const returnAnimation = skeleton.data.findAnimation("taiki") ? "taiki" : 
                                               (config.id === 'nezumi' && skeleton.data.findAnimation("search")) ? "search" : null;
                        
                        if (returnAnimation && clickAnimation !== returnAnimation) {
                            animationState.addAnimation(0, returnAnimation, true, 0);
                        }
                    } else {
                        console.log(`⚠️ ${config.id}: 利用可能なクリックアニメーションが見つかりません`);
                    }
                } else {
                    console.log(`🔍 ${config.id}範囲外: ΔX=${deltaX.toFixed(3)} (上限${clickConfig.radiusX}), ΔY=${deltaY.toFixed(3)} (上限${clickConfig.radiusY})`);
                }
            };
            
            // ハンドラーをcanvas要素に保存（spine-bounds-integration.jsで使用）
            canvas.originalClickHandler = originalClickHandler;
            
            // イベントリスナー登録
            canvas.addEventListener("click", originalClickHandler);
        }

        // Spine WebGLの読み込み待ち
        async function waitForSpine() {
            return new Promise((resolve, reject) => {
                let checkCount = 0;
                const maxChecks = 50;

                const checkSpine = () => {
                    checkCount++;
                    if (typeof spine !== "undefined") {
                        console.log("✅ Spine WebGL読み込み完了");
                        resolve();
                    } else if (checkCount >= maxChecks) {
                        reject(new Error("Spine WebGL読み込みタイムアウト"));
                    } else {
                        setTimeout(checkSpine, 100);
                    }
                };

                checkSpine();
            });
        }

        // アセット読み込み待ち
        async function waitForAssets(assetManager) {
            return new Promise((resolve, reject) => {
                let checkCount = 0;
                const maxChecks = 50;

                const checkAssets = () => {
                    checkCount++;
                    if (assetManager.isLoadingComplete()) {
                        console.log("✅ アセット読み込み完了");
                        resolve();
                    } else if (checkCount >= maxChecks) {
                        reject(new Error("アセット読み込みタイムアウト"));
                    } else {
                        setTimeout(checkAssets, 100);
                    }
                };

                checkAssets();
            });
        }






        // コンソール用デバッグ関数（シンプル版）
        window.spineDebug = {
            characters: spineCharacters,
            playAnimation: (characterId, animationName) => {
                const character = spineCharacters[characterId];
                if (character && character.skeleton.data.findAnimation(animationName)) {
                    character.animationState.setAnimation(0, animationName, animationName === 'taiki');
                    console.log(`🎬 ${characterId}: ${animationName} アニメーション再生`);
                } else {
                    console.warn(`⚠️ ${characterId}: ${animationName} アニメーションが見つかりません`);
                }
            },
            listAnimations: (characterId) => {
                const character = spineCharacters[characterId];
                if (character) {
                    console.log(`📋 ${characterId}利用可能アニメーション:`, character.animations);
                }
            }
        };

        // 初期化実行
        window.addEventListener("load", () => {
            setTimeout(initSpineCharacters, 500);
        });
    </script>
</body>
</html>