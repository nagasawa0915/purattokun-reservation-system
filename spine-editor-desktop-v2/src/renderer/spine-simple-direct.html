<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç›´æ¥Spineçµ±åˆãƒ†ã‚¹ãƒˆ</title>
    <style>
        body { margin: 0; padding: 20px; background: #2c3e50; color: white; font-family: Arial, sans-serif; }
        .container { max-width: 800px; margin: 0 auto; text-align: center; }
        #spine-canvas { width: 400px; height: 300px; border: 2px solid #3498db; margin: 20px auto; display: none; }
        .status { margin: 20px 0; padding: 10px; background: rgba(0,0,0,0.3); }
        button { margin: 5px; padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:disabled { background: #7f8c8d; cursor: not-allowed; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ­ ç›´æ¥Spineçµ±åˆãƒ†ã‚¹ãƒˆ</h1>
        <div class="status" id="status">åˆæœŸåŒ–ä¸­...</div>
        <canvas id="spine-canvas" width="400" height="300"></canvas>
        <button id="load-character" disabled>ğŸ± ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼èª­ã¿è¾¼ã¿</button>
    </div>

    <!-- Spine WebGL Runtime (CDN - æˆåŠŸå®Ÿç¸¾) -->
    <script src="https://unpkg.com/@esotericsoftware/spine-webgl@4.1.24/dist/iife/spine-webgl.js"></script>
    
    <script>
        let renderer = null;
        let currentSkeleton = null;
        let animationState = null;
        
        const canvas = document.getElementById('spine-canvas');
        const status = document.getElementById('status');
        
        function updateStatus(msg) {
            status.textContent = msg;
            console.log(msg);
        }
        
        // SpineåˆæœŸåŒ–
        async function initSpine() {
            try {
                updateStatus('Spine WebGLèª­ã¿è¾¼ã¿å¾…æ©Ÿä¸­...');
                await waitForSpine();
                
                const gl = canvas.getContext("webgl", { alpha: true });
                if (!gl) throw new Error("WebGLæœªå¯¾å¿œ");
                
                renderer = new spine.SceneRenderer(canvas, gl);
                updateStatus('âœ… SpineåˆæœŸåŒ–å®Œäº†');
                
                canvas.style.display = 'block';
                document.getElementById('load-character').disabled = false;
                
            } catch (error) {
                updateStatus('âŒ åˆæœŸåŒ–å¤±æ•—: ' + error.message);
            }
        }
        
        // Spineèª­ã¿è¾¼ã¿å¾…ã¡ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
        async function waitForSpine() {
            return new Promise((resolve, reject) => {
                let count = 0;
                const check = () => {
                    count++;
                    if (typeof spine !== "undefined" && spine.AssetManager) {
                        console.log('âœ… Spine WebGLèª­ã¿è¾¼ã¿å®Œäº†');
                        resolve();
                    } else if (count >= 50) {
                        reject(new Error("Spineèª­ã¿è¾¼ã¿ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ"));
                    } else {
                        setTimeout(check, 100);
                    }
                };
                check();
            });
        }
        
        // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼èª­ã¿è¾¼ã¿
        async function loadCharacter() {
            try {
                updateStatus('purattokunèª­ã¿è¾¼ã¿ä¸­...');
                
                const gl = canvas.getContext("webgl");
                const basePath = "./assets/spine/characters/purattokun/";
                const assetManager = new spine.AssetManager(gl, basePath);
                
                assetManager.loadTextureAtlas("purattokun.atlas");
                assetManager.loadJson("purattokun.json");
                
                await waitForAssets(assetManager);
                
                const atlas = assetManager.get("purattokun.atlas");
                const atlasLoader = new spine.AtlasAttachmentLoader(atlas);
                const skeletonJson = new spine.SkeletonJson(atlasLoader);
                const skeletonData = skeletonJson.readSkeletonData(
                    assetManager.get("purattokun.json")
                );
                
                currentSkeleton = new spine.Skeleton(skeletonData);
                currentSkeleton.x = 200;
                currentSkeleton.y = 250;
                currentSkeleton.scaleX = currentSkeleton.scaleY = 0.5;
                
                const animationStateData = new spine.AnimationStateData(skeletonData);
                animationState = new spine.AnimationState(animationStateData);
                
                if (skeletonData.animations.length > 0) {
                    const firstAnimation = skeletonData.animations[0].name;
                    animationState.setAnimation(0, firstAnimation, true);
                }
                
                startRenderLoop();
                updateStatus('âœ… ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼èª­ã¿è¾¼ã¿å®Œäº†');
                
            } catch (error) {
                updateStatus('âŒ èª­ã¿è¾¼ã¿å¤±æ•—: ' + error.message);
            }
        }
        
        // ã‚¢ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿å¾…ã¡
        async function waitForAssets(assetManager) {
            return new Promise((resolve, reject) => {
                let count = 0;
                const check = () => {
                    count++;
                    if (assetManager.isLoadingComplete()) {
                        resolve();
                    } else if (count >= 100) {
                        reject(new Error("ã‚¢ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ"));
                    } else {
                        setTimeout(check, 100);
                    }
                };
                check();
            });
        }
        
        // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—
        function startRenderLoop() {
            let lastTime = Date.now() / 1000;
            
            const render = () => {
                if (!renderer || !currentSkeleton) return;
                
                const now = Date.now() / 1000;
                const delta = now - lastTime;
                lastTime = now;
                
                const gl = canvas.getContext("webgl");
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                animationState.update(delta);
                animationState.apply(currentSkeleton);
                currentSkeleton.updateWorldTransform();
                
                renderer.drawSkeleton(currentSkeleton, false);
                
                requestAnimationFrame(render);
            };
            
            requestAnimationFrame(render);
        }
        
        // ã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('load-character').addEventListener('click', loadCharacter);
        
        // åˆæœŸåŒ–é–‹å§‹
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(initSpine, 100);
        });
    </script>
</body>
</html>