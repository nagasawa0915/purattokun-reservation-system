/**
 * Spine Editor Desktop v2.0 - Package Export Module
 * ZIPç”Ÿæˆãƒ»ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ç®¡ç†æ©Ÿèƒ½
 */

export class ExportPackage {
  constructor(app) {
    this.app = app;
    this.packageData = null;
  }

  /**
   * å®Œå…¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ç”Ÿæˆ
   */
  async generateCompletePackage(project) {
    const packageData = {
      files: new Map(),
      totalSize: 0,
      metadata: {
        name: project.name || 'Spine Project',
        version: '2.0.0',
        created: new Date().toISOString(),
        generator: 'Spine Editor Desktop v2.0',
        homepage: project.homepageFolder || null,
        workflow: 'complete'
      }
    };

    try {
      console.log('ğŸ“¦ Starting complete package generation...');

      // å„ç¨®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ä¸¦åˆ—ç”Ÿæˆï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ï¼‰
      const [htmlContent, spineAssets, libraryContent, cssContent] = await Promise.all([
        this.generatePackageHTML(project),
        this.collectSpineAssets(project),
        this.loadSpineLibrary(),
        this.generatePackageCSS(project)
      ]);

      // ãƒ¡ã‚¤ãƒ³HTMLãƒ•ã‚¡ã‚¤ãƒ«
      if (htmlContent) {
        packageData.files.set('index.html', htmlContent);
      }

      // Spineã‚¢ã‚»ãƒƒãƒˆè¿½åŠ 
      spineAssets.forEach((content, filename) => {
        packageData.files.set(filename, content);
      });

      // Spine WebGLãƒ©ã‚¤ãƒ–ãƒ©ãƒª
      if (libraryContent) {
        packageData.files.set('spine-webgl.js', libraryContent);
      }

      // CSS
      if (cssContent) {
        packageData.files.set('spine-styles.css', cssContent);
      }

      // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±ãƒ»READMEãƒ•ã‚¡ã‚¤ãƒ«
      await this.addProjectDocumentation(packageData, project);

      // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºè¨ˆç®—
      packageData.totalSize = this.calculateTotalSize(packageData.files);

      console.log(`ğŸ“¦ Package complete: ${packageData.files.size} files (${this.formatFileSize(packageData.totalSize)})`);
      this.packageData = packageData;
      return packageData;

    } catch (error) {
      console.error('âŒ Package generation failed:', error);
      throw error;
    }
  }

  /**
   * å®Ÿéš›ZIPãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
   */
  async createActualZipFile(packageData, outputPath) {
    try {
      console.log('ğŸ“¦ Creating ZIP file...');

      // JSZipãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ­ãƒ¼ãƒ‰
      const JSZip = window.JSZip || await this.loadJSZip();
      const zip = new JSZip();

      // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ZIPã«è¿½åŠ 
      for (const [filename, content] of packageData.files.entries()) {
        if (this.isBinaryFile(filename)) {
          zip.file(filename, content, { binary: true });
        } else {
          zip.file(filename, content);
        }
      }

      // ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆè¿½åŠ 
      const manifest = this.createManifest(packageData);
      zip.file('package-manifest.json', JSON.stringify(manifest, null, 2));

      // ZIPç”Ÿæˆã‚ªãƒ—ã‚·ãƒ§ãƒ³
      const zipOptions = {
        type: 'blob',
        compression: 'DEFLATE',
        compressionOptions: { level: 6 },
        comment: `Generated by Spine Editor Desktop v2.0 at ${new Date().toISOString()}`
      };

      // ZIPç”Ÿæˆ
      const zipBlob = await zip.generateAsync(zipOptions);

      // ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿
      await this.writeZipFile(zipBlob, outputPath);

      console.log(`âœ… ZIP created successfully: ${outputPath}`);

    } catch (error) {
      console.error('âŒ ZIP creation failed:', error);
      
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã‚·ãƒ³ãƒ—ãƒ«ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ä½œæˆ
      await this.createFallbackArchive(packageData, outputPath);
    }
  }

  /**
   * ZIPæ›¸ãè¾¼ã¿å‡¦ç†
   */
  async writeZipFile(zipBlob, outputPath) {
    const buffer = await zipBlob.arrayBuffer();
    const uint8Array = new Uint8Array(buffer);

    const writeResult = await window.electronAPI.writeFile(
      outputPath, 
      Array.from(uint8Array)
    );

    if (!writeResult.success) {
      throw new Error(writeResult.error || 'File write failed');
    }
  }

  /**
   * JSZipãƒ©ã‚¤ãƒ–ãƒ©ãƒªå‹•çš„èª­ã¿è¾¼ã¿
   */
  async loadJSZip() {
    if (window.JSZip) {
      return window.JSZip;
    }

    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
      script.onload = () => {
        console.log('ğŸ“œ JSZip library loaded');
        resolve(window.JSZip);
      };
      script.onerror = () => reject(new Error('Failed to load JSZip library'));
      document.head.appendChild(script);
    });
  }

  /**
   * ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸HTMLç”Ÿæˆ
   */
  async generatePackageHTML(project) {
    // Homepageãƒ™ãƒ¼ã‚¹ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯ãã‚Œã‚’ä½¿ç”¨
    let htmlContent = await this.getHomepageTemplate(project);
    
    if (!htmlContent) {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³HTMLç”Ÿæˆ
      htmlContent = await this.generateStandaloneHTML(project);
    }
    
    // Spineè¨­å®šã‚’åŸ‹ã‚è¾¼ã¿
    htmlContent = this.injectSpineConfiguration(htmlContent, project);
    
    console.log('ğŸ  Package HTML generated');
    return htmlContent;
  }

  /**
   * Homepageãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå–å¾—
   */
  async getHomepageTemplate(project) {
    if (!project.homepageFolder || !window.electronAPI) {
      return null;
    }
    
    try {
      const indexPath = `${project.homepageFolder}/index.html`;
      const result = await window.electronAPI.readFile(indexPath);
      
      if (result.success) {
        console.log('ğŸ  Homepage template loaded from:', indexPath);
        return result.data;
      }
    } catch (error) {
      console.warn('âš ï¸ Homepage template load failed:', error);
    }
    
    return null;
  }

  /**
   * ã‚¹ã‚¿ãƒ³ãƒ‰ã‚¢ãƒ­ãƒ³HTMLç”Ÿæˆ
   */
  async generateStandaloneHTML(project) {
    return `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${project.name || 'Spine Animation'}</title>
    <link rel="stylesheet" href="spine-styles.css">
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background: #f0f0f0;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .spine-container {
            position: relative;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
        }
        #spine-canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }
        .controls {
            margin-top: 15px;
            text-align: center;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .btn {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        .btn:hover { 
            background: #0056b3; 
        }
        .info {
            margin-top: 10px;
            text-align: center;
            color: #666;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="spine-container">
        <canvas id="spine-canvas" width="800" height="600"></canvas>
        <div class="controls">
            <button class="btn" onclick="playAnimation()" title="ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿ">â–¶ï¸ Play</button>
            <button class="btn" onclick="pauseAnimation()" title="ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸€æ™‚åœæ­¢">â¸ï¸ Pause</button>
            <button class="btn" onclick="stopAnimation()" title="ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢">â¹ï¸ Stop</button>
        </div>
        <div class="info">
            Generated by Spine Editor Desktop v2.0
        </div>
    </div>

    <script src="spine-webgl.js"></script>
    <script>
        // Spine Editor Desktop v2.0 - Generated Script
        let canvas, gl, shader, batcher;
        let skeleton, animationState;

        function initSpine() {
            canvas = document.getElementById('spine-canvas');
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) {
                console.error('WebGL not supported');
                showError('WebGL not supported in this browser');
                return;
            }
            
            console.log('Spine WebGL initialized');
        }

        function playAnimation() {
            console.log('Play animation');
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿå‡¦ç†
        }

        function pauseAnimation() {
            console.log('Pause animation');
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸€æ™‚åœæ­¢å‡¦ç†
        }

        function stopAnimation() {
            console.log('Stop animation');
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åœæ­¢å‡¦ç†
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'background: #f8d7da; color: #721c24; padding: 10px; border-radius: 4px; margin-top: 10px;';
            errorDiv.textContent = message;
            document.querySelector('.spine-container').appendChild(errorDiv);
        }

        // è‡ªå‹•åˆæœŸåŒ–
        window.addEventListener('load', initSpine);
        
        // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        window.addEventListener('error', function(e) {
            console.error('Script error:', e.error);
            showError('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
        });
    </script>
</body>
</html>`;
  }

  /**
   * Spineè¨­å®šã‚’HTMLã«åŸ‹ã‚è¾¼ã¿
   */
  injectSpineConfiguration(htmlContent, project) {
    const character = project.spineData?.characters?.[0];
    if (!character) return htmlContent;

    const configSection = `
<div id="purattokun-config" style="display: none;"
     data-x="${(character.x / 800 * 100).toFixed(1)}"
     data-y="${(character.y / 600 * 100).toFixed(1)}"
     data-scale="${character.scaleX || 0.5}"
     data-fade-delay="1500"
     data-fade-duration="2000">
</div>`;

    // æ—¢å­˜è¨­å®šã®ç½®æ›ã¾ãŸã¯è¿½åŠ 
    if (htmlContent.includes('id="purattokun-config"')) {
      htmlContent = htmlContent.replace(
        /<div id="purattokun-config"[\s\S]*?<\/div>/,
        configSection.trim()
      );
    } else {
      htmlContent = htmlContent.replace(
        '</head>',
        `  ${configSection}\n</head>`
      );
    }

    return htmlContent;
  }

  /**
   * Spineã‚¢ã‚»ãƒƒãƒˆåé›†
   */
  async collectSpineAssets(project) {
    const assets = new Map();

    if (!project.spineData?.characters) {
      return assets;
    }

    for (const character of project.spineData.characters) {
      const characterId = character.id || 'character';

      // JSONãƒ•ã‚¡ã‚¤ãƒ«
      if (character.jsonPath) {
        const content = await this.readAssetFile(character.jsonPath);
        if (content) {
          assets.set(`assets/${characterId}.json`, content);
        }
      }

      // Atlasãƒ•ã‚¡ã‚¤ãƒ«
      if (character.atlasPath) {
        const content = await this.readAssetFile(character.atlasPath);
        if (content) {
          assets.set(`assets/${characterId}.atlas`, content);
        }
      }

      // ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«
      if (character.imagePath) {
        const content = await this.readAssetFile(character.imagePath);
        if (content) {
          assets.set(`assets/${characterId}.png`, content);
        }
      }
    }

    console.log(`ğŸ¦´ Spine assets collected: ${assets.size} files`);
    return assets;
  }

  /**
   * ã‚¢ã‚»ãƒƒãƒˆãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
   */
  async readAssetFile(filePath) {
    try {
      const result = await window.electronAPI.readFile(filePath);
      return result.success ? result.data : null;
    } catch (error) {
      console.warn(`âš ï¸ Failed to read asset: ${filePath}`, error);
      return null;
    }
  }

  /**
   * Spine WebGLãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ­ãƒ¼ãƒ‰
   */
  async loadSpineLibrary() {
    const libraryPaths = [
      '../assets/spine/spine-webgl.js',
      '../assets/spine/spine-webgl-minimal.js'
    ];

    for (const path of libraryPaths) {
      try {
        const result = await window.electronAPI.readFile(path);
        if (result.success) {
          console.log(`ğŸ“œ Spine library loaded: ${path}`);
          return result.data;
        }
      } catch (error) {
        console.warn(`âš ï¸ Library load failed: ${path}`);
      }
    }

    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æœ€å°ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
    const minimalLibrary = this.getMinimalSpineLibrary();
    console.log('ğŸ“œ Using minimal fallback library');
    return minimalLibrary;
  }

  /**
   * æœ€å°Spineãƒ©ã‚¤ãƒ–ãƒ©ãƒªå–å¾—
   */
  getMinimalSpineLibrary() {
    return `/* Spine WebGL Minimal - Generated by Spine Editor v2.0 */
console.log('Spine WebGL Minimal loaded');

// WebGLåŸºæœ¬æ©Ÿèƒ½ã®å®Ÿè£…
window.spine = {
  WebGLContext: function(canvas) {
    this.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    this.canvas = canvas;
  },
  
  loadSkeleton: function(jsonPath, atlasPath) {
    console.log('Loading skeleton:', jsonPath, atlasPath);
    // æœ€å°é™ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å®Ÿè£…
  },
  
  createSkeleton: function(data) {
    console.log('Creating skeleton');
    return { 
      setPosition: function(x, y) { console.log('Position:', x, y); },
      setScale: function(sx, sy) { console.log('Scale:', sx, sy); },
      playAnimation: function(name) { console.log('Play:', name); }
    };
  }
};

console.log('Spine WebGL Minimal initialized');
`;
  }

  /**
   * ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸CSSç”Ÿæˆ
   */
  async generatePackageCSS(project) {
    const character = project.spineData?.characters?.[0];
    if (!character) {
      return '/* No character data available */';
    }

    return `/* Spine Editor Desktop v2.0 - Package CSS */

#purattokun-canvas {
  position: absolute;
  left: ${((character.x || 400) / 800 * 100).toFixed(2)}%;
  top: ${((character.y || 300) / 600 * 100).toFixed(2)}%;
  transform: translate(-50%, -50%) scale(${character.scaleX || 0.5});
  transform-origin: center center;
  z-index: 10;
}

@media (max-width: 768px) {
  #purattokun-canvas {
    width: 30%;
    height: auto;
  }
}

/* Additional responsive styles */
@media (max-width: 480px) {
  .spine-container {
    padding: 10px;
    margin: 10px;
  }
  
  .controls .btn {
    padding: 10px 14px;
    font-size: 12px;
  }
}`;
  }

  /**
   * ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ–‡æ›¸è¿½åŠ 
   */
  async addProjectDocumentation(packageData, project) {
    // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±JSON
    const projectInfo = this.generateProjectInfo(project);
    packageData.files.set('PROJECT-INFO.json', JSON.stringify(projectInfo, null, 2));

    // READMEãƒ•ã‚¡ã‚¤ãƒ«
    const readme = this.generateReadme(project);
    packageData.files.set('README.md', readme);

    console.log('ğŸ“ Project documentation added');
  }

  /**
   * ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±ç”Ÿæˆ
   */
  generateProjectInfo(project) {
    return {
      project: {
        name: project.name || 'Untitled Spine Project',
        version: project.version || '1.0.0',
        created: project.created || new Date().toISOString(),
        generator: 'Spine Editor Desktop v2.0'
      },
      spine: {
        characters: project.spineData?.characters?.length || 0,
        animations: this.extractAnimationList(project),
        viewport: project.settings?.viewport || { width: 800, height: 600 }
      },
      deployment: {
        instructions: [
          '1. Extract all files to your web server directory',
          '2. Open index.html in a web browser',
          '3. Spine animations will load automatically',
          '4. Customize CSS for your specific layout needs'
        ],
        requirements: [
          'Modern web browser with WebGL support',
          'Web server (local or remote)',
          'No additional dependencies required'
        ]
      },
      files: {
        html: 'index.html - Main HTML file',
        css: 'spine-styles.css - Character positioning styles',
        js: 'spine-webgl.js - Spine WebGL runtime library',
        assets: 'assets/ - Spine character files (.json, .atlas, .png)'
      }
    };
  }

  /**
   * READMEç”Ÿæˆ
   */
  generateReadme(project) {
    return `# ${project.name || 'Spine Animation Project'}

Generated by Spine Editor Desktop v2.0  
Created: ${new Date().toLocaleDateString()}

## Quick Start

1. Extract all files to your web server directory
2. Open \`index.html\` in a modern web browser
3. Your Spine animation will load automatically

## Files Structure

- \`index.html\` - Main HTML file with embedded Spine configuration
- \`spine-styles.css\` - Character positioning and styling
- \`spine-webgl.js\` - Spine WebGL runtime library (self-contained)
- \`assets/\` - Spine character files (.json, .atlas, .png)
- \`PROJECT-INFO.json\` - Detailed project information

## Customization

- Edit \`spine-styles.css\` to adjust character positioning
- Modify \`index.html\` to integrate with your website
- All Spine animations are ready to use without additional setup

## Browser Support

Requires modern web browser with WebGL support:
- Chrome 30+
- Firefox 25+
- Safari 8+
- Edge 12+

## Troubleshooting

- If animations don't load, ensure all files are served via HTTP/HTTPS
- Check browser console for any WebGL errors
- Verify that all asset files are in the \`assets/\` directory

---
Created with Spine Editor Desktop v2.0`;
  }

  /**
   * ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒªã‚¹ãƒˆæŠ½å‡º
   */
  extractAnimationList(project) {
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    return ['syutugen', 'taiki', 'click'];
  }

  /**
   * ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºè¨ˆç®—
   */
  calculateTotalSize(fileMap) {
    let totalSize = 0;
    for (const content of fileMap.values()) {
      totalSize += new Blob([content]).size;
    }
    return totalSize;
  }

  /**
   * ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
   */
  formatFileSize(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  /**
   * ãƒã‚¤ãƒŠãƒªãƒ•ã‚¡ã‚¤ãƒ«åˆ¤å®š
   */
  isBinaryFile(filename) {
    const binaryExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.atlas', '.zip', '.ttf', '.woff'];
    return binaryExtensions.some(ext => filename.toLowerCase().endsWith(ext));
  }

  /**
   * ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆä½œæˆ
   */
  createManifest(packageData) {
    return {
      name: packageData.metadata.name,
      version: packageData.metadata.version,
      generator: packageData.metadata.generator,
      created: new Date().toISOString(),
      files: {
        count: packageData.files.size,
        list: Array.from(packageData.files.keys()),
        totalSize: packageData.totalSize
      },
      instructions: {
        'deployment': 'Extract all files to web server directory',
        'testing': 'Open index.html in web browser',
        'spine': 'Spine animations are embedded and ready to use'
      }
    };
  }

  /**
   * ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ä½œæˆ
   */
  async createFallbackArchive(packageData, outputPath) {
    console.warn('âš ï¸ Creating fallback archive instead of ZIP');
    
    const archiveData = Array.from(packageData.files.entries())
      .map(([filename, content]) => `FILE: ${filename}\n${content}\n`)
      .join('\n---SPINE-EDITOR-SEPARATOR---\n\n');

    const result = await window.electronAPI.writeFile(outputPath, archiveData);
    if (!result.success) {
      throw new Error(result.error || 'Fallback archive creation failed');
    }

    console.log('ğŸ“œ Fallback archive created successfully');
  }

  /**
   * ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿å–å¾—
   */
  getPackageData() {
    return this.packageData;
  }

  /**
   * ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢
   */
  clearPackageData() {
    this.packageData = null;
  }
}

// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
export default ExportPackage;