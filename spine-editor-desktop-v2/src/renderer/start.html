<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spine Editor v2.0 - Demo</title>
    <style>
        /* æœ€å°4ãƒ‘ãƒãƒ«ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: #f5f5f5;
            height: 100vh;
            overflow: hidden;
        }

        .demo-container {
            display: grid;
            grid-template-columns: 250px 1fr 250px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 1px;
            background-color: #ddd;
        }

        .demo-header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .demo-title {
            font-size: 18px;
            font-weight: 600;
            margin: 0;
        }

        .demo-actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background-color: rgba(255,255,255,0.2);
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: rgba(255,255,255,0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: #4CAF50;
        }

        .btn-primary:hover {
            background-color: #45a049;
        }

        /* å·¦ãƒ‘ãƒãƒ«: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ­ãƒ¼ãƒ€ãƒ¼ */
        .project-panel {
            background-color: white;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            background-color: #f8f9fa;
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
            font-weight: 600;
            font-size: 14px;
            color: #333;
        }

        .panel-content {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }

        /* ä¸­å¤®ãƒ‘ãƒãƒ«: HTMLãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ */
        .preview-panel {
            background-color: white;
            display: flex;
            flex-direction: column;
        }

        .preview-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f9f9f9;
            position: relative;
            transition: all 0.2s ease;
        }
        
        .preview-content.drag-over {
            background-color: #e3f2fd;
            border: 2px dashed #007ACC;
        }

        .preview-placeholder {
            color: #888;
            font-size: 16px;
            text-align: center;
        }

        .preview-iframe {
            width: 100%;
            height: 100%;
            border: none;
            background-color: white;
        }

        /* å³ãƒ‘ãƒãƒ«: ãƒšãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ + Spineåˆ¶å¾¡ */
        .control-panel {
            background-color: white;
            border-left: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
        }

        .control-section {
            border-bottom: 1px solid #e0e0e0;
        }

        .control-section:last-child {
            border-bottom: none;
            flex: 1;
        }

        /* ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆ */
        .file-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .file-item {
            padding: 8px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            font-size: 13px;
        }

        .file-item:hover {
            background-color: #f5f5f5;
        }

        .file-item.selected {
            background-color: #e3f2fd;
            color: #1976d2;
        }

        /* Spineåˆ¶å¾¡ã‚¨ãƒªã‚¢ */
        .spine-controls {
            padding: 15px;
        }

        .spine-position {
            margin-bottom: 15px;
        }

        .position-input {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            align-items: center;
        }

        .position-input label {
            font-size: 12px;
            color: #666;
            width: 30px;
        }

        .position-input input {
            width: 80px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }

        /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤º */
        .loading {
            color: #666;
            font-size: 14px;
            text-align: center;
            padding: 20px;
        }

        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º */
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 8px;
        }

        .status-ready { background-color: #4CAF50; }
        .status-loading { background-color: #FF9800; }
        .status-error { background-color: #F44336; }

        /* ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒŠãƒ¼æ–¹å¼ã‚¹ã‚¿ã‚¤ãƒ« */
        .file-section {
            margin-bottom: 2px;
        }

        .file-section-header {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            color: #495057;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .file-section-header:hover {
            background-color: #e9ecef;
        }

        .section-toggle {
            width: 16px;
            text-align: center;
            margin-right: 8px;
            font-size: 12px;
            transition: transform 0.2s;
        }

        .section-title {
            flex: 1;
        }

        .section-count {
            color: #6c757d;
            font-size: 11px;
            font-weight: normal;
        }

        .file-section-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            border-left: 2px solid #dee2e6;
            margin-left: 8px;
        }

        .file-section-content.expanded {
            max-height: 1000px;
        }

        .file-section-content.collapsed {
            max-height: 0;
        }

        .file-section .file-item {
            padding: 6px 20px;
            cursor: pointer;
            border-bottom: 1px solid #f8f9fa;
            font-size: 12px;
            margin: 0;
            background-color: white;
        }

        .file-section .file-item:hover {
            background-color: #f8f9fa;
        }

        .file-section .file-item.selected {
            background-color: #e3f2fd;
            color: #1976d2;
            border-left: 3px solid #2196f3;
        }

        /* Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¢ã‚¤ãƒ†ãƒ  */
        .spine-character-item {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            cursor: grab;
            border-bottom: 1px solid #f0f0f0;
            transition: all 0.2s ease;
            background: white;
        }

        .spine-character-item:hover {
            background-color: #f8f9ff;
            transform: translateX(2px);
        }

        .spine-character-item.dragging {
            opacity: 0.7;
            background-color: #e8f5e8;
            cursor: grabbing;
        }

        .character-icon {
            font-size: 20px;
            margin-right: 10px;
            flex-shrink: 0;
        }

        .character-info {
            flex: 1;
            min-width: 0;
        }

        .character-name {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .character-path {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
        }

        /* ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚°ãƒ«ãƒ¼ãƒ— */
        .section-group {
            border-bottom: 1px solid #e0e0e0;
        }

        .section-group:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body>
    <div class="demo-container">
        <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
        <header class="demo-header">
            <div>
                <h1 class="demo-title">Spine Editor v2.0 Demo</h1>
            </div>
            <div class="demo-actions">
                <button id="btn-open-folder" class="btn btn-primary">ğŸ“ ãƒ•ã‚©ãƒ«ãƒ€ã‚’é–‹ã</button>
                <button id="btn-load-spine-folder" class="btn">ğŸ­ Spineãƒ•ã‚©ãƒ«ãƒ€é¸æŠ</button>
                <button id="btn-export-package" class="btn" disabled>ğŸ“¦ ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å‡ºåŠ›</button>
                <button id="btn-preview-package" class="btn" disabled>ğŸ‘ï¸ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</button>
                <span id="status-indicator" class="status-indicator status-ready"></span>
            </div>
        </header>

        <!-- å·¦ãƒ‘ãƒãƒ«: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ­ãƒ¼ãƒ€ãƒ¼ -->
        <div class="project-panel">
            <!-- HTMLãƒ•ã‚¡ã‚¤ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
            <div class="section-group">
                <div class="panel-header">Project Files</div>
                <div class="panel-content">
                    <div id="project-status" class="loading">ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã—ã¦ãã ã•ã„</div>
                    <div id="file-list" class="file-list" style="display: none;"></div>
                </div>
            </div>
            
            <!-- Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
            <div class="section-group">
                <div class="panel-header">ğŸ­ Spine Characters</div>
                <div class="panel-content">
                    <div id="spine-character-status" class="loading">Spineãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã—ã¦ãã ã•ã„</div>
                    <div id="spine-character-list" class="file-list" style="display: none;"></div>
                </div>
            </div>
        </div>

        <!-- ä¸­å¤®ãƒ‘ãƒãƒ«: HTMLãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
        <div class="preview-panel">
            <div class="panel-header">HTML Preview</div>
            <div class="preview-content" id="preview-content">
                <div id="preview-placeholder" class="preview-placeholder">
                    HTMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã™ã‚‹ã¨<br>ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã¾ã™<br><br>
                    <small style="color: #888;">ğŸ’¡ å·¦ã‹ã‚‰Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã—ã¦è¿½åŠ ã§ãã¾ã™</small>
                </div>
                <iframe id="preview-iframe" class="preview-iframe" style="display: none;"></iframe>
                <!-- Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
                <div id="spine-character-container" class="spine-character-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
                    <!-- Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒã“ã“ã«å‹•çš„è¿½åŠ ã•ã‚Œã‚‹ -->
                </div>
            </div>
        </div>

        <!-- å³ãƒ‘ãƒãƒ«: ãƒšãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ + Spineåˆ¶å¾¡ -->
        <div class="control-panel">
            <!-- ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã‚¨ãƒªã‚¢ -->
            <div class="control-section">
                <div class="panel-header">Page Selector</div>
                <div class="panel-content">
                    <div id="page-list" class="file-list">
                        <div class="loading">HTMLãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“</div>
                    </div>
                </div>
            </div>

            <!-- Spineåˆ¶å¾¡ã‚¨ãƒªã‚¢ -->
            <div class="control-section">
                <div class="panel-header">Spine Control</div>
                <div class="spine-controls">
                    <div class="spine-position">
                        <div class="position-input">
                            <label>X:</label>
                            <input id="spine-x" type="number" step="1" value="0">
                        </div>
                        <div class="position-input">
                            <label>Y:</label>
                            <input id="spine-y" type="number" step="1" value="0">
                        </div>
                    </div>
                    <button id="btn-add-spine" class="btn" style="width: 100%; margin-bottom: 10px;" disabled>
                        ğŸ­ Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¿½åŠ 
                    </button>
                    <button id="btn-save-position" class="btn" style="width: 100%;" disabled>
                        ğŸ’¾ ä½ç½®ã‚’ä¿å­˜
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script src="js/demo-modules.js"></script>
    <script src="js/spine-core.js"></script>
    <script src="js/spine-renderer.js"></script>
    
    <script>
        // ãƒ‡ãƒ¢ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
        class DemoApp {
            constructor() {
                this.currentProject = null;
                this.currentPage = null;
                this.spinePosition = { x: 100, y: 100 };
                this.spineCharacter = null;
                
                // ãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹è¨˜æ†¶æ©Ÿèƒ½
                this.savedPaths = {
                    project: localStorage.getItem('spine-editor-project-path'),
                    spine: localStorage.getItem('spine-editor-spine-path')
                };
                
                // Spine SystemåˆæœŸåŒ–
                this.spineCore = new SpineCore();
                this.spineRenderer = null;
                
                this.initializeUI();
                this.bindEvents();
                this.initializeSpineSystem();
            }

            initializeUI() {
                this.statusIndicator = document.getElementById('status-indicator');
                this.projectStatus = document.getElementById('project-status');
                this.fileList = document.getElementById('file-list');
                this.pageList = document.getElementById('page-list');
                this.previewPlaceholder = document.getElementById('preview-placeholder');
                this.previewIframe = document.getElementById('preview-iframe');
                
                // Spineé–¢é€£è¦ç´ 
                this.spineCharacterStatus = document.getElementById('spine-character-status');
                this.spineCharacterList = document.getElementById('spine-character-list');
                
                this.btnOpenFolder = document.getElementById('btn-open-folder');
                this.btnLoadSpineFolder = document.getElementById('btn-load-spine-folder');
                this.btnExportPackage = document.getElementById('btn-export-package');
                this.btnPreviewPackage = document.getElementById('btn-preview-package');
                this.btnAddSpine = document.getElementById('btn-add-spine');
                this.btnSavePosition = document.getElementById('btn-save-position');
                
                this.spineXInput = document.getElementById('spine-x');
                this.spineYInput = document.getElementById('spine-y');
                
                // ä¿å­˜ã•ã‚ŒãŸãƒ‘ã‚¹ãŒã‚ã‚Œã°è‡ªå‹•èª­ã¿è¾¼ã¿
                this.loadSavedPaths();
                
                // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³è¨­å®š
                this.setupDropZone();
            }

            // ä¿å­˜ã•ã‚ŒãŸãƒ‘ã‚¹è‡ªå‹•èª­ã¿è¾¼ã¿
            async loadSavedPaths() {
                console.log('ğŸ”§ localStorageçŠ¶æ…‹ç¢ºèª:');
                console.log('  - project:', localStorage.getItem('spine-editor-project-path'));
                console.log('  - spine:', localStorage.getItem('spine-editor-spine-path'));
                console.log('ğŸ”§ this.savedPaths:', this.savedPaths);
                
                if (this.savedPaths.project) {
                    console.log('ğŸ”„ Auto-loading saved project path:', this.savedPaths.project);
                    // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ã‚¹ã‚’è‡ªå‹•è¨­å®šï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã¯è¡¨ç¤ºã—ãªã„ï¼‰
                    this.currentProject = this.savedPaths.project;
                }
                
                if (this.savedPaths.spine) {
                    console.log('ğŸ”„ Auto-loading saved spine path:', this.savedPaths.spine);
                    // Spineãƒ‘ã‚¹ã‹ã‚‰è‡ªå‹•æ¤œå‡ºï¼ˆUIæ›´æ–°ã¯è¡Œã‚ãªã„ã€æ¬¡å›ã®ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚ã«ä½¿ç”¨ï¼‰
                }
            }

            /**
             * ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³è¨­å®šï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢ã§Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼å—ã‘å…¥ã‚Œï¼‰
             */
            setupDropZone() {
                const previewContent = document.getElementById('preview-content');
                const spineContainer = document.getElementById('spine-character-container');
                
                if (!previewContent || !spineContainer) {
                    console.warn('âš ï¸ ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                // ãƒ‰ãƒ©ãƒƒã‚°ã‚ªãƒ¼ãƒãƒ¼ï¼ˆãƒ‰ãƒ­ãƒƒãƒ—å¯èƒ½é ˜åŸŸã®è¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼‰
                previewContent.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                    previewContent.classList.add('drag-over');
                });
                
                // ãƒ‰ãƒ©ãƒƒã‚°ãƒªãƒ¼ãƒ–ï¼ˆãƒ‰ãƒ­ãƒƒãƒ—å¯èƒ½é ˜åŸŸã‚’é›¢ã‚ŒãŸæ™‚ï¼‰
                previewContent.addEventListener('dragleave', (e) => {
                    // å­è¦ç´ ã¸ã®ç§»å‹•ã¯ç„¡è¦–ï¼ˆãƒãƒ–ãƒªãƒ³ã‚°å¯¾ç­–ï¼‰
                    if (!previewContent.contains(e.relatedTarget)) {
                        previewContent.classList.remove('drag-over');
                    }
                });
                
                // ãƒ‰ãƒ­ãƒƒãƒ—ï¼ˆå®Ÿéš›ã«Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’é…ç½®ï¼‰
                previewContent.addEventListener('drop', (e) => {
                    e.preventDefault();
                    previewContent.classList.remove('drag-over');
                    
                    try {
                        // ãƒ‰ãƒ©ãƒƒã‚°ã•ã‚ŒãŸã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                        const characterDataStr = e.dataTransfer.getData('application/json');
                        if (!characterDataStr) {
                            console.warn('âš ï¸ ãƒ‰ãƒ­ãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                            return;
                        }
                        
                        const characterData = JSON.parse(characterDataStr);
                        console.log('ğŸ­ Dropped character:', characterData);
                        
                        // ãƒ‰ãƒ­ãƒƒãƒ—ä½ç½®ã‚’è¨ˆç®—ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢å†…ã®ç›¸å¯¾ä½ç½®ï¼‰
                        const rect = previewContent.getBoundingClientRect();
                        const dropX = e.clientX - rect.left;
                        const dropY = e.clientY - rect.top;
                        
                        // Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã«è¿½åŠ 
                        this.addSpineCharacterToPreview(characterData, dropX, dropY);
                        
                    } catch (error) {
                        console.error('âŒ ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                        this.updateStatus('error', `ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¿½åŠ å¤±æ•—: ${error.message}`);
                    }
                });
                
                console.log('âœ… ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³è¨­å®šå®Œäº†');
            }

            /**
             * ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢ã«Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’è¿½åŠ 
             */
            async addSpineCharacterToPreview(characterData, x, y) {
                try {
                    this.updateStatus('loading', 'Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’èª­ã¿è¾¼ã¿ä¸­...');
                    
                    const spineContainer = document.getElementById('spine-character-container');
                    
                    // ä¸€æ„ã®IDã‚’ç”Ÿæˆ
                    const characterId = `spine-character-${Date.now()}`;
                    
                    // Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¦ç´ ã‚’ä½œæˆ
                    const characterElement = document.createElement('div');
                    characterElement.id = characterId;
                    characterElement.className = 'spine-character-element';
                    characterElement.style.cssText = `
                        position: absolute;
                        left: ${x}px;
                        top: ${y}px;
                        width: 200px;
                        height: 200px;
                        border: 2px dashed #007ACC;
                        background: rgba(0, 122, 204, 0.1);
                        border-radius: 8px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        cursor: move;
                        pointer-events: auto;
                        user-select: none;
                    `;
                    
                    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æƒ…å ±ã‚’è¡¨ç¤º
                    characterElement.innerHTML = `
                        <div style="text-align: center; color: #007ACC;">
                            <div style="font-size: 24px;">ğŸ­</div>
                            <div style="font-size: 14px; font-weight: bold;">${characterData.name}</div>
                            <div style="font-size: 12px; opacity: 0.7;">Spine Character</div>
                        </div>
                    `;
                    
                    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¦ç´ ã«ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½ã‚’è¿½åŠ 
                    this.setupCharacterDrag(characterElement, characterData);
                    
                    // ã‚³ãƒ³ãƒ†ãƒŠã«è¿½åŠ 
                    spineContainer.appendChild(characterElement);
                    
                    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒªã‚¹ãƒˆã«ç™»éŒ²
                    if (!this.spineCharacters) {
                        this.spineCharacters = [];
                    }
                    this.spineCharacters.push({
                        id: characterId,
                        element: characterElement,
                        data: characterData,
                        position: { x, y }
                    });
                    
                    this.updateStatus('ready', `ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã€Œ${characterData.name}ã€ã‚’è¿½åŠ ã—ã¾ã—ãŸ`);
                    console.log(`âœ… Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã€Œ${characterData.name}ã€ã‚’ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã«è¿½åŠ å®Œäº†`);
                    
                } catch (error) {
                    console.error('âŒ Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¿½åŠ ã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus('error', `ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¿½åŠ å¤±æ•—: ${error.message}`);
                }
            }

            /**
             * ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¦ç´ ã®ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½è¨­å®šï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†…ã§ã®ç§»å‹•ï¼‰
             */
            setupCharacterDrag(element, characterData) {
                let isDragging = false;
                let dragStartX = 0;
                let dragStartY = 0;
                let elementStartX = 0;
                let elementStartY = 0;
                
                element.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    elementStartX = parseInt(element.style.left) || 0;
                    elementStartY = parseInt(element.style.top) || 0;
                    
                    element.style.opacity = '0.8';
                    element.style.transform = 'scale(1.05)';
                    element.style.zIndex = '1000';
                    
                    e.preventDefault();
                    e.stopPropagation();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;
                    
                    const newX = elementStartX + deltaX;
                    const newY = elementStartY + deltaY;
                    
                    element.style.left = `${newX}px`;
                    element.style.top = `${newY}px`;
                });
                
                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        element.style.opacity = '1';
                        element.style.transform = 'scale(1)';
                        element.style.zIndex = '';
                        
                        // ä½ç½®ã‚’ä¿å­˜
                        const characterEntry = this.spineCharacters?.find(c => c.element === element);
                        if (characterEntry) {
                            characterEntry.position.x = parseInt(element.style.left) || 0;
                            characterEntry.position.y = parseInt(element.style.top) || 0;
                            console.log(`ğŸ“ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã€Œ${characterData.name}ã€ä½ç½®æ›´æ–°:`, characterEntry.position);
                        }
                    }
                });
            }

            bindEvents() {
                console.log('ğŸ”§ Setting up event handlers...');
                console.log('ğŸ”§ btnLoadSpineFolder element:', this.btnLoadSpineFolder);
                
                this.btnOpenFolder.addEventListener('click', () => this.openFolder());
                this.btnLoadSpineFolder.addEventListener('click', () => {
                    console.log('ğŸ­ Spine folder button clicked!');
                    this.loadSpineFolder();
                });
                this.btnExportPackage.addEventListener('click', () => this.exportPackage());
                this.btnPreviewPackage.addEventListener('click', () => this.previewPackage());
                this.btnAddSpine.addEventListener('click', () => this.addSpineCharacter());
                this.btnSavePosition.addEventListener('click', () => this.savePosition());
                
                this.spineXInput.addEventListener('change', (e) => {
                    this.spinePosition.x = parseInt(e.target.value) || 0;
                    this.updateSpinePosition();
                });
                
                this.spineYInput.addEventListener('change', (e) => {
                    this.spinePosition.y = parseInt(e.target.value) || 0;
                    this.updateSpinePosition();
                });
            }

            /**
             * Spineã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–
             */
            initializeSpineSystem() {
                try {
                    // SpineCoreåˆæœŸåŒ–
                    const success = this.spineCore.initialize();
                    if (!success) {
                        console.error('âŒ SpineCoreåˆæœŸåŒ–å¤±æ•—');
                        return;
                    }
                    
                    // SpineRendereråˆæœŸåŒ–
                    this.spineRenderer = new SpineRenderer(this.spineCore);
                    
                    // ä¿å­˜ã•ã‚ŒãŸä½ç½®ã‚’å¾©å…ƒ
                    this.restorePosition();
                    
                    console.log('âœ… Spine SystemåˆæœŸåŒ–å®Œäº†');
                    
                } catch (error) {
                    console.error('âŒ Spineã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                }
            }

            updateStatus(status, message) {
                this.statusIndicator.className = `status-indicator status-${status}`;
                this.projectStatus.textContent = message;
            }

            async openFolder() {
                this.updateStatus('loading', 'ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠä¸­...');
                
                // è©³ç´°ãƒ‡ãƒãƒƒã‚°: localStorageç›´æ¥ç¢ºèª
                const directProject = localStorage.getItem('spine-editor-project-path');
                console.log('ğŸ”§ localStorageç›´æ¥ç¢ºèª project:', directProject);
                console.log('ğŸ”§ this.savedPaths.project:', this.savedPaths.project);
                console.log('ğŸ”§ å€¤ãŒåŒã˜ã‹:', directProject === this.savedPaths.project);
                
                try {
                    // ä¿å­˜ã•ã‚ŒãŸãƒ‘ã‚¹ã‚’åˆæœŸãƒ•ã‚©ãƒ«ãƒ€ã¨ã—ã¦ä½¿ç”¨ï¼ˆæœ‰åŠ¹ãªå ´åˆã®ã¿ï¼‰
                    const initialPath = this.savedPaths.project || null;
                    console.log('ğŸ”§ Project initial path:', initialPath);
                    console.log('ğŸ”§ initialPathã‚¿ã‚¤ãƒ—:', typeof initialPath, 'é•·ã•:', initialPath?.length);
                    const result = await window.projectLoader.selectFolder(initialPath);
                    if (result.success) {
                        this.currentProject = result.path;
                        
                        // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ã‚¹ã‚’ä¿å­˜
                        localStorage.setItem('spine-editor-project-path', result.path);
                        console.log('ğŸ’¾ Project path saved:', result.path);
                        
                        // this.savedPathsã‚‚æ›´æ–°
                        this.savedPaths.project = result.path;
                        console.log('ğŸ”„ this.savedPaths.project updated:', this.savedPaths.project);
                        
                        // ã‚µãƒ¼ãƒãƒ¼ã«ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‘ã‚¹ã‚’è¨­å®š
                        if (window.electronAPI && window.electronAPI.server) {
                            const serverResult = await window.electronAPI.server.setProjectPath(result.path);
                            console.log('ğŸ”§ Server project path set:', serverResult);
                        }
                        
                        this.loadProjectFiles(result.files);
                        this.updateStatus('ready', `ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèª­ã¿è¾¼ã¿å®Œäº†: ${result.files.length} ãƒ•ã‚¡ã‚¤ãƒ«`);
                    } else if (result.canceled) {
                        this.updateStatus('ready', 'ãƒ•ã‚©ãƒ«ãƒ€é¸æŠãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ');
                    } else {
                        this.updateStatus('error', 'ãƒ•ã‚©ãƒ«ãƒ€é¸æŠã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                } catch (error) {
                    console.error('ãƒ•ã‚©ãƒ«ãƒ€é¸æŠã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus('error', 'ãƒ•ã‚©ãƒ«ãƒ€é¸æŠã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            }

            async loadSpineFolder() {
                console.log('ğŸ­ loadSpineFolder() method called!');
                this.updateStatus('loading', 'Spineãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠä¸­...');
                
                // ãƒ‡ãƒãƒƒã‚°: é–¢æ•°å­˜åœ¨ç¢ºèª
                console.log('ğŸ”§ window.projectLoader:', window.projectLoader);
                console.log('ğŸ”§ selectSpineFolder exists:', typeof window.projectLoader?.selectSpineFolder);
                
                try {
                    // é–¢æ•°å­˜åœ¨ãƒã‚§ãƒƒã‚¯
                    if (!window.projectLoader || typeof window.projectLoader.selectSpineFolder !== 'function') {
                        console.error('âŒ selectSpineFolder function not found, falling back to selectFolder');
                        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å…ƒã®é–¢æ•°ã‚’ä½¿ç”¨
                        const initialSpinePath = this.savedPaths.spine || null;
                        console.log('ğŸ”§ Spine initial path (fallback):', initialSpinePath);
                        const result = await window.projectLoader.selectFolder(initialSpinePath);
                        
                        if (result.success && result.path) {
                            console.log('ğŸ­ Selected Spine folder (fallback):', result.path);
                            
                            // Spineãƒ‘ã‚¹ã‚’ä¿å­˜
                            localStorage.setItem('spine-editor-spine-path', result.path);
                            console.log('ğŸ’¾ Spine path saved:', result.path);
                            
                            // this.savedPathsã‚‚æ›´æ–°ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†å†…ï¼‰
                            this.savedPaths.spine = result.path;
                            console.log('ğŸ”„ this.savedPaths.spine updated (fallback):', this.savedPaths.spine);
                            
                            // ä»¥ä¸‹ã¯æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã¨åŒã˜å‡¦ç†
                            console.log('ğŸ”§ Starting Spine file detection...');
                            const spineFiles = await this.detectSpineFiles(result.path);
                            console.log('ğŸ”§ Detection completed. Found files:', spineFiles);
                            
                            this.displaySpineCharacters(spineFiles);
                            console.log('ğŸ­ Detected Spine files:', spineFiles);
                            this.updateStatus('ready', `Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æ¤œå‡ºå®Œäº†: ${spineFiles.length} å€‹`);
                        } else if (result.canceled) {
                            this.updateStatus('ready', 'Spineãƒ•ã‚©ãƒ«ãƒ€é¸æŠãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ');
                        } else {
                            this.updateStatus('error', 'Spineãƒ•ã‚©ãƒ«ãƒ€é¸æŠã«å¤±æ•—ã—ã¾ã—ãŸ');
                        }
                        return;
                    }
                    
                    // è©³ç´°ãƒ‡ãƒãƒƒã‚°: localStorageç›´æ¥ç¢ºèª
                    const directSpine = localStorage.getItem('spine-editor-spine-path');
                    console.log('ğŸ”§ localStorageç›´æ¥ç¢ºèª spine:', directSpine);
                    console.log('ğŸ”§ this.savedPaths.spine:', this.savedPaths.spine);
                    console.log('ğŸ”§ å€¤ãŒåŒã˜ã‹:', directSpine === this.savedPaths.spine);
                    
                    // Spineå°‚ç”¨ãƒ•ã‚©ãƒ«ãƒ€é¸æŠé–¢æ•°ã‚’ä½¿ç”¨ãƒ»ä¿å­˜ã•ã‚ŒãŸSpineãƒ‘ã‚¹ã‚’åˆæœŸãƒ•ã‚©ãƒ«ãƒ€ã¨ã—ã¦ä½¿ç”¨ï¼ˆæœ‰åŠ¹ãªå ´åˆã®ã¿ï¼‰
                    const initialSpinePath = this.savedPaths.spine || null;
                    console.log('ğŸ”§ Spine initial path:', initialSpinePath);
                    console.log('ğŸ”§ initialSpinePathã‚¿ã‚¤ãƒ—:', typeof initialSpinePath, 'é•·ã•:', initialSpinePath?.length);
                    const result = await window.projectLoader.selectSpineFolder(initialSpinePath);
                    
                    if (result.success && result.path) {
                        console.log('ğŸ­ Selected Spine folder:', result.path);
                        
                        // Spineãƒ‘ã‚¹ã‚’ä¿å­˜
                        localStorage.setItem('spine-editor-spine-path', result.path);
                        console.log('ğŸ’¾ Spine path saved:', result.path);
                        
                        // this.savedPathsã‚‚æ›´æ–°
                        this.savedPaths.spine = result.path;
                        console.log('ğŸ”„ this.savedPaths.spine updated:', this.savedPaths.spine);
                        
                        console.log('ğŸ”§ Starting Spine file detection...');
                        
                        // Spineãƒ•ã‚¡ã‚¤ãƒ«æ¤œå‡ºå‡¦ç†ï¼ˆä¾‹: .json/.atlas/.pngï¼‰
                        const spineFiles = await this.detectSpineFiles(result.path);
                        console.log('ğŸ”§ Detection completed. Found files:', spineFiles);
                        
                        if (spineFiles.length > 0) {
                            this.updateStatus('ready', `Spineãƒ•ã‚¡ã‚¤ãƒ«æ¤œå‡º: ${spineFiles.length}å€‹ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼`);
                            console.log('ğŸ­ Detected Spine files:', spineFiles);
                            
                            // å·¦ãƒ‘ãƒãƒ«ã«Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä¸€è¦§è¡¨ç¤º
                            this.displaySpineCharacters(spineFiles);
                        } else {
                            this.updateStatus('ready', 'Spineãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
                            this.spineCharacterStatus.textContent = 'Spineãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ';
                            this.spineCharacterList.style.display = 'none';
                        }
                    }
                } catch (error) {
                    console.error('ğŸš¨ Spineãƒ•ã‚©ãƒ«ãƒ€é¸æŠã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus('error', 'Spineãƒ•ã‚©ãƒ«ãƒ€é¸æŠã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            }

            async detectSpineFiles(folderPath) {
                try {
                    console.log('ğŸ” Scanning folder:', folderPath);
                    
                    // ElectronAPIã§ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¹ã‚­ãƒ£ãƒ³
                    const scanResult = await window.electronAPI.fs.scanDirectory(
                        folderPath, 
                        ['.json', '.atlas', '.png']
                    );
                    
                    console.log('ğŸ“‹ Scan result:', scanResult);
                    
                    if (!scanResult.success) {
                        console.warn('ğŸš¨ Spine folder scan failed:', scanResult.error);
                        return [];
                    }
                    
                    // .json/.atlas/.pngã®ã‚»ãƒƒãƒˆã‚’æ¤œå‡º
                    const jsonFiles = scanResult.files?.json || [];
                    const atlasFiles = scanResult.files?.atlas || [];
                    const pngFiles = scanResult.files?.png || [];
                    
                    console.log('ğŸ“ Found files:');
                    console.log('  JSON files:', jsonFiles);
                    console.log('  Atlas files:', atlasFiles);
                    console.log('  PNG files:', pngFiles);
                    
                    const spineCharacters = [];
                    
                    for (const jsonFile of jsonFiles) {
                        // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚©ãƒ«ãƒ€ã‚’é™¤å¤–
                        if (this.isBackupPath(jsonFile)) {
                            console.log('ğŸš« Skipping backup file:', jsonFile);
                            continue;
                        }
                        
                        const baseName = jsonFile.replace(/\.json$/, '').split('/').pop();
                        const atlasFile = atlasFiles.find(f => f.includes(baseName + '.atlas') && !this.isBackupPath(f));
                        const pngFile = pngFiles.find(f => f.includes(baseName + '.png') && !this.isBackupPath(f));
                        
                        if (atlasFile && pngFile) {
                            spineCharacters.push({
                                name: baseName,
                                jsonPath: jsonFile,
                                atlasPath: atlasFile,
                                texturePath: pngFile,
                                folderPath: this.getCharacterFolder(jsonFile)
                            });
                        }
                    }
                    
                    return spineCharacters;
                } catch (error) {
                    console.error('ğŸš¨ Spine detection error:', error);
                    return [];
                }
            }

            // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‘ã‚¹åˆ¤å®šï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚©ãƒ«ãƒ€é™¤å¤–ï¼‰
            isBackupPath(filePath) {
                const backupKeywords = ['backup', 'bak', 'ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—', 'archive', 'old'];
                const pathLower = filePath.toLowerCase();
                return backupKeywords.some(keyword => pathLower.includes(keyword));
            }

            // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹å–å¾—
            getCharacterFolder(jsonPath) {
                const parts = jsonPath.split('/');
                parts.pop(); // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’é™¤å»
                return parts.join('/');
            }

            /**
             * ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥è¡¨ç¤ºï¼ˆåˆ¥ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦é¢¨ï¼‰
             */
            showToastNotification(message) {
                // æ—¢å­˜ã®ãƒˆãƒ¼ã‚¹ãƒˆãŒã‚ã‚Œã°å‰Šé™¤
                const existingToast = document.querySelector('.toast-notification');
                if (existingToast) {
                    existingToast.remove();
                }
                
                // ãƒˆãƒ¼ã‚¹ãƒˆè¦ç´ ã‚’ä½œæˆ
                const toast = document.createElement('div');
                toast.className = 'toast-notification';
                toast.textContent = message;
                
                // ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š
                toast.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #4CAF50;
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    font-size: 14px;
                    font-weight: 500;
                    z-index: 10000;
                    opacity: 0;
                    transform: translateX(100px);
                    transition: all 0.3s ease;
                    max-width: 300px;
                    word-wrap: break-word;
                `;
                
                // ãƒšãƒ¼ã‚¸ã«è¿½åŠ 
                document.body.appendChild(toast);
                
                // ãƒ•ãƒ¯ãƒƒã¨ç¾ã‚Œã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                setTimeout(() => {
                    toast.style.opacity = '1';
                    toast.style.transform = 'translateX(0)';
                }, 10);
                
                // 2ç§’å¾Œã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã—ã¦å‰Šé™¤
                setTimeout(() => {
                    toast.style.opacity = '0';
                    toast.style.transform = 'translateX(100px)';
                    
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†å¾Œã«è¦ç´ å‰Šé™¤
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300);
                }, 2000);
            }

            displaySpineCharacters(spineFiles) {
                console.log('ğŸ­ Displaying Spine characters:', spineFiles);
                
                // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¦ç´ ã¯éè¡¨ç¤ºã«ã™ã‚‹ï¼ˆä½¿ç”¨ã—ãªã„ï¼‰
                this.spineCharacterStatus.style.display = 'none';
                
                // åˆ¥ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦é¢¨ã®ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥ã‚’è¡¨ç¤º
                this.showToastNotification(`${spineFiles.length}å€‹ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ`);
                
                // ãƒªã‚¹ãƒˆã‚’ã‚¯ãƒªã‚¢
                this.spineCharacterList.innerHTML = '';
                
                // å„ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ãƒªã‚¹ãƒˆã«è¿½åŠ 
                spineFiles.forEach((character, index) => {
                    const item = document.createElement('div');
                    item.className = 'file-item spine-character-item';
                    item.draggable = true; // ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ã«è¨­å®š
                    item.dataset.characterId = character.name;
                    item.dataset.characterPath = character.jsonPath;
                    
                    item.innerHTML = `
                        <div class="character-icon">ğŸ­</div>
                        <div class="character-info">
                            <div class="character-name">${character.name}</div>
                            <div class="character-path">${character.folderPath.split('/').pop()}</div>
                        </div>
                    `;
                    
                    // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆè©³ç´°è¡¨ç¤ºç”¨ï¼‰
                    item.addEventListener('click', () => {
                        console.log('ğŸ­ Selected character:', character.name);
                        // TODO: ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è©³ç´°è¡¨ç¤º
                    });
                    
                    // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã§å®Ÿè£…ï¼‰
                    item.addEventListener('dragstart', (e) => {
                        console.log('ğŸ­ Drag started:', character.name);
                        e.dataTransfer.setData('application/json', JSON.stringify(character));
                        e.dataTransfer.effectAllowed = 'copy';
                        item.classList.add('dragging');
                    });
                    
                    // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†ã‚¤ãƒ™ãƒ³ãƒˆ
                    item.addEventListener('dragend', (e) => {
                        item.classList.remove('dragging');
                    });
                    
                    this.spineCharacterList.appendChild(item);
                });
                
                // ãƒªã‚¹ãƒˆã‚’è¡¨ç¤º
                this.spineCharacterList.style.display = 'block';
                
                console.log('âœ… Spine character list displayed');
            }

            loadProjectFiles(files) {
                console.log('ğŸ”§ loadProjectFileså—ä¿¡:', files);
                console.log('ğŸ”§ æœ€åˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚µãƒ³ãƒ—ãƒ«:', files[0]);
                
                // ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã‚’å®‰å…¨ã«ãƒã‚§ãƒƒã‚¯ï¼ˆã‚ˆã‚Šå¯›å®¹ãªåˆ¤å®šï¼‰
                const safeFiles = files.filter(f => {
                    if (!f) {
                        console.log('ğŸ”§ Null file detected');
                        return false;
                    }
                    
                    // nameãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¾ãŸã¯pathãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å–å¾—
                    const name = f.name || f.path || f.toString();
                    
                    if (!name || typeof name !== 'string') {
                        console.log('ğŸ”§ Invalid name for file:', f);
                        return false;
                    }
                    
                    const isHTML = name.toLowerCase().endsWith('.html') || name.toLowerCase().endsWith('.htm');
                    return isHTML;
                });
                
                console.log('ğŸ”§ å®‰å…¨ãªHTMLãƒ•ã‚¡ã‚¤ãƒ«:', safeFiles.length, 'å€‹');
                
                if (safeFiles.length === 0) {
                    this.pageList.innerHTML = '<div class="loading">HTMLãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</div>';
                    return;
                }
                
                // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒŠãƒ¼æ–¹å¼ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ•´ç†ãƒ»è¡¨ç¤º
                this.renderOutlinerView(safeFiles);
                
                // Spineåˆ¶å¾¡ã‚’æœ‰åŠ¹åŒ–
                this.btnAddSpine.disabled = false;
                this.btnExportPackage.disabled = false;
                this.btnPreviewPackage.disabled = false;
                
                console.log('ğŸ¯ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å®Œäº†:', safeFiles.length, 'å€‹');
            }
            
            /**
             * ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒŠãƒ¼æ–¹å¼ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’éšå±¤è¡¨ç¤º
             */
            renderOutlinerView(files) {
                console.log('ğŸ“‚ Creating outliner view for', files.length, 'files');
                
                // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’éšå±¤åˆ¥ã«åˆ†é¡
                const hierarchy = this.organizeFilesHierarchy(files);
                
                // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒŠãƒ¼UIã‚’ä½œæˆ
                this.pageList.innerHTML = '';
                
                // ãƒ«ãƒ¼ãƒˆç›´ä¸‹ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆå„ªå…ˆè¡¨ç¤ºï¼‰
                if (hierarchy.root.length > 0) {
                    const rootSection = this.createFileSection('ğŸ“„ ãƒ«ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«', hierarchy.root, true);
                    this.pageList.appendChild(rootSection);
                }
                
                // ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€ï¼ˆæŠ˜ã‚ŠãŸãŸã¿è¡¨ç¤ºï¼‰
                Object.keys(hierarchy.folders).forEach(folderName => {
                    const folderFiles = hierarchy.folders[folderName];
                    const folderSection = this.createFileSection(`ğŸ“ ${folderName}`, folderFiles, false);
                    this.pageList.appendChild(folderSection);
                });
                
                console.log('ğŸ“‚ Outliner view created:', hierarchy);
            }
            
            /**
             * ãƒ•ã‚¡ã‚¤ãƒ«ã‚’éšå±¤åˆ¥ã«æ•´ç†
             */
            organizeFilesHierarchy(files) {
                const hierarchy = {
                    root: [],
                    folders: {}
                };
                
                files.forEach(file => {
                    const path = file.path || file.name || '';
                    const pathParts = path.split(/[\/\\]/);
                    
                    if (pathParts.length === 1) {
                        // ãƒ«ãƒ¼ãƒˆç›´ä¸‹ã®ãƒ•ã‚¡ã‚¤ãƒ«
                        hierarchy.root.push(file);
                    } else {
                        // ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«
                        const topLevelFolder = pathParts[0];
                        if (!hierarchy.folders[topLevelFolder]) {
                            hierarchy.folders[topLevelFolder] = [];
                        }
                        hierarchy.folders[topLevelFolder].push(file);
                    }
                });
                
                return hierarchy;
            }
            
            /**
             * ãƒ•ã‚¡ã‚¤ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ä½œæˆï¼ˆãƒ«ãƒ¼ãƒˆç”¨ãƒ»ãƒ•ã‚©ãƒ«ãƒ€ç”¨ï¼‰
             */
            createFileSection(title, files, expanded = false) {
                const section = document.createElement('div');
                section.className = 'file-section';
                
                // ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãƒ˜ãƒƒãƒ€ãƒ¼
                const header = document.createElement('div');
                header.className = 'file-section-header';
                header.innerHTML = `
                    <span class="section-toggle ${expanded ? 'expanded' : 'collapsed'}">${expanded ? 'â–¼' : 'â–¶'}</span>
                    <span class="section-title">${title}</span>
                    <span class="section-count">(${files.length})</span>
                `;
                
                // ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…å®¹
                const content = document.createElement('div');
                content.className = `file-section-content ${expanded ? 'expanded' : 'collapsed'}`;
                
                // ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆä½œæˆ
                files.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    item.textContent = file.name || file.path.split(/[\/\\]/).pop() || `File ${index + 1}`;
                    item.dataset.index = index;
                    
                    // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
                    item.addEventListener('click', () => {
                        this.selectFileWithPreview(file, item);
                    });
                    
                    content.appendChild(item);
                });
                
                // ãƒˆã‚°ãƒ«æ©Ÿèƒ½
                header.addEventListener('click', () => {
                    const toggle = header.querySelector('.section-toggle');
                    const isExpanded = content.classList.contains('expanded');
                    
                    if (isExpanded) {
                        content.classList.remove('expanded');
                        content.classList.add('collapsed');
                        toggle.textContent = 'â–¶';
                        toggle.classList.remove('expanded');
                        toggle.classList.add('collapsed');
                    } else {
                        content.classList.remove('collapsed');
                        content.classList.add('expanded');
                        toggle.textContent = 'â–¼';
                        toggle.classList.remove('collapsed');
                        toggle.classList.add('expanded');
                    }
                });
                
                section.appendChild(header);
                section.appendChild(content);
                
                return section;
            }

            // çµ±åˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§è¡¨ç¤º + HTMLãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ©Ÿèƒ½
            renderFileListWithPreview(files) {
                console.log('ğŸ”§ Direct rendering files:', files);
                this.pageList.innerHTML = '';
                
                files.forEach((file, index) => {
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    item.textContent = file.name || file.path || `File ${index + 1}`;
                    item.dataset.index = index;
                    
                    item.addEventListener('click', () => {
                        this.selectFileWithPreview(file, item);
                    });
                    
                    this.pageList.appendChild(item);
                });
                
                // æœ€åˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è‡ªå‹•é¸æŠ
                if (files.length > 0) {
                    const firstItem = this.pageList.firstChild;
                    this.selectFileWithPreview(files[0], firstItem);
                }
            }
            
            selectFileWithPreview(file, element) {
                // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒŠãƒ¼å†…ã®å…¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ã‚¤ãƒ†ãƒ ã‹ã‚‰é¸æŠçŠ¶æ…‹ã‚’å‰Šé™¤
                this.pageList.querySelectorAll('.file-item').forEach(item => {
                    item.classList.remove('selected');
                });
                element.classList.add('selected');
                
                this.currentPage = file;
                console.log('ğŸ“‹ ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ:', file.name || file.path);
                
                // HTMLãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
                this.loadHTMLPreview(file);
            }
            
            async loadHTMLPreview(file) {
                console.log('ğŸ–¼ï¸ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼èª­ã¿è¾¼ã¿:', file);
                this.updateStatus('loading', `ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼èª­ã¿è¾¼ã¿ä¸­: ${file.name || file.path}`);
                
                try {
                    const previewIframe = this.previewIframe;
                    const previewPlaceholder = this.previewPlaceholder;
                    
                    console.log('ğŸ”§ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†é–‹å§‹');
                    console.log('ğŸ”§ file.fullPath:', file.fullPath);
                    console.log('ğŸ”§ file.path:', file.path);
                    console.log('ğŸ”§ file.name:', file.name);
                    console.log('ğŸ”§ currentProject:', window.projectLoader.currentProject);
                    
                    // å†…è”µHTTPã‚µãƒ¼ãƒãƒ¼çµŒç”±ã§ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆSpineã‚¢ã‚»ãƒƒãƒˆå¯¾å¿œï¼‰
                    const currentPort = window.location.port || '8082';
                    const serverUrl = `http://localhost:${currentPort}`;
                    
                    // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰ã®ç›¸å¯¾ãƒ‘ã‚¹ã§HTTPã‚¢ã‚¯ã‚»ã‚¹ï¼ˆWindowsåŒºåˆ‡ã‚Šæ–‡å­—æ­£è¦åŒ–ï¼‰
                    if (file.path) {
                        const normalizedPath = file.path.replace(/\\/g, '/');  // WindowsåŒºåˆ‡ã‚Šæ–‡å­—ã‚’æ­£è¦åŒ–
                        const httpUrl = `${serverUrl}/${normalizedPath}`;
                        console.log('ğŸ”§ Using HTTP server preview:', httpUrl);
                        console.log('ğŸ”§ Path normalized:', file.path, '->', normalizedPath);
                        previewIframe.src = httpUrl;
                    } else if (file.name) {
                        const httpUrl = `${serverUrl}/${file.name}`;
                        console.log('ğŸ”§ Using HTTP server preview (name):', httpUrl);
                        previewIframe.src = httpUrl;
                    } else {
                        throw new Error('File path not available');
                    }
                    
                    previewPlaceholder.style.display = 'none';
                    previewIframe.style.display = 'block';
                    
                    this.updateStatus('ready', `ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤ºä¸­: ${file.name || file.path}`);
                } catch (error) {
                    console.error('ğŸš¨ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus('error', `ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
                    
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã«è©³ç´°è¡¨ç¤º
                    this.previewPlaceholder.innerHTML = `
                        <div style="color: #666; text-align: center; padding: 20px;">
                            <p>HTMLãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ</p>
                            <p style="font-size: 12px; color: #999;">ãƒ•ã‚¡ã‚¤ãƒ«: ${file.name || file.path}</p>
                            <p style="font-size: 12px; color: #999;">ã‚¨ãƒ©ãƒ¼: ${error.message}</p>
                        </div>
                    `;
                    this.previewPlaceholder.style.display = 'block';
                    this.previewIframe.style.display = 'none';
                }
            }

            addSpineCharacter() {
                this.updateStatus('loading', 'Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’è¿½åŠ ä¸­...');
                
                try {
                    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢ã‚’å–å¾—
                    const previewContent = document.querySelector('.preview-content');
                    if (!previewContent) {
                        throw new Error('ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    }
                    
                    // æ—¢å­˜ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒã‚ã‚Œã°å‰Šé™¤
                    if (this.spineCharacter) {
                        this.spineRenderer.removeCharacter('dummy-character');
                        this.spineCharacter = null;
                    }
                    
                    // ãƒ€ãƒŸãƒ¼ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿
                    const characterData = {
                        name: 'Dummy Character',
                        type: 'demo',
                        version: 'v2.0'
                    };
                    
                    // Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’æç”»
                    const success = this.spineRenderer.renderSpineCharacter(
                        'dummy-character',
                        characterData,
                        { x: this.spinePosition.x, y: this.spinePosition.y },
                        previewContent
                    );
                    
                    if (success) {
                        this.spineCharacter = 'dummy-character';
                        
                        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
                        this.spineRenderer.initializeAnimation('dummy-character', {
                            idle: 'taiki',
                            click: 'yarare'
                        });
                        
                        // ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½ã‚’è¿½åŠ 
                        this.setupSpineDragFunction();
                        
                        // UIæ›´æ–°
                        this.spineXInput.value = this.spinePosition.x;
                        this.spineYInput.value = this.spinePosition.y;
                        this.btnSavePosition.disabled = false;
                        
                        this.updateStatus('ready', 'Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¿½åŠ å®Œäº†');
                        console.log('âœ… Spineãƒ€ãƒŸãƒ¼ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¿½åŠ å®Œäº†');
                        
                    } else {
                        throw new Error('Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä½œæˆå¤±æ•—');
                    }
                    
                } catch (error) {
                    console.error('âŒ Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¿½åŠ ã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus('error', `Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¿½åŠ å¤±æ•—: ${error.message}`);
                }
            }

            /**
             * Spineãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½è¨­å®š
             */
            setupSpineDragFunction() {
                const canvasElement = this.spineCore.canvasElements.get('spine-dummy-character');
                if (!canvasElement) {
                    console.warn('âš ï¸ Spineã‚­ãƒ£ãƒ³ãƒã‚¹è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                let isDragging = false;
                let dragStartX = 0;
                let dragStartY = 0;
                let elementStartX = 0;
                let elementStartY = 0;
                
                // ãƒã‚¦ã‚¹ãƒ€ã‚¦ãƒ³ï¼ˆãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ï¼‰
                canvasElement.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    elementStartX = parseInt(canvasElement.style.left) || 0;
                    elementStartY = parseInt(canvasElement.style.top) || 0;
                    
                    canvasElement.style.cursor = 'grabbing';
                    e.preventDefault();
                });
                
                // ãƒã‚¦ã‚¹ç§»å‹•ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ä¸­ï¼‰
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaX = e.clientX - dragStartX;
                    const deltaY = e.clientY - dragStartY;
                    
                    const newX = elementStartX + deltaX;
                    const newY = elementStartY + deltaY;
                    
                    // Canvasã‚’ç§»å‹•
                    canvasElement.style.left = newX + 'px';
                    canvasElement.style.top = newY + 'px';
                    
                    // å†…éƒ¨åº§æ¨™ã‚‚æ›´æ–°
                    this.spinePosition.x = newX;
                    this.spinePosition.y = newY;
                    
                    // UIæ›´æ–°
                    this.spineXInput.value = newX;
                    this.spineYInput.value = newY;
                });
                
                // ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—ï¼ˆãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†ï¼‰
                document.addEventListener('mouseup', (e) => {
                    if (isDragging) {
                        isDragging = false;
                        canvasElement.style.cursor = 'move';
                        
                        this.updateStatus('ready', `ä½ç½®æ›´æ–°: (${this.spinePosition.x}, ${this.spinePosition.y})`);
                        console.log('ğŸ¯ ãƒ‰ãƒ©ãƒƒã‚°å®Œäº†:', this.spinePosition);
                    }
                });
                
                console.log('âœ… Spineãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½è¨­å®šå®Œäº†');
            }
            
            /**
             * Spineä½ç½®æ›´æ–°ï¼ˆæ•°å€¤å…¥åŠ›ã‹ã‚‰ï¼‰
             */
            updateSpinePosition() {
                if (!this.spineCharacter) return;
                
                const canvasElement = this.spineCore.canvasElements.get('spine-dummy-character');
                if (canvasElement) {
                    canvasElement.style.left = this.spinePosition.x + 'px';
                    canvasElement.style.top = this.spinePosition.y + 'px';
                    
                    this.updateStatus('ready', `ä½ç½®æ›´æ–°: (${this.spinePosition.x}, ${this.spinePosition.y})`);
                    console.log('ğŸ“ ä½ç½®æ•°å€¤æ›´æ–°:', this.spinePosition);
                }
            }

            savePosition() {
                if (!this.spineCharacter) {
                    this.updateStatus('error', 'Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                // localStorageä¿å­˜
                const positionData = {
                    characterId: this.spineCharacter,
                    position: this.spinePosition,
                    timestamp: Date.now()
                };
                
                try {
                    localStorage.setItem('spine-desktop-position', JSON.stringify(positionData));
                    console.log('ğŸ’¾ ä½ç½®ä¿å­˜å®Œäº†:', positionData);
                    this.updateStatus('ready', `ä½ç½®ä¿å­˜å®Œäº†: (${this.spinePosition.x}, ${this.spinePosition.y})`);
                } catch (error) {
                    console.error('âŒ ä½ç½®ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus('error', 'ä½ç½®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            }
            
            /**
             * ä¿å­˜ã•ã‚ŒãŸä½ç½®ã‚’å¾©å…ƒ
             */
            restorePosition() {
                try {
                    const saved = localStorage.getItem('spine-desktop-position');
                    if (!saved) return false;
                    
                    const positionData = JSON.parse(saved);
                    this.spinePosition = positionData.position;
                    
                    // UIæ›´æ–°
                    this.spineXInput.value = this.spinePosition.x;
                    this.spineYInput.value = this.spinePosition.y;
                    
                    console.log('ğŸ“ ä½ç½®å¾©å…ƒ:', this.spinePosition);
                    return true;
                    
                } catch (error) {
                    console.error('âŒ ä½ç½®å¾©å…ƒã‚¨ãƒ©ãƒ¼:', error);
                    return false;
                }
            }

            async exportPackage() {
                this.updateStatus('loading', 'ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’å‡ºåŠ›ä¸­...');
                
                try {
                    // å‡ºåŠ›ãƒ‘ã‚¹ã‚’é¸æŠ
                    const saveResult = await window.electronAPI.saveFileDialog({
                        title: 'ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ä¿å­˜',
                        defaultPath: `spine-package-${Date.now()}.zip`,
                        filters: [
                            { name: 'ZIP Files', extensions: ['zip'] }
                        ]
                    });
                    
                    if (saveResult.canceled) {
                        this.updateStatus('ready', 'ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å‡ºåŠ›ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ');
                        return;
                    }
                    
                    const outputPath = saveResult.filePath;
                    console.log('ğŸ“¦ å‡ºåŠ›ãƒ‘ã‚¹:', outputPath);
                    
                    // æœ€å°ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ä½œæˆ
                    const success = await this.createMinimalPackage(outputPath);
                    
                    if (success) {
                        this.updateStatus('ready', `ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å‡ºåŠ›å®Œäº†: ${outputPath}`);
                    } else {
                        this.updateStatus('error', 'ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å‡ºåŠ›ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                    
                } catch (error) {
                    console.error('âŒ ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å‡ºåŠ›ã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus('error', `ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å‡ºåŠ›ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                }
            }
            
            /**
             * æœ€å°ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ä½œæˆï¼ˆPhase 0.2ç”¨ï¼‰
             */
            async createMinimalPackage(outputPath) {
                console.log('ğŸ“¦ Creating minimal package...');
                
                try {
                    // ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ç”¨HTMLã‚’ä½œæˆ
                    const packageHTML = this.createPackageHTML();
                    
                    // ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ç”¨CSSã‚’ä½œæˆ
                    const packageCSS = this.createPackageCSS();
                    
                    // JSZip ã‚’å‹•çš„èª­ã¿è¾¼ã¿
                    await this.loadJSZip();
                    
                    const zip = new JSZip();
                    
                    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ZIPã«è¿½åŠ 
                    zip.file('index.html', packageHTML);
                    zip.file('styles.css', packageCSS);
                    zip.file('README.md', this.createPackageReadme());
                    
                    // ZIPç”Ÿæˆ
                    const content = await zip.generateAsync({ type: 'blob' });
                    
                    // ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿
                    const buffer = await content.arrayBuffer();
                    const uint8Array = new Uint8Array(buffer);
                    
                    const writeResult = await window.electronAPI.fs.writeFile(
                        outputPath, 
                        uint8Array
                    );
                    
                    if (writeResult.success) {
                        console.log('âœ… Package created successfully');
                        return true;
                    } else {
                        console.error('âŒ File write failed:', writeResult.error);
                        return false;
                    }
                    
                } catch (error) {
                    console.error('âŒ Package creation failed:', error);
                    return false;
                }
            }
            
            /**
             * JSZipå‹•çš„èª­ã¿è¾¼ã¿
             */
            async loadJSZip() {
                if (window.JSZip) return;
                
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                    script.onload = () => {
                        console.log('ğŸ“œ JSZip loaded');
                        resolve();
                    };
                    script.onerror = () => reject(new Error('JSZipèª­ã¿è¾¼ã¿å¤±æ•—'));
                    document.head.appendChild(script);
                });
            }
            
            /**
             * ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ç”¨HTMLä½œæˆ
             */
            createPackageHTML() {
                return `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spine Character Demo</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h1>Spine Character Demo</h1>
        <div class="spine-area">
            <div id="spine-character" class="spine-placeholder">
                <div class="spine-icon">ğŸ­</div>
                <p>Spine Character</p>
                <p class="position">Position: (${this.spinePosition.x}, ${this.spinePosition.y})</p>
            </div>
        </div>
        <div class="info">
            <p>Generated by Spine Editor Desktop v2.0</p>
            <p>Character positioned at: X=${this.spinePosition.x}, Y=${this.spinePosition.y}</p>
        </div>
    </div>
</body>
</html>`;
            }
            
            /**
             * ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ç”¨CSSä½œæˆ
             */
            createPackageCSS() {
                return `/* Spine Editor Desktop v2.0 - Package CSS */

body {
    margin: 0;
    padding: 20px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background-color: #f5f5f5;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    padding: 30px;
}

h1 {
    text-align: center;
    color: #333;
    margin-bottom: 30px;
}

.spine-area {
    position: relative;
    width: 100%;
    height: 600px;
    background: linear-gradient(45deg, #f9f9f9 0%, #e8e8e8 100%);
    border: 2px solid #ddd;
    border-radius: 8px;
    overflow: hidden;
}

.spine-placeholder {
    position: absolute;
    left: ${this.spinePosition.x}px;
    top: ${this.spinePosition.y}px;
    width: 120px;
    height: 150px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 50%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    text-align: center;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    transform: translate(-50%, -50%);
    transition: all 0.3s ease;
}

.spine-placeholder:hover {
    transform: translate(-50%, -50%) scale(1.05);
}

.spine-icon {
    font-size: 48px;
    margin-bottom: 10px;
}

.spine-placeholder p {
    margin: 5px 0;
    font-size: 14px;
    font-weight: 500;
}

.position {
    font-size: 12px;
    opacity: 0.8;
}

.info {
    margin-top: 30px;
    padding: 20px;
    background-color: #f8f9fa;
    border-radius: 8px;
    text-align: center;
}

.info p {
    margin: 5px 0;
    color: #666;
    font-size: 14px;
}

@media (max-width: 768px) {
    .container {
        margin: 10px;
        padding: 20px;
    }
    
    .spine-area {
        height: 400px;
    }
    
    .spine-placeholder {
        width: 80px;
        height: 100px;
    }
    
    .spine-icon {
        font-size: 32px;
    }
}`;
            }
            
            /**
             * ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ç”¨READMEä½œæˆ
             */
            createPackageReadme() {
                return `# Spine Character Package

Generated by Spine Editor Desktop v2.0  
Created: ${new Date().toLocaleDateString()}

## Quick Start

1. Extract all files to your web server directory
2. Open \`index.html\` in a web browser
3. View your positioned Spine character

## Files

- \`index.html\` - Main HTML file
- \`styles.css\` - Character positioning styles  
- \`README.md\` - This documentation

## Character Position

- X: ${this.spinePosition.x}px
- Y: ${this.spinePosition.y}px

## Notes

This is a Phase 0.2 minimal package for demonstration purposes.
Future versions will include actual Spine WebGL rendering.

---
Created with Spine Editor Desktop v2.0`;
            }
            
            /**
             * ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ©Ÿèƒ½
             */
            async previewPackage() {
                this.updateStatus('loading', 'ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æº–å‚™ä¸­...');
                
                try {
                    // ä¸€æ™‚çš„ãªHTMLã‚’ä½œæˆã—ã¦ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
                    const previewHTML = this.createPackageHTML();
                    const previewCSS = this.createPackageCSS();
                    
                    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼HTMLã« CSS ã‚’åŸ‹ã‚è¾¼ã¿
                    const fullPreviewHTML = previewHTML.replace(
                        '<link rel="stylesheet" href="styles.css">',
                        `<style>${previewCSS}</style>`
                    );
                    
                    // Blob URL ã‚’ä½œæˆ
                    const blob = new Blob([fullPreviewHTML], { type: 'text/html' });
                    const url = URL.createObjectURL(blob);
                    
                    // Electron APIçµŒç”±ã§æ–°ã—ã„ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é–‹ã
                    if (window.electronAPI && window.electronAPI.openURL) {
                        await window.electronAPI.openURL(url);
                        this.updateStatus('ready', 'ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é–‹ãã¾ã—ãŸ');
                    } else {
                        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: iframe ã§ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
                        this.showInlinePreview(fullPreviewHTML);
                        this.updateStatus('ready', 'ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤ºã—ã¾ã—ãŸ');
                    }
                    
                    // ãƒ¡ãƒ¢ãƒªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                    setTimeout(() => URL.revokeObjectURL(url), 30000);
                    
                } catch (error) {
                    console.error('âŒ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus('error', `ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å¤±æ•—: ${error.message}`);
                }
            }
            
            /**
             * ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤ºï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
             */
            showInlinePreview(html) {
                const blob = new Blob([html], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                
                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒªã‚¢ã«è¡¨ç¤º
                this.previewIframe.src = url;
                this.previewPlaceholder.style.display = 'none';
                this.previewIframe.style.display = 'block';
                
                // ãƒ¡ãƒ¢ãƒªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                setTimeout(() => URL.revokeObjectURL(url), 30000);
            }

            // ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã¯ demo-modules.js ã«ç§»è­²
        }

        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•
        document.addEventListener('DOMContentLoaded', () => {
            window.demoApp = new DemoApp();
            console.log('ğŸ¯ Demo App initialized');
        });
    </script>
</body>
</html>