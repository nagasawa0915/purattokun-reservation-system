<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>🚀 最小Spineテスト - 3モジュールのみ</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #f0f0f0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        
        #spine-canvas {
            border: 2px solid #333;
            background: transparent;
            display: block;
            margin: 20px auto;
        }
        
        .controls {
            text-align: center;
            margin: 20px;
        }
        
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #007acc;
            color: white;
        }
        
        button:hover {
            background: #005a9e;
        }
        
        .status {
            text-align: center;
            margin: 10px;
            padding: 10px;
            background: white;
            border-radius: 4px;
            font-family: monospace;
        }
        
        .comparison {
            margin: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <h1>🚀 最小Spineテスト（3モジュールのみ）</h1>
    
    <div class="comparison">
        <h3>📊 モジュール削減効果</h3>
        <p><strong>従来システム:</strong> 21モジュール積み重なり</p>
        <p><strong>最小システム:</strong> 3モジュールのみ</p>
        <ul>
            <li>✅ spine-webgl.js - WebGLライブラリ</li>
            <li>✅ HTML5 Canvas - 基本Canvas</li>  
            <li>✅ minimal-render.js - 最小描画ロジック</li>
        </ul>
    </div>

    <canvas id="spine-canvas" width="800" height="600"></canvas>
    
    <div class="controls">
        <button onclick="loadNezumi()">🐭 nezumi読み込み</button>
        <button onclick="loadPurattokun()">🐱 purattokun読み込み</button>
        <button onclick="clearCanvas()">🧹 クリア</button>
        <button onclick="toggleBackground()">🎨 背景切り替え</button>
        <button onclick="diagnosticBlackEdge()" style="background: #dc3545;">🔍 黒縁診断</button>
        <button onclick="testBlackEdgeFix()" style="background: #fd7e14;">🔬 黒縁修正実験</button>
    </div>
    
    <div id="status" class="status">
        システム初期化中...
    </div>

    <!-- 🚀 Phase 4: 動作確認済みSpine WebGLライブラリに切り替え -->
    <script src="assets/spine/spine-webgl-working.js"></script>
    
    <!-- 🚀 モジュール3: 最小描画ロジック -->
    <script>
        // 🚀 最小実装開始
        console.log('🚀 最小Spineシステム開始（3モジュールのみ）');
        
        // グローバル変数（最小限）
        let canvas, gl, spineRenderer = {};
        let currentCharacter = null;
        let animationId = null;
        let backgroundDark = false;
        
        // 🚀 初期化
        async function initMinimalSpineSystem() {
            updateStatus('WebGL初期化中...');
            
            // Canvas取得（モジュール2: HTML5 Canvas）
            canvas = document.getElementById('spine-canvas');
            
            // 🚀 Phase 7: 動作版と完全同一WebGL設定
            const contextOptions = {
                alpha: true,
                premultipliedAlpha: false // 動作版と同じ設定
            };
            
            // 🚀 Phase 7: 動作版と完全同一（webglのみ使用）
            gl = canvas.getContext('webgl', contextOptions);
            
            if (!gl) {
                throw new Error('WebGL not supported');
            }
            
            console.log('✅ WebGL初期化完了:', gl.getParameter(gl.VERSION));
            
            // 🚀 Phase 7: 動作版のレンダリング設定は最小限のみ
            
            // Spine WebGL待機
            await waitForSpine();
            
            updateStatus('✅ 最小Spineシステム初期化完了');
            console.log('✅ 最小システム準備完了 - 問題テスト可能');
        }
        
        // Spine読み込み待機（最小版）
        async function waitForSpine() {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 50;
                
                const check = () => {
                    if (typeof spine !== 'undefined' && spine.AssetManager) {
                        console.log('✅ Spine WebGL読み込み完了（最小版）');
                        resolve();
                    } else if (attempts++ >= maxAttempts) {
                        reject(new Error('Spine読み込みタイムアウト'));
                    } else {
                        setTimeout(check, 100);
                    }
                };
                check();
            });
        }
        
        // 🚀 最小キャラクター読み込み
        async function loadCharacter(characterName) {
            try {
                updateStatus(`${characterName}読み込み中...`);
                
                // 既存キャラクタークリア
                if (currentCharacter) {
                    clearCanvas();
                }
                
                // アセットパス（最小構成）
                const basePath = `assets/spine/characters/${characterName}/`;
                const assetManager = new spine.AssetManager(gl, basePath);
                
                // 基本アセット読み込み
                assetManager.loadTextureAtlas(`${characterName}.atlas`);
                assetManager.loadJson(`${characterName}.json`);
                
                // 読み込み完了待機
                await waitForAssets(assetManager);
                
                // 🚀 Phase 7: 動作版と同一のアセット取得方法
                const atlas = assetManager.get(`${characterName}.atlas`);
                const skeletonData = assetManager.get(`${characterName}.json`);
                
                const atlasLoader = new spine.AtlasAttachmentLoader(atlas);
                const skeletonJson = new spine.SkeletonJson(atlasLoader);
                const skeleton = new spine.Skeleton(skeletonJson.readSkeletonData(skeletonData));
                
                // 🚀 シンプル座標（中央配置）
                skeleton.x = 0;
                skeleton.y = 0;
                skeleton.scaleX = skeleton.scaleY = 1.0;
                
                // アニメーション設定
                const animationStateData = new spine.AnimationStateData(skeleton.data);
                const animationState = new spine.AnimationState(animationStateData);
                
                if (skeleton.data.animations.length > 0) {
                    animationState.setAnimation(0, skeleton.data.animations[0].name, true);
                }
                
                skeleton.updateWorldTransform();
                
                // 🚀 Phase 4: PMA対応SceneRenderer初期化（アセット=PMA、WebGL=Straight設定）
                spineRenderer.instance = new spine.SceneRenderer(canvas, gl);
                
                // 🚀 Phase 6: 最小構成で安定性確保
                console.log('✅ Phase 6: 基本設定で初期化完了（安定性最優先）');
                
                currentCharacter = {
                    skeleton,
                    animationState,
                    name: characterName
                };
                
                // レンダリング開始
                startRendering();
                
                updateStatus(`✅ ${characterName}読み込み完了（最小版）`);
                console.log(`✅ ${characterName}読み込み完了 - 問題検証開始`);
                
            } catch (error) {
                console.error(`❌ ${characterName}読み込みエラー:`, error);
                updateStatus(`❌ ${characterName}読み込み失敗: ${error.message}`);
            }
        }
        
        // 🚀 Phase 4: 強化されたアセット読み込み待機（完全待機）
        function waitForAssets(assetManager) {
            return new Promise((resolve, reject) => {
                let attemptCount = 0;
                const maxAttempts = 100; // 10秒待機
                
                const check = () => {
                    attemptCount++;
                    console.log(`📦 アセット読み込み確認 ${attemptCount}/${maxAttempts}`);
                    
                    if (assetManager.isLoadingComplete()) {
                        // 🚀 Phase 4: 追加安全待機（テクスチャ完全準備保証）
                        setTimeout(() => {
                            console.log('✅ アセット読み込み完了 + 安全待機完了');
                            resolve();
                        }, 500); // 500ms追加待機
                    } else if (attemptCount >= maxAttempts) {
                        reject(new Error('アセット読み込みタイムアウト'));
                    } else {
                        setTimeout(check, 100);
                    }
                };
                check();
            });
        }
        
        // 🚀 Phase 4: フレーム安定化レンダリング（1フレーム表示問題対策）
        function startRendering() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            let lastTime = Date.now() / 1000;
            let frameCount = 0;
            let isFirstFrame = true;
            
            const render = () => {
                if (!currentCharacter) return;
                
                const now = Date.now() / 1000;
                const delta = now - lastTime;
                lastTime = now;
                frameCount++;
                
                try {
                    // アニメーション更新
                    currentCharacter.animationState.update(delta);
                    currentCharacter.animationState.apply(currentCharacter.skeleton);
                    currentCharacter.skeleton.updateWorldTransform();
                    
                    // 🚀 Phase 7: 動作版と完全同一のレンダリング手順
                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.viewport(0, 0, canvas.width, canvas.height);
                    
                    // カメラ設定
                    spineRenderer.instance.camera.setViewport(canvas.width, canvas.height);
                    
                    // 描画
                    spineRenderer.instance.begin();
                    spineRenderer.instance.drawSkeleton(currentCharacter.skeleton, true);
                    spineRenderer.instance.end();
                    
                } catch (error) {
                    console.error('❌ レンダリングエラー:', error);
                }
                
                animationId = requestAnimationFrame(render);
            };
            
            console.log('🎬 レンダリングループ開始（フレーム安定化版）');
            animationId = requestAnimationFrame(render);
        }
        
        // 🚀 グローバルスコープに関数配置（HTMLから呼び出し可能）
        window.loadNezumi = function() {
            loadCharacter('nezumi');
        };
        
        window.loadPurattokun = function() {
            loadCharacter('purattokun');
        };
        
        window.clearCanvas = function() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            currentCharacter = null;
            if (gl) {
                gl.clear(gl.COLOR_BUFFER_BIT);
            }
            updateStatus('キャンバスクリア完了');
        };
        
        window.toggleBackground = function() {
            backgroundDark = !backgroundDark;
            document.body.style.background = backgroundDark ? '#222' : '#f0f0f0';
            updateStatus(`背景: ${backgroundDark ? '黒' : '白'}`);
        };
        
        // 🔍 Phase 5: 黒縁問題診断用関数追加
        window.diagnosticBlackEdge = function() {
            console.log('🔍 Phase 5: 黒縁問題診断開始');
            
            if (!currentCharacter) {
                console.warn('⚠️ キャラクターが読み込まれていません');
                return;
            }
            
            // テクスチャ情報確認
            const skeleton = currentCharacter.skeleton;
            if (skeleton && skeleton.slots) {
                console.log('📊 スロット・アタッチメント情報:');
                skeleton.slots.forEach((slot, index) => {
                    const attachment = slot.getAttachment();
                    if (attachment && attachment.texture) {
                        console.log(`  Slot ${index} (${slot.data.name}):`);
                        console.log(`    - テクスチャサイズ: ${attachment.texture.image.width}x${attachment.texture.image.height}`);
                        console.log(`    - UVs:`, attachment.uvs);
                        console.log(`    - 座標:`, attachment.vertices);
                        
                        // WebGLテクスチャ状態確認
                        const texture = attachment.texture;
                        if (texture._texture) {
                            console.log(`    - WebGLテクスチャID: ${texture._texture}`);
                        }
                    }
                });
            }
            
            // WebGL設定再確認
            console.log('🔍 現在のWebGL設定:');
            console.log('  - BLEND enabled:', gl.isEnabled(gl.BLEND));
            console.log('  - Blend func:', gl.getParameter(gl.BLEND_SRC_RGB), gl.getParameter(gl.BLEND_DST_RGB));
            console.log('  - UNPACK_PREMULTIPLY_ALPHA:', gl.getParameter(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL));
            console.log('  - Context attributes:', gl.getContextAttributes());
            
            updateStatus('🔍 黒縁診断完了 - コンソール参照');
        };
        
        // 🔍 Phase 5: 実験的黒縁修正テスト
        window.testBlackEdgeFix = function() {
            console.log('🔬 Phase 5: 実験的黒縁修正開始');
            
            if (!currentCharacter || !gl) return;
            
            // 実験1: ブレンドモード変更テスト
            console.log('🔬 実験1: ブレンドモード変更');
            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); // PMA用に戻す
            
            setTimeout(() => {
                console.log('🔬 実験2: Straight Alphaに戻す');
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                
                setTimeout(() => {
                    console.log('🔬 実験3: ONE_MINUS_DST_ALPHAテスト');
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_DST_ALPHA);
                    
                    setTimeout(() => {
                        console.log('🔬 実験完了: 元に戻します');
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                        updateStatus('🔬 黒縁修正実験完了');
                    }, 2000);
                }, 2000);
            }, 2000);
            
            updateStatus('🔬 黒縁修正実験実行中...');
        };
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            console.log('📊 Status:', message);
        }
        
        // 🚀 システム開始
        window.addEventListener('DOMContentLoaded', () => {
            initMinimalSpineSystem().catch(error => {
                console.error('❌ 初期化エラー:', error);
                updateStatus(`❌ 初期化失敗: ${error.message}`);
            });
        });
        
        console.log('🚀 最小Spineテストファイル読み込み完了');
    </script>
</body>
</html>