<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ğŸš€ æœ€å°Spineãƒ†ã‚¹ãƒˆ - 3ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã¿</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #f0f0f0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        
        #spine-canvas {
            border: 2px solid #333;
            background: transparent;
            display: block;
            margin: 20px auto;
        }
        
        .controls {
            text-align: center;
            margin: 20px;
        }
        
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #007acc;
            color: white;
        }
        
        button:hover {
            background: #005a9e;
        }
        
        .status {
            text-align: center;
            margin: 10px;
            padding: 10px;
            background: white;
            border-radius: 4px;
            font-family: monospace;
        }
        
        .comparison {
            margin: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <h1>ğŸš€ æœ€å°Spineãƒ†ã‚¹ãƒˆï¼ˆ3ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã¿ï¼‰</h1>
    
    <div class="comparison">
        <h3>ğŸ“Š ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å‰Šæ¸›åŠ¹æœ</h3>
        <p><strong>å¾“æ¥ã‚·ã‚¹ãƒ†ãƒ :</strong> 21ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç©ã¿é‡ãªã‚Š</p>
        <p><strong>æœ€å°ã‚·ã‚¹ãƒ†ãƒ :</strong> 3ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã¿</p>
        <ul>
            <li>âœ… spine-webgl.js - WebGLãƒ©ã‚¤ãƒ–ãƒ©ãƒª</li>
            <li>âœ… HTML5 Canvas - åŸºæœ¬Canvas</li>  
            <li>âœ… minimal-render.js - æœ€å°æç”»ãƒ­ã‚¸ãƒƒã‚¯</li>
        </ul>
    </div>

    <canvas id="spine-canvas" width="800" height="600"></canvas>
    
    <div class="controls">
        <button onclick="loadNezumi()">ğŸ­ nezumièª­ã¿è¾¼ã¿</button>
        <button onclick="loadPurattokun()">ğŸ± purattokunèª­ã¿è¾¼ã¿</button>
        <button onclick="clearCanvas()">ğŸ§¹ ã‚¯ãƒªã‚¢</button>
        <button onclick="toggleBackground()">ğŸ¨ èƒŒæ™¯åˆ‡ã‚Šæ›¿ãˆ</button>
    </div>
    
    <div id="status" class="status">
        ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ä¸­...
    </div>

    <!-- ğŸš€ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«1: Spine WebGLãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã¿ -->
    <script src="assets/spine/spine-webgl.js"></script>
    
    <!-- ğŸš€ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«3: æœ€å°æç”»ãƒ­ã‚¸ãƒƒã‚¯ -->
    <script>
        // ğŸš€ æœ€å°å®Ÿè£…é–‹å§‹
        console.log('ğŸš€ æœ€å°Spineã‚·ã‚¹ãƒ†ãƒ é–‹å§‹ï¼ˆ3ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã¿ï¼‰');
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ï¼ˆæœ€å°é™ï¼‰
        let canvas, gl, spine = {};
        let currentCharacter = null;
        let animationId = null;
        let backgroundDark = false;
        
        // ğŸš€ åˆæœŸåŒ–
        async function initMinimalSpineSystem() {
            updateStatus('WebGLåˆæœŸåŒ–ä¸­...');
            
            // Canvaså–å¾—ï¼ˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«2: HTML5 Canvasï¼‰
            canvas = document.getElementById('spine-canvas');
            
            // ğŸš€ Webç‰ˆå®Œå…¨çµ±ä¸€WebGLè¨­å®šï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰
            const contextOptions = {
                alpha: true,
                premultipliedAlpha: false
            };
            
            // WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå–å¾—ï¼ˆWebç‰ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æˆ¦ç•¥ï¼‰
            gl = canvas.getContext('webgl2', contextOptions) || 
                 canvas.getContext('webgl', contextOptions) || 
                 canvas.getContext('experimental-webgl', contextOptions);
            
            if (!gl) {
                throw new Error('WebGL not supported');
            }
            
            console.log('âœ… WebGLåˆæœŸåŒ–å®Œäº†:', gl.getParameter(gl.VERSION));
            
            // ğŸš€ Sæ–¹å¼ï¼ˆã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆÎ±ï¼‰è¨­å®šã®ã¿
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            gl.clearColor(0.0, 0.0, 0.0, 0.0);
            
            // Spine WebGLå¾…æ©Ÿ
            await waitForSpine();
            
            updateStatus('âœ… æœ€å°Spineã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†');
            console.log('âœ… æœ€å°ã‚·ã‚¹ãƒ†ãƒ æº–å‚™å®Œäº† - å•é¡Œãƒ†ã‚¹ãƒˆå¯èƒ½');
        }
        
        // Spineèª­ã¿è¾¼ã¿å¾…æ©Ÿï¼ˆæœ€å°ç‰ˆï¼‰
        async function waitForSpine() {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 50;
                
                const check = () => {
                    if (typeof spine !== 'undefined' && spine.AssetManager) {
                        console.log('âœ… Spine WebGLèª­ã¿è¾¼ã¿å®Œäº†ï¼ˆæœ€å°ç‰ˆï¼‰');
                        resolve();
                    } else if (attempts++ >= maxAttempts) {
                        reject(new Error('Spineèª­ã¿è¾¼ã¿ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'));
                    } else {
                        setTimeout(check, 100);
                    }
                };
                check();
            });
        }
        
        // ğŸš€ æœ€å°ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼èª­ã¿è¾¼ã¿
        async function loadCharacter(characterName) {
            try {
                updateStatus(`${characterName}èª­ã¿è¾¼ã¿ä¸­...`);
                
                // æ—¢å­˜ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¯ãƒªã‚¢
                if (currentCharacter) {
                    clearCanvas();
                }
                
                // ã‚¢ã‚»ãƒƒãƒˆãƒ‘ã‚¹ï¼ˆæœ€å°æ§‹æˆï¼‰
                const basePath = `assets/spine/characters/${characterName}/`;
                const assetManager = new spine.AssetManager(gl, basePath);
                
                // åŸºæœ¬ã‚¢ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿
                assetManager.loadTextureAtlas(`${characterName}.atlas`);
                assetManager.loadJson(`${characterName}.json`);
                
                // èª­ã¿è¾¼ã¿å®Œäº†å¾…æ©Ÿ
                await waitForAssets(assetManager);
                
                // Skeletonæ§‹ç¯‰ï¼ˆæœ€å°ç‰ˆï¼‰
                const atlas = assetManager.require(`${characterName}.atlas`);
                const skeletonData = assetManager.require(`${characterName}.json`);
                
                const atlasLoader = new spine.AtlasAttachmentLoader(atlas);
                const skeletonJson = new spine.SkeletonJson(atlasLoader);
                const skeleton = new spine.Skeleton(skeletonJson.readSkeletonData(skeletonData));
                
                // ğŸš€ ã‚·ãƒ³ãƒ—ãƒ«åº§æ¨™ï¼ˆä¸­å¤®é…ç½®ï¼‰
                skeleton.x = 0;
                skeleton.y = 0;
                skeleton.scaleX = skeleton.scaleY = 1.0;
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
                const animationStateData = new spine.AnimationStateData(skeleton.data);
                const animationState = new spine.AnimationState(animationStateData);
                
                if (skeleton.data.animations.length > 0) {
                    animationState.setAnimation(0, skeleton.data.animations[0].name, true);
                }
                
                skeleton.updateWorldTransform();
                
                // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼æº–å‚™
                spine.renderer = new spine.SceneRenderer(canvas, gl);
                
                currentCharacter = {
                    skeleton,
                    animationState,
                    name: characterName
                };
                
                // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–‹å§‹
                startRendering();
                
                updateStatus(`âœ… ${characterName}èª­ã¿è¾¼ã¿å®Œäº†ï¼ˆæœ€å°ç‰ˆï¼‰`);
                console.log(`âœ… ${characterName}èª­ã¿è¾¼ã¿å®Œäº† - å•é¡Œæ¤œè¨¼é–‹å§‹`);
                
            } catch (error) {
                console.error(`âŒ ${characterName}èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:`, error);
                updateStatus(`âŒ ${characterName}èª­ã¿è¾¼ã¿å¤±æ•—: ${error.message}`);
            }
        }
        
        // ã‚¢ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿å¾…æ©Ÿ
        function waitForAssets(assetManager) {
            return new Promise((resolve, reject) => {
                const check = () => {
                    if (assetManager.isLoadingComplete()) {
                        resolve();
                    } else {
                        setTimeout(check, 100);
                    }
                };
                check();
            });
        }
        
        // ğŸš€ æœ€å°ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆå•é¡Œæ¤œè¨¼ç”¨ï¼‰
        function startRendering() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            let lastTime = Date.now() / 1000;
            
            const render = () => {
                if (!currentCharacter) return;
                
                const now = Date.now() / 1000;
                const delta = now - lastTime;
                lastTime = now;
                
                // ç”»é¢ã‚¯ãƒªã‚¢
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                try {
                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
                    currentCharacter.animationState.update(delta);
                    currentCharacter.animationState.apply(currentCharacter.skeleton);
                    currentCharacter.skeleton.updateWorldTransform();
                    
                    // æç”»
                    spine.renderer.drawSkeleton(currentCharacter.skeleton, false);
                    
                } catch (error) {
                    console.error('âŒ ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:', error);
                }
                
                animationId = requestAnimationFrame(render);
            };
            
            animationId = requestAnimationFrame(render);
        }
        
        // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«é–¢æ•°
        function loadNezumi() {
            loadCharacter('nezumi');
        }
        
        function loadPurattokun() {
            loadCharacter('purattokun');
        }
        
        function clearCanvas() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            currentCharacter = null;
            if (gl) {
                gl.clear(gl.COLOR_BUFFER_BIT);
            }
            updateStatus('ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªã‚¢å®Œäº†');
        }
        
        function toggleBackground() {
            backgroundDark = !backgroundDark;
            document.body.style.background = backgroundDark ? '#222' : '#f0f0f0';
            updateStatus(`èƒŒæ™¯: ${backgroundDark ? 'é»’' : 'ç™½'}`);
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
            console.log('ğŸ“Š Status:', message);
        }
        
        // ğŸš€ ã‚·ã‚¹ãƒ†ãƒ é–‹å§‹
        window.addEventListener('DOMContentLoaded', () => {
            initMinimalSpineSystem().catch(error => {
                console.error('âŒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                updateStatus(`âŒ åˆæœŸåŒ–å¤±æ•—: ${error.message}`);
            });
        });
        
        console.log('ğŸš€ æœ€å°Spineãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å®Œäº†');
    </script>
</body>
</html>