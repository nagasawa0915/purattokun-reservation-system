<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🐱 Purattokun + StableSpineRenderer + BoundingBox テスト</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #2E86AB 0%, #A23B72 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
            margin-top: 10px;
        }
        
        .canvas-container {
            position: relative;
            width: 800px;
            height: 600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }
        
        #spine-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            min-width: 250px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #ffd700;
        }
        
        .btn {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }
        
        .btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .btn.success {
            background: rgba(76, 175, 80, 0.8);
        }
        
        .btn.danger {
            background: rgba(244, 67, 54, 0.8);
        }
        
        .btn.primary {
            background: rgba(33, 150, 243, 0.8);
        }
        
        .log {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 350px;
            max-height: 250px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 10px;
            border-radius: 5px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .status {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 13px;
        }
        
        .status-label {
            color: #ccc;
        }
        
        .status-value {
            color: #ffd700;
            font-weight: bold;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 1000;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #ffd700;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* バウンディングボックス表示用のz-indexを確保 */
        .bounding-box-overlay {
            z-index: 999 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🐱 Purattokun + StableSpineRenderer + BoundingBox</h1>
            <div class="subtitle">最新安定版 - 黒枠問題完全解決 + BB統合テスト + 自動アニメーション検出</div>
        </div>
        
        <div class="canvas-container">
            <canvas id="spine-canvas" width="800" height="600"></canvas>
        </div>
    </div>
    
    <div class="status" id="status-panel">
        <h3 style="margin: 0 0 10px 0; color: #ffd700;">📊 システム状態</h3>
        <div class="status-item">
            <span class="status-label">StableSpineRenderer:</span>
            <span class="status-value" id="renderer-status">初期化中</span>
        </div>
        <div class="status-item">
            <span class="status-label">Purattokun読み込み:</span>
            <span class="status-value" id="nezumi-status">待機中</span>
        </div>
        <div class="status-item">
            <span class="status-label">バウンディングボックス:</span>
            <span class="status-value" id="bbox-status">待機中</span>
        </div>
        <div class="status-item">
            <span class="status-label">統合状態:</span>
            <span class="status-value" id="integration-status">準備中</span>
        </div>
    </div>
    
    <div class="controls">
        <div class="control-group">
            <h3>⭐ StableSpineRenderer</h3>
            <button class="btn primary" id="init-renderer">レンダラー初期化</button>
            <button class="btn" id="load-nezumi">Purattokun読み込み</button>
            <button class="btn" id="play-search">待機アニメーション</button>
            <button class="btn" id="play-kettei">やられアニメーション</button>
        </div>
        
        <div class="control-group">
            <h3>📦 バウンディングボックス</h3>
            <button class="btn" id="create-bbox">BB作成</button>
            <button class="btn" id="toggle-bbox">BB表示切替</button>
            <button class="btn" id="test-resize">リサイズテスト</button>
            <button class="btn danger" id="cleanup-bbox">BBクリーンアップ</button>
        </div>
        
        <div class="control-group">
            <h3>🧪 統合テスト</h3>
            <button class="btn success" id="full-test">完全統合テスト</button>
            <button class="btn" id="performance-test">パフォーマンステスト</button>
            <button class="btn danger" id="reset-all">全リセット</button>
        </div>
        
        <div class="control-group">
            <h3>🔧 デバッグ</h3>
            <button class="btn" id="debug-info">システム情報表示</button>
            <button class="btn" id="clear-log">ログクリア</button>
        </div>
    </div>
    
    <div class="log" id="log-panel">
        <div style="color: #ffd700; margin-bottom: 10px;">📝 システムログ</div>
    </div>
    
    <div class="loading" id="loading-screen">
        <div class="spinner"></div>
        <div>StableSpineRenderer + BB システム読み込み中...</div>
    </div>

    <!-- Spine WebGL -->
    <script src="assets/js/libs/spine-webgl.js"></script>
    
    <!-- StableSpineRenderer -->
    <script src="micromodules/spine-renderer/StableSpineRenderer.js"></script>
    
    <!-- バウンディングボックスマイクロモジュール -->
    <script src="micromodules/bounding-box/PureBoundingBoxCore.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxBounds.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxUI.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxEvents.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBox.js"></script>

    <script>
        /**
         * 🎯 Nezumi + StableSpineRenderer + BoundingBox 統合システム
         * 
         * 特徴:
         * - StableSpineRendererによる確実なSpine表示（黒枠問題解決済み）
         * - PureBoundingBoxによる高度なバウンディングボックス編集
         * - リアルタイム統合テスト機能
         */
        class NezumiStableSpineBBIntegration {
            constructor() {
                this.canvas = document.getElementById('spine-canvas');
                
                // StableSpineRenderer
                this.spineRenderer = null;
                
                // PureBoundingBox
                this.boundingBox = null;
                
                // 状態管理
                this.rendererInitialized = false;
                this.nezumiLoaded = false;
                this.bboxCreated = false;
                this.integrationComplete = false;
                
                this.init();
            }
            
            async init() {
                this.log('🚀 Nezumi StableSpine + BB統合システム初期化開始');
                
                try {
                    // ライブラリ確認
                    await this.checkDependencies();
                    
                    // UI初期化
                    this.initUI();
                    
                    this.hideLoading();
                    this.log('✅ 初期化完了 - レンダラー初期化ボタンを押してください');
                    this.updateStatus('integration-status', '初期化完了');
                    
                } catch (error) {
                    this.log(`❌ 初期化エラー: ${error.message}`);
                    this.hideLoading();
                    this.updateStatus('integration-status', '初期化失敗');
                }
            }
            
            async checkDependencies() {
                this.log('🔍 ライブラリ依存関係確認中...');
                
                // Spine WebGL確認
                if (typeof window.spine === 'undefined') {
                    throw new Error('Spine WebGLライブラリが見つかりません');
                }
                
                // StableSpineRenderer確認
                if (typeof window.StableSpineRenderer === 'undefined') {
                    throw new Error('StableSpineRendererが見つかりません');
                }
                
                // PureBoundingBox確認
                if (typeof window.PureBoundingBox === 'undefined') {
                    throw new Error('PureBoundingBoxが見つかりません');
                }
                
                this.log('✅ 全ライブラリ確認完了');
            }
            
            initUI() {
                this.log('🎨 UI初期化中...');
                
                // StableSpineRenderer制御
                document.getElementById('init-renderer').addEventListener('click', () => this.initRenderer());
                document.getElementById('load-nezumi').addEventListener('click', () => this.loadNezumi());
                document.getElementById('play-search').addEventListener('click', () => this.playAnimation('taiki'));
                document.getElementById('play-kettei').addEventListener('click', () => this.playAnimation('yarare'));
                
                // バウンディングボックス制御
                document.getElementById('create-bbox').addEventListener('click', () => this.createBoundingBox());
                document.getElementById('toggle-bbox').addEventListener('click', () => this.toggleBoundingBox());
                document.getElementById('test-resize').addEventListener('click', () => this.testResize());
                document.getElementById('cleanup-bbox').addEventListener('click', () => this.cleanupBoundingBox());
                
                // 統合テスト
                document.getElementById('full-test').addEventListener('click', () => this.fullIntegrationTest());
                document.getElementById('performance-test').addEventListener('click', () => this.performanceTest());
                document.getElementById('reset-all').addEventListener('click', () => this.resetAll());
                
                // デバッグ
                document.getElementById('debug-info').addEventListener('click', () => this.showDebugInfo());
                document.getElementById('clear-log').addEventListener('click', () => this.clearLog());
                
                this.log('✅ UI初期化完了');
            }
            
            async initRenderer() {
                this.log('⭐ StableSpineRenderer初期化中...');
                this.updateStatus('renderer-status', '初期化中');
                
                try {
                    // StableSpineRenderer作成（canvasも同時に指定）
                    this.spineRenderer = new StableSpineRenderer({
                        canvas: this.canvas,
                        character: 'purattokun',
                        basePath: '/assets/spine/characters/',
                        // defaultAnimation: 自動検出される！（purattokuんの場合は'taiki'が選択される）
                        debug: true,
                        logCallback: (message, level) => this.log(`[Renderer] ${message}`)
                    });
                    
                    // 初期化実行
                    await this.spineRenderer.initialize();
                    
                    this.rendererInitialized = true;
                    this.updateStatus('renderer-status', '初期化完了');
                    this.log('✅ StableSpineRenderer初期化完了');
                    this.log('📝 Nezumi読み込みボタンを押してください');
                    
                } catch (error) {
                    this.log(`❌ StableSpineRenderer初期化エラー: ${error.message}`);
                    this.updateStatus('renderer-status', '初期化失敗');
                }
            }
            
            async loadNezumi() {
                if (!this.rendererInitialized) {
                    this.log('⚠️ 先にレンダラーを初期化してください');
                    return;
                }
                
                this.log('🐱 purattokun読み込み開始...');
                this.updateStatus('nezumi-status', '読み込み中');
                
                try {
                    // StableSpineRendererは initialize() で全て完了
                    // 既に読み込み・描画・アニメーション全て開始済み
                    
                    // 初期アニメーション（自動検出されたものがそのまま使用される）
                    // 追加のplayAnimationは不要（initialize()で自動開始）
                    
                    this.nezumiLoaded = true;
                    this.updateStatus('nezumi-status', '読み込み完了');
                    this.log('✅ purattokun読み込み完了 - 自動検出アニメーション再生中');
                    
                } catch (error) {
                    this.log(`❌ Nezumi読み込みエラー: ${error.message}`);
                    this.updateStatus('nezumi-status', '読み込み失敗');
                }
            }
            
            playAnimation(animationName) {
                if (!this.nezumiLoaded) {
                    this.log('⚠️ 先にNezumiを読み込んでください');
                    return;
                }
                
                try {
                    this.spineRenderer.playAnimation(animationName);
                    this.log(`🎭 アニメーション再生: ${animationName}`);
                } catch (error) {
                    this.log(`❌ アニメーション再生エラー: ${error.message}`);
                }
            }
            
            async createBoundingBox() {
                if (!this.nezumiLoaded) {
                    this.log('⚠️ 先にNezumiを読み込んでください');
                    return;
                }
                
                this.log('📦 バウンディングボックス作成中...');
                this.updateStatus('bbox-status', '作成中');
                
                try {
                    // PureBoundingBox作成
                    this.boundingBox = new window.PureBoundingBox({
                        targetElement: this.canvas,
                        nodeId: 'purattokun-spine-bb-canvas'
                    });
                    
                    // バウンディングボックス実行
                    const result = await this.boundingBox.execute({ 
                        visible: true,
                        interactive: true,
                        showHandles: true
                    });
                    
                    if (result.success) {
                        this.bboxCreated = true;
                        this.updateStatus('bbox-status', '作成完了');
                        this.log('✅ バウンディングボックス作成完了');
                        this.log(`📊 Bounds: x=${result.bounds.x}, y=${result.bounds.y}, w=${result.bounds.width}, h=${result.bounds.height}`);
                    } else {
                        this.log(`❌ バウンディングボックス作成失敗: ${result.error}`);
                        this.updateStatus('bbox-status', '作成失敗');
                    }
                    
                } catch (error) {
                    this.log(`❌ バウンディングボックスエラー: ${error.message}`);
                    this.updateStatus('bbox-status', 'エラー');
                }
            }
            
            toggleBoundingBox() {
                if (!this.boundingBox) {
                    this.log('⚠️ バウンディングボックスが作成されていません');
                    return;
                }
                
                try {
                    const state = this.boundingBox.getState();
                    if (state.bounds && state.bounds.visible) {
                        this.boundingBox.hide();
                        this.log('👻 バウンディングボックス非表示');
                    } else {
                        this.boundingBox.show();
                        this.log('👁️ バウンディングボックス表示');
                    }
                } catch (error) {
                    this.log(`❌ 表示切替エラー: ${error.message}`);
                }
            }
            
            testResize() {
                if (!this.boundingBox) {
                    this.log('⚠️ バウンディングボックスが作成されていません');
                    return;
                }
                
                this.log('🔧 リサイズテスト実行中...');
                
                try {
                    // テスト用のリサイズ実行
                    const currentBounds = this.boundingBox.getBounds();
                    const newWidth = currentBounds.width * 1.2;
                    const newHeight = currentBounds.height * 1.2;
                    
                    this.boundingBox.resize(newWidth, newHeight);
                    this.log(`✅ リサイズテスト完了: ${newWidth.toFixed(0)} x ${newHeight.toFixed(0)}`);
                } catch (error) {
                    this.log(`❌ リサイズテストエラー: ${error.message}`);
                }
            }
            
            cleanupBoundingBox() {
                if (!this.boundingBox) {
                    this.log('⚠️ バウンディングボックスが作成されていません');
                    return;
                }
                
                try {
                    this.boundingBox.cleanup();
                    this.boundingBox = null;
                    this.bboxCreated = false;
                    this.updateStatus('bbox-status', 'クリーンアップ完了');
                    this.log('🧹 バウンディングボックスクリーンアップ完了');
                } catch (error) {
                    this.log(`❌ クリーンアップエラー: ${error.message}`);
                }
            }
            
            async fullIntegrationTest() {
                this.log('🧪 完全統合テスト開始');
                this.updateStatus('integration-status', '統合テスト中');
                
                try {
                    // 1. レンダラー初期化確認
                    if (!this.rendererInitialized) {
                        await this.initRenderer();
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                    
                    // 2. Nezumi読み込み確認
                    if (!this.nezumiLoaded) {
                        await this.loadNezumi();
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                    
                    // 3. バウンディングボックス作成確認
                    if (!this.bboxCreated) {
                        await this.createBoundingBox();
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                    
                    // 4. 動作テスト
                    if (this.rendererInitialized && this.nezumiLoaded && this.bboxCreated) {
                        this.log('🎯 動作テスト実行中...');
                        
                        // アニメーション切り替えテスト
                        this.playAnimation('yarare');
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        this.playAnimation('taiki');
                        
                        // バウンディングボックス表示テスト
                        this.toggleBoundingBox();
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        this.testResize();
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        this.toggleBoundingBox();
                        
                        this.integrationComplete = true;
                        this.updateStatus('integration-status', '統合テスト成功');
                        this.log('🎉 完全統合テスト成功！全機能正常動作確認');
                        
                    } else {
                        this.log('❌ 統合テスト失敗 - 一部機能が動作していません');
                        this.updateStatus('integration-status', '統合テスト失敗');
                    }
                    
                } catch (error) {
                    this.log(`❌ 統合テストエラー: ${error.message}`);
                    this.updateStatus('integration-status', 'エラー');
                }
            }
            
            async performanceTest() {
                this.log('⚡ パフォーマンステスト開始');
                
                const startTime = Date.now();
                
                try {
                    // レンダラーパフォーマンス
                    if (this.spineRenderer) {
                        const renderStart = Date.now();
                        for (let i = 0; i < 10; i++) {
                            this.playAnimation(i % 2 === 0 ? 'taiki' : 'yarare');
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                        const renderTime = Date.now() - renderStart;
                        this.log(`📊 レンダラーパフォーマンス: ${renderTime}ms (10回切り替え)`);
                    }
                    
                    // バウンディングボックスパフォーマンス
                    if (this.boundingBox) {
                        const bboxStart = Date.now();
                        for (let i = 0; i < 5; i++) {
                            this.toggleBoundingBox();
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                        const bboxTime = Date.now() - bboxStart;
                        this.log(`📊 BBパフォーマンス: ${bboxTime}ms (5回切り替え)`);
                    }
                    
                    const totalTime = Date.now() - startTime;
                    this.log(`⚡ パフォーマンステスト完了: 総時間 ${totalTime}ms`);
                    
                } catch (error) {
                    this.log(`❌ パフォーマンステストエラー: ${error.message}`);
                }
            }
            
            resetAll() {
                this.log('🔄 全リセット実行中...');
                
                try {
                    // バウンディングボックスクリーンアップ
                    if (this.boundingBox) {
                        this.cleanupBoundingBox();
                    }
                    
                    // スパインレンダラーストップ
                    if (this.spineRenderer) {
                        this.spineRenderer.stop();
                        this.spineRenderer = null;
                    }
                    
                    // 状態リセット
                    this.rendererInitialized = false;
                    this.nezumiLoaded = false;
                    this.bboxCreated = false;
                    this.integrationComplete = false;
                    
                    // ステータス更新
                    this.updateStatus('renderer-status', 'リセット完了');
                    this.updateStatus('nezumi-status', '待機中');
                    this.updateStatus('bbox-status', '待機中');
                    this.updateStatus('integration-status', 'リセット完了');
                    
                    // キャンバスクリア
                    const ctx = this.canvas.getContext('2d');
                    if (ctx) {
                        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    }
                    
                    this.log('✅ 全リセット完了');
                    
                } catch (error) {
                    this.log(`❌ リセットエラー: ${error.message}`);
                }
            }
            
            showDebugInfo() {
                this.log('🔍 システム情報表示');
                
                const info = {
                    rendererInitialized: this.rendererInitialized,
                    nezumiLoaded: this.nezumiLoaded,
                    bboxCreated: this.bboxCreated,
                    integrationComplete: this.integrationComplete,
                    canvasSize: `${this.canvas.width}x${this.canvas.height}`,
                    spineRenderer: !!this.spineRenderer,
                    boundingBox: !!this.boundingBox
                };
                
                Object.entries(info).forEach(([key, value]) => {
                    this.log(`  ${key}: ${value}`);
                });
                
                // グローバル変数確認
                this.log('📚 ライブラリ状況:');
                this.log(`  spine: ${typeof window.spine}`);
                this.log(`  StableSpineRenderer: ${typeof window.StableSpineRenderer}`);
                this.log(`  PureBoundingBox: ${typeof window.PureBoundingBox}`);
            }
            
            clearLog() {
                const logPanel = document.getElementById('log-panel');
                logPanel.innerHTML = '<div style="color: #ffd700; margin-bottom: 10px;">📝 システムログ</div>';
                this.log('🧹 ログクリア完了');
            }
            
            log(message) {
                const logPanel = document.getElementById('log-panel');
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.style.marginBottom = '3px';
                logEntry.innerHTML = `<span style="color: #666">[${timestamp}]</span> ${message}`;
                logPanel.appendChild(logEntry);
                
                // スクロール調整
                logPanel.scrollTop = logPanel.scrollHeight;
                
                // コンソールにも出力
                console.log(`[NezumiStableSpineBB] ${message}`);
            }
            
            updateStatus(elementId, status) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = status;
                }
            }
            
            hideLoading() {
                const loadingScreen = document.getElementById('loading-screen');
                if (loadingScreen) {
                    loadingScreen.style.display = 'none';
                }
            }
        }
        
        // 🚀 システム起動
        window.addEventListener('load', async () => {
            // ライブラリ読み込み待機
            await new Promise(resolve => setTimeout(resolve, 500));
            
            console.log('🎯 Nezumi + StableSpineRenderer + BoundingBox 統合システム起動');
            
            // システム初期化
            window.nezumiIntegration = new NezumiStableSpineBBIntegration();
            
            // デバッグ用グローバル関数
            window.debugNezumiSystem = () => {
                if (window.nezumiIntegration) {
                    window.nezumiIntegration.showDebugInfo();
                }
            };
        });
    </script>
</body>
</html>