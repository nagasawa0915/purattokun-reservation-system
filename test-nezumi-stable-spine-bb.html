<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>🐱 Purattokun + StableSpineRenderer + BoundingBox テスト</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
        background: linear-gradient(135deg, #2e86ab 0%, #a23b72 100%);
        color: white;
        min-height: 100vh;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .header h1 {
        font-size: 2.5em;
        margin: 0;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .subtitle {
        font-size: 1.2em;
        opacity: 0.9;
        margin-top: 10px;
      }

      /* 🎯 複数キャラクター対応スタイル */
      .characters-container {
        display: flex;
        justify-content: center;
        gap: 40px;
        margin: 0 auto;
        max-width: 800px;
      }

      .character-container {
        position: relative;
        width: 300px;
        height: 300px;
        /* 🎯 視覚的装飾を削除 - キャラクターのみを際立たせる */
        background: transparent;
        overflow: visible; /* BBが表示されるようにvisibleに変更 */
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        transition: all 0.3s ease;
      }

      .character-container:hover {
        border-color: rgba(255, 215, 0, 0.5);
        box-shadow: 0 4px 16px rgba(255, 215, 0, 0.2);
      }

      .character-container canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        /* 🎯 Canvas背景も透明に */
        background: transparent;
        /* 🎯 歪み防止: アスペクト比を維持 */
        object-fit: contain;
        image-rendering: pixelated;
      }

      .character-label {
        position: absolute;
        bottom: -30px;
        left: 50%;
        transform: translateX(-50%);
        color: #ffd700;
        font-size: 14px;
        font-weight: 600;
        text-align: center;
        white-space: nowrap;
      }

      /* レスポンシブ対応 */
      @media (max-width: 768px) {
        .characters-container {
          flex-direction: column;
          align-items: center;
          gap: 20px;
        }
        
        .character-container {
          width: 250px;
          height: 250px;
        }
      }

      .controls {
        position: fixed;
        top: 20px;
        right: 20px;
        bottom: 20px;
        width: 280px;
        background: rgba(0, 0, 0, 0.8);
        padding: 20px;
        border-radius: 10px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        overflow-y: auto;
        overflow-x: hidden;
      }

      .control-group {
        margin-bottom: 15px;
      }

      .control-group h3 {
        margin: 0 0 10px 0;
        font-size: 14px;
        color: #ffd700;
      }

      .btn {
        display: block;
        width: 100%;
        padding: 8px 12px;
        margin: 5px 0;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 12px;
      }

      .btn:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.5);
      }

      .btn.success {
        background: rgba(76, 175, 80, 0.8);
      }

      .btn.danger {
        background: rgba(244, 67, 54, 0.8);
      }

      .btn.primary {
        background: rgba(33, 150, 243, 0.8);
      }

      .log {
        position: fixed;
        bottom: 20px;
        left: 20px;
        width: 350px;
        max-height: 250px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        font-family: "Courier New", monospace;
        font-size: 11px;
        padding: 10px;
        border-radius: 5px;
        overflow-y: auto;
        border: 1px solid rgba(255, 255, 255, 0.2);
        z-index: 1000;
      }

      .status {
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 15px;
        border-radius: 10px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .status-item {
        display: flex;
        justify-content: space-between;
        margin: 5px 0;
        font-size: 13px;
      }

      .status-label {
        color: #ccc;
      }

      .status-value {
        color: #ffd700;
        font-weight: bold;
      }

      .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        z-index: 1000;
      }

      .spinner {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid #ffd700;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* バウンディングボックス表示用のz-indexを確保 */
      .bounding-box-overlay {
        z-index: 999 !important;
      }

      /* スクロールバーのスタイリング */
      .controls::-webkit-scrollbar {
        width: 8px;
      }

      .controls::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
      }

      .controls::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 4px;
      }

      .controls::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.5);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>🐱 Purattokun + StableSpineRenderer + BoundingBox</h1>
        <div class="subtitle">
          最新安定版 - 黒枠問題完全解決 + BB統合テスト + 自動アニメーション検出
        </div>
      </div>

      <!-- 🎯 複数キャラクター対応コンテナ -->
      <div class="characters-container">
        <!-- ぷらっとくん -->
        <div class="character-container" id="purattokun-container">
          <canvas id="purattokun-canvas" width="300" height="300"></canvas>
          <div class="character-label">🐱 ぷらっとくん</div>
        </div>
        
        <!-- ねずみちゃん -->
        <div class="character-container" id="nezumi-container">
          <canvas id="nezumi-canvas" width="300" height="300"></canvas>
          <div class="character-label">🐭 ねずみちゃん</div>
        </div>
      </div>
    </div>

    <div class="status" id="status-panel">
      <h3 style="margin: 0 0 10px 0; color: #ffd700">📊 システム状態</h3>
      <div class="status-item">
        <span class="status-label">StableSpineRenderer:</span>
        <span class="status-value" id="renderer-status">初期化中</span>
      </div>
      <div class="status-item">
        <span class="status-label">Purattokun読み込み:</span>
        <span class="status-value" id="nezumi-status">待機中</span>
      </div>
      <div class="status-item">
        <span class="status-label">バウンディングボックス:</span>
        <span class="status-value" id="bbox-status">待機中</span>
      </div>
      <div class="status-item">
        <span class="status-label">統合状態:</span>
        <span class="status-value" id="integration-status">準備中</span>
      </div>
    </div>

    <div class="controls">
      <div class="control-group">
        <h3>⭐ 複数キャラクター制御</h3>
        <button class="btn primary" id="init-renderer">レンダラー初期化</button>
        <button class="btn" id="load-purattokun">🐱 Purattokun読み込み</button>
        <button class="btn" id="load-nezumi">🐭 Nezumi読み込み</button>
        <button class="btn" id="load-all-characters">🌟 全キャラクター読み込み</button>
      </div>

      <!-- 🎯 キャラクター個別制御 -->
      <div class="control-group">
        <h3>🎮 キャラクター制御</h3>
        <div id="character-controls">
          <p style="color: #ccc; font-size: 12px;">キャラクターを選択すると制御パネルが表示されます</p>
        </div>
      </div>

      <div class="control-group">
        <h3>📦 バウンディングボックス</h3>
        <button class="btn" id="create-bbox">BB作成</button>
        <button class="btn" id="toggle-bbox">BB表示切替</button>
        <button class="btn" id="test-resize">リサイズテスト</button>
        <button class="btn danger" id="cleanup-bbox">BBクリーンアップ</button>
      </div>

      <div class="control-group">
        <h3>🧪 統合テスト</h3>
        <button class="btn success" id="full-test">完全統合テスト</button>
        <button class="btn" id="performance-test">パフォーマンステスト</button>
        <button class="btn danger" id="reset-all">全リセット</button>
      </div>

      <!-- 🔧 デバッグ機能（iframeから移動） -->
      <div class="control-group">
        <h3>🔧 デバッグ機能</h3>
        <button class="btn" id="debug-info-btn">💡 デバッグ情報表示</button>
        <button class="btn" id="clear-log-btn">🗑️ ログクリア</button>
        <button class="btn" id="console-debug">🖥️ コンソールログ</button>
      </div>

      <!-- 🎯 CanvasResizeController マイクロモジュール統合 -->
      <div class="control-group canvas-resize-module">
        <h3>🎛️ Canvas制御システム（マイクロモジュール）</h3>
        <p style="font-size: 0.8em; color: #ccc; margin: 5px 0 10px 0">
          iframe統合による完全分離UI・デスクトップアプリ対応
        </p>
        
        <!-- CanvasResizeController UI iframe -->
        <iframe 
          src="./micromodules/canvas-resize/ui.html" 
          id="canvas-resize-iframe"
          width="100%" 
          height="500"
          frameborder="0"
          style="
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.5);
            overflow: hidden;
          ">
        </iframe>
      </div>
    </div>

    <div class="log" id="log-panel">
      <div style="color: #ffd700; margin-bottom: 10px">📝 システムログ</div>
    </div>

    <div class="loading" id="loading-screen">
      <div class="spinner"></div>
      <div>StableSpineRenderer + BB システム読み込み中...</div>
    </div>

    <!-- Spine WebGL -->
    <script src="assets/js/libs/spine-webgl.js"></script>

    <!-- StableSpineRenderer -->
    <script src="micromodules/spine-renderer/StableSpineRenderer.js"></script>

    <!-- バウンディングボックスマイクロモジュール -->
    <script src="micromodules/bounding-box/PureBoundingBoxCore.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxBounds.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxUI.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBoxEvents.js"></script>
    <script src="micromodules/bounding-box/PureBoundingBox.js"></script>
    
    <!-- 🎯 Phase 1: LogSystem マイクロモジュール -->
    <script src="micromodules/spine-integration/LogSystem.js"></script>

    <script>
      /**
       * 🎯 多キャラクター + StableSpineRenderer + BoundingBox 統合システム
       *
       * 特徴:
       * - 複数キャラクター対応（purattokun + nezumi）
       * - StableSpineRendererによる確実なSpine表示（黒枠問題解決済み）
       * - PureBoundingBoxによる高度なバウンディングボックス編集
       * - キャラクター選択・制御統合システム
       */
      class MultiCharacterStableSpineBBIntegration {
        constructor() {
          // 🎯 複数キャラクター管理
          this.characters = {
            purattokun: {
              canvas: document.getElementById("purattokun-canvas"),
              renderer: null,
              boundingBox: null,
              loaded: false
            },
            nezumi: {
              canvas: document.getElementById("nezumi-canvas"), 
              renderer: null,
              boundingBox: null,
              loaded: false
            }
          };

          // 現在選択中のキャラクター
          this.selectedCharacter = null;

          // 状態管理
          this.rendererInitialized = false;
          this.integrationComplete = false;

          // 🎯 SpineSettingsPersistence マイクロモジュール統合
          this.settingsPersistence = new SpineSettingsPersistence({
            debug: true, // デバッグログ有効
            version: '1.0'
          });

          // 🎯 LogSystem マイクロモジュール統合
          this.logSystem = new SpineLogSystem({
            logLevel: 'info',
            maxLogs: 1000,
            showTimestamp: true,
            enableConsole: true,
            enableHtml: true,
            prefix: '[StableSpineBB]'
          });

          this.init();

          // ウィンドウリサイズ時のCanvas解像度調整
          window.addEventListener('resize', () => {
            setTimeout(() => {
              this.handleWindowResize();
            }, 100);
          });
        }

        async init() {
          this.log("🚀 StableSpine + BB統合システム初期化開始");

          try {
            // ライブラリ確認
            await this.checkDependencies();

            // 🎯 複数キャラクター用UIイベント設定
            this.setupMultiCharacterEventListeners();

            // 🎨 Canvas操作ボタンの拡張（オレンジBB表示機能）
            this.enhanceCanvasButtons();

            // 読み込み画面を非表示
            this.hideLoading();
            
            this.log("✅ 初期化完了 - レンダラー初期化ボタンを押してください");
            this.updateStatus("integration-status", "初期化完了");
          } catch (error) {
            this.log(`❌ 初期化エラー: ${error.message}`);
            this.updateStatus("integration-status", "初期化失敗");
            this.hideLoading(); // エラー時も読み込み画面を非表示
          }
        }

        async checkDependencies() {
          this.log("🔍 ライブラリ依存関係確認中...");

          // SpineLogSystem確認
          if (typeof window.SpineLogSystem === "undefined") {
            throw new Error("SpineLogSystemが見つかりません");
          }

          // Spine WebGL確認
          if (typeof window.spine === "undefined") {
            throw new Error("Spine WebGLライブラリが見つかりません");
          }

          // StableSpineRenderer確認
          if (typeof window.StableSpineRenderer === "undefined") {
            throw new Error("StableSpineRendererが見つかりません");
          }

          // PureBoundingBox確認
          if (typeof window.PureBoundingBox === "undefined") {
            throw new Error("PureBoundingBoxが見つかりません");
          }

          this.log("✅ 全ライブラリ確認完了");
        }

        // 🎯 複数キャラクター用UIイベント設定
        setupMultiCharacterEventListeners() {
          // レンダラー初期化
          const initRendererBtn = document.getElementById("init-renderer");
          if (initRendererBtn) {
            initRendererBtn.onclick = () => this.initRenderer();
          }

          // 個別キャラクター読み込み
          const loadPurattokuBtn = document.getElementById("load-purattokun");
          if (loadPurattokuBtn) {
            loadPurattokuBtn.onclick = () => this.loadPurattokun();
          }

          const loadNezumiBtn = document.getElementById("load-nezumi");
          if (loadNezumiBtn) {
            loadNezumiBtn.onclick = () => this.loadNezumi();
          }

          // 全キャラクター読み込み
          const loadAllBtn = document.getElementById("load-all-characters");
          if (loadAllBtn) {
            loadAllBtn.onclick = () => this.loadAllCharacters();
          }

          // キャラクター選択設定
          this.setupCharacterSelection('purattokun');
          this.setupCharacterSelection('nezumi');

          this.log("✅ 複数キャラクター用イベントリスナー設定完了");
        }

        async initRenderer() {
          this.log("⭐ 複数キャラクター用レンダラー初期化中...");
          this.updateStatus("renderer-status", "初期化中");

          try {
            this.rendererInitialized = true;
            this.updateStatus("renderer-status", "初期化完了");
            this.log("✅ 複数キャラクターシステム初期化完了");
            this.log("📝 キャラクター読み込みボタンを押してください");
          } catch (error) {
            this.log(`❌ レンダラー初期化エラー: ${error.message}`);
            this.updateStatus("renderer-status", "初期化失敗");
          }
        }

        // 🎯 個別キャラクター読み込みメソッド
        async loadCharacter(characterId) {
          if (!this.rendererInitialized) {
            this.log("⚠️ 先にレンダラーを初期化してください");
            return;
          }

          const character = this.characters[characterId];
          if (!character) {
            this.log(`❌ 未知のキャラクター: ${characterId}`);
            return;
          }

          this.log(`🎯 ${characterId} 読み込み開始...`);

          try {
            // StableSpineRenderer作成（1:1の理想比率で設定）
            character.renderer = new StableSpineRenderer({
              canvas: character.canvas,
              character: characterId,
              basePath: "/assets/spine/characters/",
              debug: true,
              position: {
                x: 100,
                y: -100,
                scaleX: 1.0,  // 1:1の理想比率
                scaleY: 1.0   // 1:1の理想比率
              },
              logCallback: (message, level) =>
                this.log(`[${characterId}] ${message}`),
            });

            // 初期化実行
            await character.renderer.initialize();
            character.loaded = true;

            // Canvas解像度を正しく設定（歪み防止）
            this.fixCanvasAspectRatio(character.canvas);

            this.log(`✅ ${characterId} 読み込み完了`);
            
            // キャラクターコンテナにクリックイベント追加
            this.setupCharacterSelection(characterId);
            
            // 初回選択（最初に読み込まれたキャラクター）
            if (!this.selectedCharacter) {
              this.selectCharacter(characterId);
            }

            // CanvasResizeControllerにSpineRenderer初期化完了を通知
            if (window.canvasResizeHandler) {
              this.log(`📡 ${characterId} 初期化完了をCanvasResizeControllerに通知開始`);
              window.canvasResizeHandler.sendToIframe('spineRendererReady', {
                characterId: characterId
              });
              this.log(`📡 ${characterId} 初期化完了をCanvasResizeControllerに通知完了`);
            } else {
              this.log('⚠️ CanvasResizeHandlerが見つかりません - iframe通知をスキップ');
            }

            // 🎯 直接復元アプローチ：メインページ側でSpine設定を復元
            this.restoreSpineSettingsDirectly(characterId);

          } catch (error) {
            this.log(`❌ ${characterId} 読み込み失敗: ${error.message}`);
          }
        }

        // Purattokun読み込み
        async loadPurattokun() {
          return this.loadCharacter('purattokun');
        }

        // 全キャラクター読み込み
        async loadAllCharacters() {
          this.log("🌟 全キャラクター読み込み開始...");
          await this.loadPurattokun();
          await new Promise(resolve => setTimeout(resolve, 500)); // 0.5秒待機
          await this.loadNezumi();
          this.log("🌟 全キャラクター読み込み完了");
        }

        // Nezumi読み込み（新しい個別読み込みメソッドを使用）
        async loadNezumi() {
          return this.loadCharacter('nezumi');
        }

        // 🎯 キャラクター選択システム
        setupCharacterSelection(characterId) {
          const container = document.getElementById(`${characterId}-container`);
          if (!container) return;

          container.style.cursor = 'pointer';
          container.addEventListener('click', () => {
            this.selectCharacter(characterId);
          });
        }

        selectCharacter(characterId) {
          // 既存選択を解除
          if (this.selectedCharacter) {
            this.deselectCharacter(this.selectedCharacter);
          }

          this.selectedCharacter = characterId;
          
          // 視覚的フィードバック
          const container = document.getElementById(`${characterId}-container`);
          container.style.borderColor = '#ff6b35';
          container.style.boxShadow = '0 4px 20px rgba(255, 107, 53, 0.4)';
          
          // キャラクター制御パネル更新
          this.updateCharacterControlPanel(characterId);
          
          // BBを表示
          this.showCharacterBB(characterId);
          
          // CanvasResizeControllerに選択キャラクターを通知
          this.notifyCanvasResizeController(characterId);
          
          this.log(`🎯 キャラクター選択: ${characterId}`);
        }

        deselectCharacter(characterId) {
          const container = document.getElementById(`${characterId}-container`);
          container.style.borderColor = 'rgba(255, 255, 255, 0.2)';
          container.style.boxShadow = '';
          
          // BBを非表示
          this.hideCharacterBB(characterId);
        }

        updateCharacterControlPanel(characterId) {
          const controlsDiv = document.getElementById('character-controls');
          if (!controlsDiv) return;

          controlsDiv.innerHTML = `
            <div style="color: #ffd700; font-weight: bold; margin-bottom: 10px;">
              🎯 選択中: ${characterId === 'purattokun' ? '🐱 ぷらっとくん' : '🐭 ねずみちゃん'}
            </div>
            <button class="btn" onclick="window.multiCharacterSystem.playCharacterAnimation('${characterId}', 'taiki')">待機アニメーション</button>
            <button class="btn" onclick="window.multiCharacterSystem.playCharacterAnimation('${characterId}', 'kettei')">やられアニメーション</button>
            <button class="btn" onclick="window.multiCharacterSystem.toggleCharacterBB('${characterId}')">BB表示切替</button>
          `;
        }

        // 🎯 BB管理システム
        async showCharacterBB(characterId) {
          const character = this.characters[characterId];
          if (!character || !character.loaded) return;

          try {
            // 既存BBがあれば削除
            if (character.boundingBox) {
              character.boundingBox.cleanup();
            }

            // 新しいBB作成
            character.boundingBox = new PureBoundingBox({
              targetElement: character.canvas,
              nodeId: `${characterId}-spine-bb-canvas`,
            });

            // BB実行（表示）
            const result = await character.boundingBox.execute({ visible: true });
            
            if (result.success) {
              this.log(`✅ ${characterId} BB作成完了`);
            } else {
              this.log(`❌ ${characterId} BB作成失敗: ${result.error}`);
            }
          } catch (error) {
            this.log(`❌ ${characterId} BB作成エラー: ${error.message}`);
          }
        }

        hideCharacterBB(characterId) {
          const character = this.characters[characterId];
          if (character && character.boundingBox) {
            character.boundingBox.hide();
          }
        }

        toggleCharacterBB(characterId) {
          const character = this.characters[characterId];
          if (!character || !character.boundingBox) return;

          // BB状態確認して切り替え
          const state = character.boundingBox.getState();
          if (state.uiState.visible) {
            character.boundingBox.hide();
            this.log(`🔍 ${characterId} BB非表示`);
          } else {
            character.boundingBox.show();
            this.log(`🔍 ${characterId} BB表示`);
          }
        }

        // キャラクター個別アニメーション再生
        playCharacterAnimation(characterId, animationName) {
          const character = this.characters[characterId];
          if (!character || !character.loaded) {
            this.log(`⚠️ ${characterId}が読み込まれていません`);
            return;
          }

          try {
            character.renderer.playAnimation(animationName);
            this.log(`🎬 ${characterId}: ${animationName} アニメーション再生`);
          } catch (error) {
            this.log(`❌ ${characterId} アニメーション再生エラー: ${error.message}`);
          }
        }

        playAnimation(animationName) {
          if (!this.nezumiLoaded) {
            this.log("⚠️ 先にNezumiを読み込んでください");
            return;
          }

          try {
            this.spineRenderer.playAnimation(animationName);
            this.log(`🎭 アニメーション再生: ${animationName}`);
          } catch (error) {
            this.log(`❌ アニメーション再生エラー: ${error.message}`);
          }
        }

        async createBoundingBox() {
          if (!this.nezumiLoaded) {
            this.log("⚠️ 先にNezumiを読み込んでください");
            return;
          }

          this.log("📦 バウンディングボックス作成中...");
          this.updateStatus("bbox-status", "作成中");

          try {
            // PureBoundingBox作成
            this.boundingBox = new window.PureBoundingBox({
              targetElement: this.canvas,
              nodeId: "purattokun-spine-bb-canvas",
            });

            // 🎯 BBとCanvas統合動作のコールバック設定
            this.setupBBCanvasIntegration();

            // バウンディングボックス実行
            const result = await this.boundingBox.execute({
              visible: true,
              interactive: true,
              showHandles: true,
            });

            if (result.success) {
              this.bboxCreated = true;
              this.updateStatus("bbox-status", "作成完了");
              this.log("✅ バウンディングボックス作成完了");
              this.log("🔗 BB+Canvas統合動作機能を有効化");
              this.log(
                `📊 Bounds: x=${result.bounds.x}, y=${result.bounds.y}, w=${result.bounds.width}, h=${result.bounds.height}`
              );
            } else {
              this.log(`❌ バウンディングボックス作成失敗: ${result.error}`);
              this.updateStatus("bbox-status", "作成失敗");
            }
          } catch (error) {
            this.log(`❌ バウンディングボックスエラー: ${error.message}`);
            this.updateStatus("bbox-status", "エラー");
          }
        }

        toggleBoundingBox() {
          if (!this.boundingBox) {
            this.log("⚠️ バウンディングボックスが作成されていません");
            return;
          }

          try {
            const state = this.boundingBox.getState();
            if (state.bounds && state.bounds.visible) {
              this.boundingBox.hide();
              this.log("👻 バウンディングボックス非表示");
            } else {
              this.boundingBox.show();
              this.log("👁️ バウンディングボックス表示");
            }
          } catch (error) {
            this.log(`❌ 表示切替エラー: ${error.message}`);
          }
        }

        testResize() {
          if (!this.boundingBox) {
            this.log("⚠️ バウンディングボックスが作成されていません");
            return;
          }

          this.log("🔧 リサイズテスト実行中...");

          try {
            // テスト用のリサイズ実行
            const currentBounds = this.boundingBox.getBounds();
            const newWidth = currentBounds.width * 1.2;
            const newHeight = currentBounds.height * 1.2;

            this.boundingBox.resize(newWidth, newHeight);
            this.log(
              `✅ リサイズテスト完了: ${newWidth.toFixed(
                0
              )} x ${newHeight.toFixed(0)}`
            );
          } catch (error) {
            this.log(`❌ リサイズテストエラー: ${error.message}`);
          }
        }

        cleanupBoundingBox() {
          if (!this.boundingBox) {
            this.log("⚠️ バウンディングボックスが作成されていません");
            return;
          }

          try {
            this.boundingBox.cleanup();
            this.boundingBox = null;
            this.bboxCreated = false;
            this.updateStatus("bbox-status", "クリーンアップ完了");
            this.log("🧹 バウンディングボックスクリーンアップ完了");
          } catch (error) {
            this.log(`❌ クリーンアップエラー: ${error.message}`);
          }
        }

        async fullIntegrationTest() {
          this.log("🧪 完全統合テスト開始");
          this.updateStatus("integration-status", "統合テスト中");

          try {
            // 1. レンダラー初期化確認
            if (!this.rendererInitialized) {
              await this.initRenderer();
              await new Promise((resolve) => setTimeout(resolve, 1000));
            }

            // 2. Nezumi読み込み確認
            if (!this.nezumiLoaded) {
              await this.loadNezumi();
              await new Promise((resolve) => setTimeout(resolve, 2000));
            }

            // 3. バウンディングボックス作成確認
            if (!this.bboxCreated) {
              await this.createBoundingBox();
              await new Promise((resolve) => setTimeout(resolve, 1000));
            }

            // 4. 動作テスト
            if (
              this.rendererInitialized &&
              this.nezumiLoaded &&
              this.bboxCreated
            ) {
              this.log("🎯 動作テスト実行中...");

              // アニメーション切り替えテスト
              this.playAnimation("yarare");
              await new Promise((resolve) => setTimeout(resolve, 2000));
              this.playAnimation("taiki");

              // バウンディングボックス表示テスト
              this.toggleBoundingBox();
              await new Promise((resolve) => setTimeout(resolve, 1000));
              this.testResize();
              await new Promise((resolve) => setTimeout(resolve, 1000));
              this.toggleBoundingBox();

              this.integrationComplete = true;
              this.updateStatus("integration-status", "統合テスト成功");
              this.log("🎉 完全統合テスト成功！全機能正常動作確認");
            } else {
              this.log("❌ 統合テスト失敗 - 一部機能が動作していません");
              this.updateStatus("integration-status", "統合テスト失敗");
            }
          } catch (error) {
            this.log(`❌ 統合テストエラー: ${error.message}`);
            this.updateStatus("integration-status", "エラー");
          }
        }

        async performanceTest() {
          this.log("⚡ パフォーマンステスト開始");

          const startTime = Date.now();

          try {
            // レンダラーパフォーマンス
            if (this.spineRenderer) {
              const renderStart = Date.now();
              for (let i = 0; i < 10; i++) {
                this.playAnimation(i % 2 === 0 ? "taiki" : "yarare");
                await new Promise((resolve) => setTimeout(resolve, 100));
              }
              const renderTime = Date.now() - renderStart;
              this.log(
                `📊 レンダラーパフォーマンス: ${renderTime}ms (10回切り替え)`
              );
            }

            // バウンディングボックスパフォーマンス
            if (this.boundingBox) {
              const bboxStart = Date.now();
              for (let i = 0; i < 5; i++) {
                this.toggleBoundingBox();
                await new Promise((resolve) => setTimeout(resolve, 50));
              }
              const bboxTime = Date.now() - bboxStart;
              this.log(`📊 BBパフォーマンス: ${bboxTime}ms (5回切り替え)`);
            }

            const totalTime = Date.now() - startTime;
            this.log(`⚡ パフォーマンステスト完了: 総時間 ${totalTime}ms`);
          } catch (error) {
            this.log(`❌ パフォーマンステストエラー: ${error.message}`);
          }
        }

        resetAll() {
          this.log("🔄 全リセット実行中...");

          try {
            // バウンディングボックスクリーンアップ
            if (this.boundingBox) {
              this.cleanupBoundingBox();
            }

            // スパインレンダラーストップ
            if (this.spineRenderer) {
              this.spineRenderer.stop();
              this.spineRenderer = null;
            }

            // 状態リセット
            this.rendererInitialized = false;
            this.nezumiLoaded = false;
            this.bboxCreated = false;
            this.integrationComplete = false;

            // ステータス更新
            this.updateStatus("renderer-status", "リセット完了");
            this.updateStatus("nezumi-status", "待機中");
            this.updateStatus("bbox-status", "待機中");
            this.updateStatus("integration-status", "リセット完了");

            // キャンバスクリア
            const ctx = this.canvas.getContext("2d");
            if (ctx) {
              ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            this.log("✅ 全リセット完了");
          } catch (error) {
            this.log(`❌ リセットエラー: ${error.message}`);
          }
        }

        // 🎯 Phase 1: ログ機能はLogSystem.jsに移行済み
        
        /**
         * LogSystem経由のログ出力 - 既存互換性100%保持
         */
        log(message) {
          this.logSystem.log(message);
        }

        // 簡単なステータス更新メソッド
        updateStatus(statusId, message) {
          const statusElement = document.getElementById(statusId);
          if (statusElement) {
            statusElement.textContent = message;
          }
        }

        // 読み込み画面を非表示にする
        hideLoading() {
          const loadingScreen = document.getElementById("loading-screen");
          if (loadingScreen) {
            loadingScreen.style.display = "none";
          }
        }

        // CanvasResizeControllerに選択キャラクター変更を通知
        notifyCanvasResizeController(characterId) {
          const character = this.characters[characterId];
          if (!character || !character.loaded || !character.renderer) {
            this.log(`⚠️ ${characterId} が読み込まれていないため、CanvasResizeController通知をスキップ`);
            return;
          }

          try {
            // 選択されたキャラクターのCanvas情報を取得
            const canvas = character.canvas;
            const renderer = character.renderer;
            
            // 🎯 Canvas情報をUI側が理解できる形式で準備（simple-pin-test.htmlと統一）
            const canvasData = {
              // Canvas解像度情報
              canvasWidth: canvas.width,
              canvasHeight: canvas.height,
              
              // Canvas表示サイズ情報
              displayWidth: parseInt(canvas.style.width) || canvas.width,
              displayHeight: parseInt(canvas.style.height) || canvas.height,
              
              // Spineキャラクター設定情報
              scaleX: renderer.skeleton?.scaleX || 1.0,
              scaleY: renderer.skeleton?.scaleY || 1.0,
              x: renderer.skeleton?.x || 0,
              y: renderer.skeleton?.y || 0,
              
              // キャラクター情報
              characterId: characterId,
              canvasId: canvas.id,
              
              // 取得時刻
              timestamp: Date.now()
            };

            this.log(`📋 ${characterId}のCanvas情報:`, 'info');
            this.log(`  解像度: ${canvasData.canvasWidth}×${canvasData.canvasHeight}px`);
            this.log(`  表示サイズ: ${canvasData.displayWidth}×${canvasData.displayHeight}px`);
            this.log(`  スケール: X:${canvasData.scaleX}, Y:${canvasData.scaleY}`);
            this.log(`  位置: X:${canvasData.x}, Y:${canvasData.y}`);

            // UI側が受信できる'updateCanvasData'メッセージで送信
            if (window.canvasResizeHandler) {
              window.canvasResizeHandler.sendToIframe('updateCanvasData', canvasData);
              this.log(`🎛️ ${characterId}のCanvas情報をUIに送信完了`);
            } else {
              this.log('⚠️ CanvasResizeIframeHandlerが見つかりません');
            }
            
          } catch (error) {
            this.log(`❌ CanvasResizeController通知エラー: ${error.message}`);
          }
        }

        // BBフィードバック送信（CanvasResizeController経由）
        sendBBFeedback(type) {
          if (window.canvasResizeHandler) {
            window.canvasResizeHandler.sendBBFeedback(type);
          }
        }

        // 🎯 SpineSettingsPersistence統合版：メインページ側でSpine設定を復元（キャラクター別）
        restoreSpineSettingsDirectly(characterId) {
          try {
            // SpineSettingsPersistenceから設定を復元
            const settings = this.settingsPersistence.restore(characterId);
            
            if (settings) {
              this.log(`🔄 ${characterId}の保存された設定を直接復元: ${JSON.stringify(settings)}`);
              
              const character = this.characters[characterId];
              if (character && character.loaded && character.renderer && character.renderer.skeleton) {
                
                // スケールの復元
                if (settings.scaleX !== undefined && settings.scaleY !== undefined) {
                  character.renderer.setTransform(null, null, settings.scaleX, settings.scaleY);
                  this.log(`📏 ${characterId} スケール直接復元: X=${settings.scaleX}, Y=${settings.scaleY}`);
                }
                
                // 位置の復元
                if (settings.positionX !== undefined && settings.positionY !== undefined) {
                  character.renderer.setTransform(settings.positionX, settings.positionY, null, null);
                  this.log(`📍 ${characterId} 位置直接復元: X=${settings.positionX}, Y=${settings.positionY}`);
                }
                
                // Canvas解像度の復元
                if (settings.canvasSize !== undefined && settings.canvasSize !== null) {
                  character.canvas.width = settings.canvasSize;
                  character.canvas.height = settings.canvasSize;
                  
                  // WebGLビューポート更新
                  const gl = character.canvas.getContext('webgl');
                  if (gl) {
                    gl.viewport(0, 0, settings.canvasSize, settings.canvasSize);
                  }
                  this.log(`📐 ${characterId} Canvas解像度直接復元: ${settings.canvasSize}x${settings.canvasSize}`);
                }
                
                this.log(`✅ ${characterId} 設定直接復元完了`);
                
              } else {
                this.log(`⚠️ ${characterId} Renderer準備未完了 - 復元スキップ`);
              }
            } else {
              this.log(`📝 ${characterId} 保存された設定が見つかりません（SpineSettingsPersistenceから）`);
            }
          } catch (error) {
            this.log(`❌ ${characterId} 直接復元エラー: ${error.message}`);
            
            // フォールバック：既存のlocalStorage方式で試行
            this.log(`🔄 フォールバック：既存方式で復元試行`);
            this.restoreSpineSettingsDirectlyLegacy(characterId);
          }
        }
        
        // 🔄 フォールバック用：既存のlocalStorage方式（後方互換性）
        restoreSpineSettingsDirectlyLegacy(characterId) {
          try {
            // キャラクター固有のキーを生成（既存形式）
            const pageId = window.location.pathname || 'default';
            const spineKey = `spineSettings-${pageId}-${characterId}`;
            
            const spineData = localStorage.getItem(spineKey);
            if (spineData) {
              const settings = JSON.parse(spineData);
              this.log(`🔄 ${characterId}のフォールバック復元: ${JSON.stringify(settings)}`);
              
              const character = this.characters[characterId];
              if (character && character.loaded && character.renderer && character.renderer.skeleton) {
                
                // スケールの復元
                if (settings.scaleX !== undefined && settings.scaleY !== undefined) {
                  character.renderer.setTransform(null, null, settings.scaleX, settings.scaleY);
                  this.log(`📏 ${characterId} スケールフォールバック復元: X=${settings.scaleX}, Y=${settings.scaleY}`);
                }
                
                // 位置の復元
                if (settings.positionX !== undefined && settings.positionY !== undefined) {
                  character.renderer.setTransform(settings.positionX, settings.positionY, null, null);
                  this.log(`📍 ${characterId} 位置フォールバック復元: X=${settings.positionX}, Y=${settings.positionY}`);
                }
                
                // Canvas解像度の復元
                if (settings.canvasSize !== undefined) {
                  character.canvas.width = settings.canvasSize;
                  character.canvas.height = settings.canvasSize;
                  
                  // WebGLビューポート更新
                  const gl = character.canvas.getContext('webgl');
                  if (gl) {
                    gl.viewport(0, 0, settings.canvasSize, settings.canvasSize);
                  }
                  this.log(`📐 ${characterId} Canvas解像度フォールバック復元: ${settings.canvasSize}x${settings.canvasSize}`);
                }
                
                this.log(`✅ ${characterId} フォールバック設定復元完了`);
                
              } else {
                this.log(`⚠️ ${characterId} Renderer準備未完了 - フォールバック復元スキップ`);
              }
            } else {
              this.log(`📝 ${characterId} フォールバック保存設定が見つかりません`);
            }
          } catch (error) {
            this.log(`❌ ${characterId} フォールバック復元エラー: ${error.message}`);
          }
        }

        // Canvas解像度とアスペクト比を修正（歪み防止）
        fixCanvasAspectRatio(canvas) {
          try {
            // 親コンテナのサイズを取得
            const container = canvas.parentElement;
            const containerRect = container.getBoundingClientRect();
            const containerSize = Math.min(containerRect.width, containerRect.height);
            
            // Canvas解像度を親コンテナサイズに合わせて正方形に設定
            canvas.width = containerSize;
            canvas.height = containerSize;
            
            // WebGLビューポートも更新
            const gl = canvas.getContext('webgl');
            if (gl) {
              gl.viewport(0, 0, containerSize, containerSize);
            }
            
            this.log(`🎯 Canvas解像度修正: ${containerSize}x${containerSize} (歪み防止)`);
          } catch (error) {
            this.log(`❌ Canvas解像度修正エラー: ${error.message}`);
          }
        }

        // ウィンドウリサイズ時の処理
        handleWindowResize() {
          Object.keys(this.characters).forEach(characterId => {
            const character = this.characters[characterId];
            if (character && character.loaded && character.canvas) {
              this.fixCanvasAspectRatio(character.canvas);
            }
          });
        }
        
        // デバウンス付き位置保存（500ms遅延）
        debouncedSavePosition(positionX, positionY) {
          // 前回のタイマーをクリア
          if (this.positionSaveTimer) {
            clearTimeout(this.positionSaveTimer);
          }
          
          // 新しいタイマーを設定
          this.positionSaveTimer = setTimeout(() => {
            const integration = window.nezumiIntegration;
            if (integration && integration.selectedCharacter) {
              // CanvasResizeIframeHandlerからSpinePositioningのsavePositionSettingsを呼び出し
              if (window.spinePositioning && window.spinePositioning.savePositionSettings) {
                window.spinePositioning.savePositionSettings(integration.selectedCharacter, positionX, positionY);
              } else {
                this.log('⚠️ SpinePositioning.savePositionSettingsが見つかりません');
              }
            }
          }, 500);
        }

        /**
         * LogSystem高度機能への便利なアクセサーメソッド
         */
        warn(message) { this.logSystem.warn(message); }
        error(message) { this.logSystem.error(message); }
        success(message) { this.logSystem.success(message); }
        debug(message) { this.logSystem.debug(message); }

        /**
         * ログ管理メソッド
         */
        clearLog() { this.logSystem.clearLog(); }
        exportLogs() { return this.logSystem.exportLogsAsText(); }
        exportLogsJson() { return this.logSystem.exportLogsAsJson(); }
        getLogStats() { return this.logSystem.getStats(); }
        searchLogs(query) { return this.logSystem.searchLogs(query); }
        setLogLevel(level) { this.logSystem.setLogLevel(level); }
        showLogConfig() { this.logSystem.showConfig(); }

        // 🎯 Phase 1: updateStatus(), hideLoading() はUIController.jsに移行済み

        // 📐 Canvas 解像度リサイズ機能（正方形）
        resizeCanvas() {
          try {
            const sizeInput = document.getElementById("canvas-size");
            const newSize = parseInt(sizeInput.value);

            if (!newSize || newSize < 100 || newSize > 1200) {
              this.log("❌ 無効なサイズです（100-1200px）");
              return;
            }

            this.log(
              `🔄 Canvas解像度リサイズ開始: ${this.canvas.width}x${this.canvas.height} → ${newSize}x${newSize}`
            );

            // Canvas属性を正方形に変更
            this.canvas.width = newSize;
            this.canvas.height = newSize;

            // 表示も更新
            document.getElementById("canvas-size-display").textContent = `${newSize}x${newSize}`;

            this.log(
              `✅ Canvas解像度リサイズ完了: ${this.canvas.width}x${this.canvas.height}`
            );

            // WebGLコンテキストがある場合は再初期化が必要
            if (this.spineRenderer && this.nezumiLoaded) {
              this.log("🔄 WebGL再初期化が推奨されます");

              // WebGLビューポートも更新
              const gl = this.canvas.getContext("webgl");
              if (gl) {
                gl.viewport(0, 0, newSize, newSize);
                this.log("✅ WebGL ビューポート更新完了");
              }
            }
          } catch (error) {
            this.log(`❌ Canvas解像度リサイズエラー: ${error.message}`);
          }
        }

        resetCanvasSize() {
          try {
            const sizeInput = document.getElementById("canvas-size");

            // デフォルトサイズに戻す
            sizeInput.value = 800;
            
            // 表示更新
            document.getElementById("canvas-size-display").textContent = "800x800";

            // リサイズ実行
            this.resizeCanvas();

            this.log("✅ Canvas解像度をデフォルト(800x800)に戻しました");
          } catch (error) {
            this.log(`❌ Canvas解像度リセットエラー: ${error.message}`);
          }
        }

        // 🎯 リアルタイム Canvas サイズ表示更新
        updateCanvasSizeDisplay() {
          const sizeInput = document.getElementById("canvas-size");
          const displaySpan = document.getElementById("canvas-size-display");
          if (sizeInput && displaySpan) {
            const size = sizeInput.value;
            displaySpan.textContent = `${size}x${size}`;
          }
        }

        // 🎯 自動サイズ算出機能
        calculateOptimalCanvasSize() {
          try {
            if (!this.spineRenderer || !this.spineRenderer.skeleton) {
              this.log("❌ Spine skeleton が読み込まれていません");
              return null;
            }

            this.log("🔍 キャラクター境界検出開始...");

            // Spineスケルトンの境界取得
            const skeleton = this.spineRenderer.skeleton;

            // 境界情報を格納する変数
            const offset = new spine.Vector2();
            const size = new spine.Vector2();
            const temp = [];

            // Spine公式API: getBounds
            skeleton.getBounds(offset, size, temp);

            // 境界情報をログ出力
            this.log(`📏 検出された境界:`);
            this.log(
              `   オフセット: (${offset.x.toFixed(2)}, ${offset.y.toFixed(2)})`
            );
            this.log(`   サイズ: ${size.x.toFixed(2)} x ${size.y.toFixed(2)}`);

            // 最適Canvasサイズ計算（余白20px）
            const padding = 40; // 余白
            const optimalWidth = Math.ceil(size.x) + padding;
            const optimalHeight = Math.ceil(size.y) + padding;

            const result = {
              detected: {
                offset: { x: offset.x, y: offset.y },
                size: { width: size.x, height: size.y },
              },
              optimal: {
                width: optimalWidth,
                height: optimalHeight,
              },
              reduction: {
                fromWidth: this.canvas.width,
                fromHeight: this.canvas.height,
                reductionRatio:
                  ((this.canvas.width * this.canvas.height -
                    optimalWidth * optimalHeight) /
                    (this.canvas.width * this.canvas.height)) *
                  100,
              },
            };

            this.log(`🎯 最適サイズ: ${optimalWidth} x ${optimalHeight}`);
            this.log(
              `📊 サイズ削減: ${result.reduction.reductionRatio.toFixed(1)}%`
            );

            return result;
          } catch (error) {
            this.log(`❌ 境界検出エラー: ${error.message}`);
            console.error("境界検出エラー:", error);
            return null;
          }
        }

        // 🎯 自動サイズ適用機能（修正版：CSSサイズ変更）
        async applyOptimalCanvasSize() {
          try {
            const optimalSizeInfo = this.calculateOptimalCanvasSize();

            if (!optimalSizeInfo) {
              this.log("❌ 最適サイズの計算に失敗しました");
              return;
            }

            const { width, height } = optimalSizeInfo.optimal;

            this.log("🔄 CSS表示サイズを変更中...");

            // 🆕 重要: CSS表示サイズを変更（これが実際の見た目を変える）
            const container = document.querySelector(".canvas-container");
            container.style.width = width + "px";
            container.style.height = height + "px";

            this.log(`📐 コンテナサイズ変更: ${width}x${height}`);

            // Canvas内部解像度も合わせて変更
            this.canvas.width = width;
            this.canvas.height = height;

            // WebGLビューポート更新
            if (this.spineRenderer && this.spineRenderer.gl) {
              this.spineRenderer.gl.viewport(0, 0, width, height);
              this.log("🔧 WebGLビューポート更新完了");
            }

            // UI入力フィールドも更新
            document.getElementById("canvas-width").value = width;
            document.getElementById("canvas-height").value = height;

            // 🆕 BBサイズも自動更新
            if (this.boundingBox) {
              this.log("📦 BB再作成中...");
              await this.cleanupBoundingBox();
              await new Promise((resolve) => setTimeout(resolve, 100));
              await this.createBoundingBox();
              this.log("✅ 新しいサイズでBB作成完了");
            }

            this.log(`✅ 最適表示サイズ適用完了: ${width}x${height}`);
            this.log(
              `📈 表示サイズ削減効果: ${optimalSizeInfo.reduction.reductionRatio.toFixed(
                1
              )}%`
            );
            this.log(`🎯 無駄な空白を除去しました`);

            return optimalSizeInfo;
          } catch (error) {
            this.log(`❌ 最適サイズ適用エラー: ${error.message}`);
          }
        }

        // 🆕 CSS表示サイズ変更機能（修正版：キャラクターサイズ保持）
        changeCanvasDisplaySize(width, height) {
          try {
            this.log(`🔄 Canvas表示サイズ変更: ${width}x${height}`);

            // コンテナサイズ変更
            const container = document.querySelector(".canvas-container");
            container.style.width = width + "px";
            container.style.height = height + "px";

            // 🎯 重要: Canvas内部解像度は高解像度で維持
            const scale = Math.max(width / 800, height / 600, 0.5); // 最低0.5倍まで
            const internalWidth = Math.max(width, 800 * scale);
            const internalHeight = Math.max(height, 600 * scale);

            this.log(
              `📏 内部解像度: ${internalWidth}x${internalHeight} (scale: ${scale.toFixed(
                2
              )})`
            );

            // Canvas内部解像度設定
            this.canvas.width = internalWidth;
            this.canvas.height = internalHeight;

            // 🎯 Canvas CSS サイズを明示的に設定（100%ではなく）
            this.canvas.style.width = width + "px";
            this.canvas.style.height = height + "px";

            // WebGLビューポート更新
            if (this.spineRenderer && this.spineRenderer.gl) {
              this.spineRenderer.gl.viewport(
                0,
                0,
                internalWidth,
                internalHeight
              );
              this.log("🔧 WebGLビューポート更新完了");
            }

            // Spineキャラクターの位置調整（必要に応じて）
            if (this.spineRenderer && this.spineRenderer.skeleton) {
              // キャラクターを中央に配置
              const centerX = internalWidth / 2;
              const centerY = internalHeight / 2;

              // 既存のtransform値を保持して位置調整
              this.spineRenderer.skeleton.x = centerX;
              this.spineRenderer.skeleton.y = centerY;

              this.log(`🎯 キャラクター位置調整: (${centerX}, ${centerY})`);
            }

            this.log(
              `✅ 表示サイズ変更完了: 表示${width}x${height}, 内部${internalWidth}x${internalHeight}`
            );
          } catch (error) {
            this.log(`❌ 表示サイズ変更エラー: ${error.message}`);
          }
        }

        // 🆕 キャラクターサイズ保持テスト機能
        testCanvasSizeWithCharacterPreservation(displayWidth, displayHeight) {
          try {
            this.log(
              `🧪 キャラクターサイズ保持テスト: ${displayWidth}x${displayHeight}`
            );

            // 現在のキャラクター情報を保存
            let characterScale = 1;
            let characterX = 400; // デフォルト中央
            let characterY = 300;

            if (this.spineRenderer && this.spineRenderer.skeleton) {
              characterScale = this.spineRenderer.skeleton.scaleX;
              characterX = this.spineRenderer.skeleton.x;
              characterY = this.spineRenderer.skeleton.y;
              this.log(
                `📋 現在のキャラクター情報: scale=${characterScale}, pos=(${characterX}, ${characterY})`
              );
            }

            // Canvas表示サイズ変更
            this.changeCanvasDisplaySize(displayWidth, displayHeight);

            // キャラクタースケールを元に戻す
            if (this.spineRenderer && this.spineRenderer.skeleton) {
              this.spineRenderer.skeleton.scaleX = characterScale;
              this.spineRenderer.skeleton.scaleY = characterScale;
              this.log(`🔄 キャラクタースケール復元: ${characterScale}`);
            }
          } catch (error) {
            this.log(`❌ キャラクターサイズ保持テストエラー: ${error.message}`);
          }
        }

        // 🎯 リアルタイムスケール調整（比率保持ロック機能付き + オレンジBB表示）
        updateScaleRealtime(axis) {
          if (!this.spineRenderer || !this.spineRenderer.skeleton) {
            this.log('⚠️ キャラクターが読み込まれていません');
            return;
          }

          const scaleXInput = document.getElementById('character-scale-x');
          const scaleYInput = document.getElementById('character-scale-y');
          const scaleLock = document.getElementById('scale-lock');
          
          // 🔒 比率保持ロック機能
          if (scaleLock.checked) {
            // 初回ロック時または比率が未記録の場合、現在の比率を記録
            if (!this.scaleRatio) {
              this.scaleRatio = parseFloat(scaleYInput.value) / parseFloat(scaleXInput.value);
              this.log(`🔒 比率ロック開始: Y/X = ${this.scaleRatio.toFixed(3)}`);
            }
            
            if (axis === 'x') {
              // Xを変更した場合、Yを比率に従って自動調整
              const newX = parseFloat(scaleXInput.value);
              const newY = newX * this.scaleRatio;
              scaleYInput.value = newY.toFixed(2);
              this.log(`🔄 比率保持: X=${newX} → Y=${newY.toFixed(2)} (比率${this.scaleRatio.toFixed(3)})`);
            } else if (axis === 'y') {
              // Yを変更した場合、Xを比率に従って自動調整
              const newY = parseFloat(scaleYInput.value);
              const newX = newY / this.scaleRatio;
              scaleXInput.value = newX.toFixed(2);
              this.log(`🔄 比率保持: Y=${newY} → X=${newX.toFixed(2)} (比率${this.scaleRatio.toFixed(3)})`);
            }
          } else {
            // ロック解除時は比率をクリア
            this.scaleRatio = null;
          }

          const scaleXValue = parseFloat(scaleXInput.value);
          const scaleYValue = parseFloat(scaleYInput.value);
          
          try {
            // リアルタイム適用
            this.spineRenderer.setTransform(null, null, scaleXValue, scaleYValue);
            
            // 表示値更新
            document.getElementById('scale-x-value').textContent = scaleXValue;
            document.getElementById('scale-y-value').textContent = scaleYValue;

            // 🎨 スケール調整中はオレンジBBを表示（視覚フィードバック）
            this.showCharacterAdjustmentBB();
            
          } catch (error) {
            this.log(`❌ リアルタイムスケールエラー: ${error.message}`);
          }
        }

        applyCharacterScale() {
          // リアルタイム対応により、この関数は基本的に不要
          // ただし互換性のために残す
          this.updateScaleRealtime();
        }

        resetCharacterScale() {
          document.getElementById('character-scale-x').value = '1.35';
          document.getElementById('character-scale-y').value = '1.0';
          document.getElementById('scale-x-value').textContent = '1.35';
          document.getElementById('scale-y-value').textContent = '1.0';
          this.applyCharacterScale();
          this.log('🔄 スケールを理想的な比率に戻しました（X=1.35, Y=1.0）');
        }

        // 🎯 自然な比率検出機能
        detectNaturalRatio() {
          if (!this.spineRenderer || !this.spineRenderer.skeleton) {
            this.log('⚠️ キャラクターが読み込まれていません');
            return;
          }

          // よく使われるキャラクター比率を試す
          const commonRatios = [
            { x: 1.0, y: 1.3, name: '縦長' },
            { x: 1.3, y: 1.0, name: '横長' },
            { x: 1.0, y: 1.2, name: '少し縦長' },
            { x: 1.2, y: 1.0, name: '少し横長' },
            { x: 1.0, y: 1.0, name: '正方形' }
          ];

          this.log('🔍 自然な比率を検出中...');
          
          // 最初の比率（縦長）を試す
          const ratio = commonRatios[0];
          document.getElementById('character-scale-x').value = ratio.x;
          document.getElementById('character-scale-y').value = ratio.y;
          document.getElementById('scale-x-value').textContent = ratio.x;
          document.getElementById('scale-y-value').textContent = ratio.y;
          
          this.applyCharacterScale();
          this.log(`💡 試行: ${ratio.name} (X=${ratio.x}, Y=${ratio.y}) - 自然に見えるか確認してください`);
          this.log('🎯 スライダーで微調整して最適な比率を見つけてください');
        }

        // 🎯 リアルタイム位置調整
        updatePositionRealtime(axis) {
          if (!this.spineRenderer || !this.spineRenderer.skeleton) {
            return; // ログなしで静かに終了（頻繁に呼ばれるため）
          }

          const xValue = parseInt(document.getElementById('character-x').value);
          const yValue = parseInt(document.getElementById('character-y').value);
          
          try {
            // リアルタイム適用
            this.spineRenderer.setTransform(xValue, yValue, null, null);
            
            // 表示値更新
            document.getElementById('x-value').textContent = xValue;
            document.getElementById('y-value').textContent = yValue;

            // 🎨 位置調整中はオレンジBBを表示（視覚フィードバック）
            this.showCharacterAdjustmentBB();
            
            // 💾 デバウンス処理で位置保存（パフォーマンス最適化）
            if (window.canvasResizeHandler) {
              window.canvasResizeHandler.debouncedSavePosition(xValue, yValue);
            }
            
          } catch (error) {
            // リアルタイムなのでエラーログは控えめに
            console.warn('位置更新エラー:', error.message);
          }
        }

        applyCharacterPosition() {
          // リアルタイム対応により、この関数は基本的に不要
          // ただし互換性のために残す
          this.updatePositionRealtime();
          
          // BBが作成されている場合は再作成
          if (this.boundingBox) {
            const xValue = parseInt(document.getElementById('character-x').value);
            const yValue = parseInt(document.getElementById('character-y').value);
            this.log(`✅ キャラクター位置確定: (${xValue}, ${yValue})`);
            
            this.log('📦 位置変更によりBB再作成中...');
            setTimeout(async () => {
              await this.cleanupBoundingBox();
              await new Promise(resolve => setTimeout(resolve, 100));
              await this.createBoundingBox();
            }, 100);
          }
        }

        centerCharacter() {
          const canvasWidth = this.canvas ? this.canvas.width : 800;
          const canvasHeight = this.canvas ? this.canvas.height : 600;
          
          const centerX = canvasWidth / 2;
          const centerY = canvasHeight / 2;
          
          // UIを更新
          document.getElementById('character-x').value = centerX;
          document.getElementById('character-y').value = centerY;
          document.getElementById('x-value').textContent = centerX;
          document.getElementById('y-value').textContent = centerY;
          
          // 適用
          this.applyCharacterPosition();
          this.log(`📍 キャラクターを中央に配置: (${centerX}, ${centerY})`);
        }

        resetCharacterPosition() {
          // デフォルト位置に戻す
          document.getElementById('character-x').value = '100';
          document.getElementById('character-y').value = '-100';
          document.getElementById('x-value').textContent = '100';
          document.getElementById('y-value').textContent = '-100';
          
          this.applyCharacterPosition();
          this.log('🔄 位置をデフォルトに戻しました');
        }

        // 🎯 現在の位置を取得してUIに反映（読み込み後の同期用）
        syncPositionUI() {
          if (this.spineRenderer && this.spineRenderer.skeleton) {
            const x = Math.round(this.spineRenderer.skeleton.x);
            const y = Math.round(this.spineRenderer.skeleton.y);
            const scaleX = this.spineRenderer.skeleton.scaleX;
            const scaleY = this.spineRenderer.skeleton.scaleY;
            
            // 🎯 現在のスケール比率を詳細ログ出力
            this.log(`🔍 現在のスケール詳細: scaleX=${scaleX}, scaleY=${scaleY}, 比率=${(scaleY/scaleX).toFixed(3)}`);
            
            // スケールが異なる場合の処理（コメントアウトして現在の状態を確認）
            let scale = scaleX;
            // if (Math.abs(scaleX - scaleY) > 0.01) {
            //   this.spineRenderer.skeleton.scaleY = scaleX;
            //   this.log(`🔄 スケール統一: scaleY ${scaleY} → ${scaleX} (等倍維持)`);
            //   scale = scaleX;
            // }
            
            // UI同期
            document.getElementById('character-x').value = x;
            document.getElementById('character-y').value = y;
            document.getElementById('x-value').textContent = x;
            document.getElementById('y-value').textContent = y;
            document.getElementById('character-scale-x').value = scaleX;
            document.getElementById('character-scale-y').value = scaleY;
            document.getElementById('scale-x-value').textContent = scaleX;
            document.getElementById('scale-y-value').textContent = scaleY;
            
            this.log(`🔄 UI同期完了: 位置(${x}, ${y}), 現在スケール${scale}`);
            
            // 🎯 推奨スケール比率を提案
            if (Math.abs(scaleX - scaleY) > 0.01) {
              const ratio = scaleY / scaleX;
              this.log(`💡 このキャラクターの自然な縦横比: Y軸 ${ratio.toFixed(2)}倍 がオリジナル設計かもしれません`);
            }
          }
        }

        // 🔗 BBとCanvas統合動作システム
        setupBBCanvasIntegration() {
          this.log("🔗 BB+Canvas統合動作システム設定中...");
          
          // BBのイベントハンドラーをオーバーライドして統合動作を追加
          const originalBounds = this.boundingBox.bounds;
          const originalEvents = this.boundingBox.events;
          
          // 🎯 ドラッグ開始時のオーバーライド
          if (originalEvents && originalEvents.onPointerDown) {
            const originalPointerDown = originalEvents.onPointerDown.bind(originalEvents);
            originalEvents.onPointerDown = (event) => {
              this.log("🖱️ BB+Canvas統合ドラッグ開始");
              this.bbDragStart = {
                canvasX: this.canvas.offsetLeft,
                canvasY: this.canvas.offsetTop,
                characterX: this.spineRenderer?.skeleton?.x || 0,
                characterY: this.spineRenderer?.skeleton?.y || 0,
              };
              return originalPointerDown(event);
            };
          }
          
          // 🎯 ドラッグ移動時のオーバーライド
          if (originalEvents && originalEvents.onPointerMove) {
            const originalPointerMove = originalEvents.onPointerMove.bind(originalEvents);
            originalEvents.onPointerMove = (event) => {
              const result = originalPointerMove(event);
              
              // BBが移動した場合、Canvas+キャラクターも一緒に移動
              if (originalEvents.isDragging && this.bbDragStart) {
                this.syncCanvasWithBB();
              }
              
              return result;
            };
          }
          
          // 🎯 リサイズ時のオーバーライド（ハンドル操作）
          if (originalBounds && originalBounds.resize) {
            const originalResize = originalBounds.resize.bind(originalBounds);
            originalBounds.resize = (newWidth, newHeight) => {
              this.log(`🔄 BB+Canvas統合リサイズ: ${newWidth}x${newHeight}`);
              
              // 元のリサイズ実行
              const result = originalResize(newWidth, newHeight);
              
              // Canvas表示サイズも連動して変更
              this.syncCanvasSizeWithBB(newWidth, newHeight);
              
              return result;
            };
          }
          
          this.log("✅ BB+Canvas統合動作システム設定完了");
        }

        // 🔗 BBの移動にCanvasを同期
        syncCanvasWithBB() {
          if (!this.boundingBox || !this.spineRenderer) return;
          
          try {
            // BBの現在位置を取得
            const bbBounds = this.boundingBox.getBounds();
            
            if (this.bbDragStart && bbBounds) {
              // 移動量を計算
              const deltaX = bbBounds.x - (this.bbDragStart.canvasX || 0);
              const deltaY = bbBounds.y - (this.bbDragStart.canvasY || 0);
              
              // キャラクターの位置も同期して移動
              if (this.spineRenderer.skeleton) {
                const newCharacterX = this.bbDragStart.characterX + deltaX;
                const newCharacterY = this.bbDragStart.characterY + deltaY;
                
                this.spineRenderer.setTransform(newCharacterX, newCharacterY, null, null);
                this.syncPositionUI();
                
                this.log(`🔄 統合移動: BB(${bbBounds.x}, ${bbBounds.y}) → キャラ(${newCharacterX}, ${newCharacterY})`);
              }
            }
          } catch (error) {
            this.log(`⚠️ Canvas同期エラー: ${error.message}`);
          }
        }

        // 🔗 BBのサイズ変更にCanvasサイズを同期
        syncCanvasSizeWithBB(newWidth, newHeight) {
          try {
            this.log(`🔄 Canvas表示サイズ同期: ${newWidth}x${newHeight}`);
            
            // Canvas表示サイズを変更（高解像度保持）
            this.changeCanvasDisplaySize(newWidth, newHeight);
            
            // キャラクタースケールも連動調整（オプション）
            if (this.spineRenderer && this.spineRenderer.skeleton) {
              // BBサイズの変化比率でキャラクタースケールを調整
              const scaleRatio = Math.min(newWidth / 300, newHeight / 300); // 基準サイズ300pxと仮定
              const newScale = Math.max(0.5, Math.min(2.0, scaleRatio)); // 0.5-2.0倍に制限
              
              this.spineRenderer.setTransform(null, null, newScale, newScale);
              this.syncPositionUI();
              
              this.log(`🔄 統合スケール調整: ${newScale.toFixed(2)}倍`);
            }
          } catch (error) {
            this.log(`⚠️ Canvas サイズ同期エラー: ${error.message}`);
          }
        }

        // 🎨 CanvasのBBをオレンジ色で表示する機能
        async showCanvasResizeMode() {
          this.log("🎨 CanvasリサイズモードBB表示開始");
          
          // 既存のCanvasリサイズBBがあれば削除
          await this.hideCanvasResizeMode();
          
          try {
            // Canvas用のオレンジ色BBを作成
            this.canvasResizeBB = new window.PureBoundingBox({
              targetElement: this.canvas,
              nodeId: "canvas-resize-bb-orange",
            });

            // BB実行（オレンジ色でカスタマイズ）
            const result = await this.canvasResizeBB.execute({
              visible: true,
              interactive: false, // Canvas操作モードなので編集不可
              showHandles: false, // ハンドル非表示
            });

            if (result.success) {
              // BBの色をオレンジに変更
              this.customizeCanvasBBColor();
              
              this.canvasResizeMode = true;
              this.log("✅ CanvasオレンジBB表示完了");
              
              // Canvas情報をログに表示
              const displaySize = `${document.querySelector('.canvas-container').offsetWidth}x${document.querySelector('.canvas-container').offsetHeight}`;
              const resolution = `${this.canvas.width}x${this.canvas.height}`;
              this.log(`📊 Canvas情報: 表示${displaySize} | 解像度${resolution}`);
              
            } else {
              this.log(`❌ CanvasオレンジBB作成失敗: ${result.error}`);
            }
            
          } catch (error) {
            this.log(`❌ CanvasオレンジBB表示エラー: ${error.message}`);
          }
        }

        async hideCanvasResizeMode() {
          try {
            if (this.canvasResizeBB) {
              this.canvasResizeBB.cleanup();
              this.canvasResizeBB = null;
            }
            
            this.canvasResizeMode = false;
            this.log("👻 CanvasオレンジBB非表示完了");
            
          } catch (error) {
            this.log(`❌ CanvasオレンジBB非表示エラー: ${error.message}`);
          }
        }

        // BBをオレンジ色にカスタマイズ（強化版）
        customizeCanvasBBColor() {
          try {
            // 少し待ってからDOMが構築されるのを待つ
            setTimeout(() => {
              // 複数の方法でBB要素を探す
              let bbContainer = document.querySelector('[data-node-id="canvas-resize-bb-orange"]');
              
              if (!bbContainer) {
                // 別のセレクターで試す
                bbContainer = document.querySelector('[id*="canvas-resize-bb"]');
              }
              
              if (!bbContainer) {
                // PureBoundingBoxの一般的なセレクターで試す
                const allBBs = document.querySelectorAll('[class*="bounding"], [class*="bb-"], [data-node-id]');
                bbContainer = Array.from(allBBs).find(el => 
                  el.getAttribute('data-node-id') === 'canvas-resize-bb-orange' ||
                  (el.id && el.id.includes('canvas-resize-bb'))
                );
              }
              
              if (bbContainer) {
                this.log(`🎯 Canvas BB要素発見: ${bbContainer.tagName}.${bbContainer.className}`);
                
                // 🎨 強制的にオレンジ色を適用（Canvas操作用）
                bbContainer.style.cssText += `
                  border: 3px solid #FF6B35 !important;
                  background-color: rgba(255, 107, 53, 0.1) !important;
                  box-shadow: 0 0 15px rgba(255, 107, 53, 0.4) !important;
                `;
                
                // 🚫 ハンドルを完全に削除
                const handles = bbContainer.querySelectorAll('[class*="handle"], [class*="resize"], [style*="cursor"], .handle, .resize-handle');
                handles.forEach(handle => {
                  handle.style.display = 'none !important';
                  handle.remove(); // 完全に削除
                });
                
                // 子要素も全てオレンジに強制変更とハンドル削除
                const allChildren = bbContainer.querySelectorAll('*');
                allChildren.forEach(child => {
                  // ハンドル関連クラス名・スタイルをチェック
                  const isHandle = child.className && (
                    child.className.includes('handle') || 
                    child.className.includes('resize') ||
                    child.className.includes('corner') ||
                    child.className.includes('edge')
                  );
                  
                  const hasHandleCursor = child.style.cursor && (
                    child.style.cursor.includes('resize') ||
                    child.style.cursor === 'pointer' ||
                    child.style.cursor === 'move'
                  );
                  
                  if (isHandle || hasHandleCursor) {
                    child.style.display = 'none !important';
                    child.remove();
                    return;
                  }
                  
                  // その他の要素はオレンジに強制変更
                  if (child.style.borderColor || child.style.border || child.tagName === 'DIV') {
                    child.style.borderColor = '#FF6B35 !important';
                  }
                  if (child.style.backgroundColor || child.tagName === 'DIV') {
                    child.style.backgroundColor = 'rgba(255, 107, 53, 0.1) !important';
                  }
                });
                
                // マウスイベントを無効化（編集できないように）
                bbContainer.style.pointerEvents = 'none !important';
                
                this.log("✅ Canvas BBオレンジ色カスタマイズ＆ハンドル完全削除完了");
              } else {
                this.log("⚠️ Canvas BB要素が見つかりません");
                // デバッグ用：現在のDOM状況をログ出力
                const allElements = document.querySelectorAll('[data-node-id], [class*="bound"], [id*="bb"]');
                this.log(`🔍 BB関連要素数: ${allElements.length}`);
                allElements.forEach(el => {
                  this.log(`  - ${el.tagName}.${el.className} [${el.getAttribute('data-node-id') || el.id}]`);
                });
              }
            }, 100); // 100ms待機でDOM構築を確実にする
            
          } catch (error) {
            this.log(`❌ Canvas BB色変更エラー: ${error.message}`);
          }
        }

        // 🎨 キャラクター調整時のオレンジBB表示機能
        async showCharacterAdjustmentBB() {
          // 既にキャラクター調整BBが表示中の場合は何もしない（頻繁な呼び出し対策）
          if (this.characterAdjustmentBBActive) {
            return;
          }

          try {
            // Canvas要素を対象にしたオレンジBB（キャラクター位置の視覚フィードバック）
            this.characterAdjustmentBB = new window.PureBoundingBox({
              targetElement: this.canvas,
              nodeId: "character-adjustment-bb-orange",
            });

            // BB実行（オレンジ色・ハンドルなし・非インタラクティブ）
            const result = await this.characterAdjustmentBB.execute({
              visible: true,
              interactive: false, // 編集不可
              showHandles: false, // ハンドル非表示
            });

            if (result.success) {
              this.characterAdjustmentBBActive = true;

              // BBの色をオレンジに変更（キャラクター調整用）
              setTimeout(() => {
                this.customizeCharacterAdjustmentBBColor();
              }, 50);

              // 2秒後に自動非表示（操作の邪魔にならないように）
              clearTimeout(this.characterAdjustmentTimeout);
              this.characterAdjustmentTimeout = setTimeout(async () => {
                await this.hideCharacterAdjustmentBB();
              }, 2000);

              this.log("✅ キャラクター調整用オレンジBB表示");
            } else {
              this.log(`❌ キャラクター調整BB作成失敗: ${result.error}`);
            }

          } catch (error) {
            this.log(`❌ キャラクター調整BB表示エラー: ${error.message}`);
          }
        }

        async hideCharacterAdjustmentBB() {
          try {
            if (this.characterAdjustmentBB) {
              this.characterAdjustmentBB.cleanup();
              this.characterAdjustmentBB = null;
            }
            
            this.characterAdjustmentBBActive = false;
            clearTimeout(this.characterAdjustmentTimeout);
            
          } catch (error) {
            this.log(`❌ キャラクター調整BB非表示エラー: ${error.message}`);
          }
        }

        // キャラクター調整用BBをオレンジ色にカスタマイズ
        customizeCharacterAdjustmentBBColor() {
          try {
            // 複数の方法でBB要素を探す
            let bbContainer = document.querySelector('[data-node-id="character-adjustment-bb-orange"]');
            
            if (!bbContainer) {
              // 別のセレクターで試す
              bbContainer = document.querySelector('[id*="character-adjustment-bb"]');
            }
            
            if (!bbContainer) {
              // PureBoundingBoxの一般的なセレクターで試す
              const allBBs = document.querySelectorAll('[class*="bounding"], [class*="bb-"], [data-node-id]');
              bbContainer = Array.from(allBBs).find(el => 
                el.getAttribute('data-node-id') === 'character-adjustment-bb-orange' ||
                (el.id && el.id.includes('character-adjustment-bb'))
              );
            }
            
            if (bbContainer) {
              this.log(`🎯 キャラクター調整BB要素発見: ${bbContainer.tagName}.${bbContainer.className}`);
              
              // 🎨 強制的にオレンジ色を適用（キャラクター調整用）
              bbContainer.style.cssText += `
                border: 2px solid #FF6B35 !important;
                background-color: rgba(255, 107, 53, 0.15) !important;
                box-shadow: 0 0 10px rgba(255, 107, 53, 0.3) !important;
              `;
              
              // 🚫 ハンドルを完全に削除
              const handles = bbContainer.querySelectorAll('[class*="handle"], [class*="resize"], [style*="cursor"]');
              handles.forEach(handle => {
                handle.style.display = 'none';
                handle.remove();
              });
              
              // 子要素のハンドル・リサイザーも削除
              const allChildren = bbContainer.querySelectorAll('*');
              allChildren.forEach(child => {
                if (child.className && (
                  child.className.includes('handle') || 
                  child.className.includes('resize') ||
                  child.style.cursor === 'pointer' ||
                  child.style.cursor === 'move'
                )) {
                  child.remove();
                  return;
                }
                
                // その他の要素は薄いオレンジに
                if (child.style.borderColor || child.style.border) {
                  child.style.borderColor = '#FF6B35';
                }
              });
              
              // マウスイベントを無効化（編集できないように）
              bbContainer.style.pointerEvents = 'none';
              
              this.log("✅ キャラクター調整BBオレンジ色カスタマイズ完了");
            } else {
              this.log("⚠️ キャラクター調整BB要素が見つかりません");
            }
            
          } catch (error) {
            this.log(`❌ キャラクター調整BB色変更エラー: ${error.message}`);
          }
        }

        // Canvas操作関連ボタンにリサイズモード表示機能を統合
        enhanceCanvasButtons() {
          const canvasButtons = [
            'resize-canvas',
            'reset-canvas', 
            'detect-bounds',
            'apply-optimal',
            'test-medium'
          ];
          
          canvasButtons.forEach(buttonId => {
            const button = document.getElementById(buttonId);
            if (button) {
              // 既存のクリックイベントを保持
              const originalOnClick = button.onclick;
              
              button.onclick = async () => {
                // CanvasオレンジBB表示
                await this.showCanvasResizeMode();
                
                // 元の機能実行
                if (originalOnClick) {
                  originalOnClick.call(this);
                }
                
                // 3秒後に自動非表示（操作の邪魔にならないように）
                setTimeout(async () => {
                  await this.hideCanvasResizeMode();
                }, 3000);
              };
            }
          });
          
          this.log("🔧 Canvas操作ボタンにオレンジBB表示機能を統合");
        }
      }

      // 🎯 グローバル関数定義（HTML inlineから呼び出し用）
      window.updateScaleRealtime = function(axis) {
        if (window.nezumiIntegration) {
          window.nezumiIntegration.updateScaleRealtime(axis);
        }
      };

      window.updatePositionRealtime = function(axis) {
        if (window.nezumiIntegration) {
          window.nezumiIntegration.updatePositionRealtime(axis);
        }
      };

      // 🎛️ CanvasResizeController iframe 通信システム
      class CanvasResizeIframeHandler {
        constructor() {
          this.iframe = null;
          this.iframeLoaded = false;
          this.messageQueue = []; // 待機中メッセージのキュー
          this.positionSaveTimer = null; // デバウンス用タイマー
          this.setupIframeCommunication();
        }

        setupIframeCommunication() {
          // iframe読み込み完了を待機
          window.addEventListener('load', () => {
            this.iframe = document.getElementById('canvas-resize-iframe');
            if (this.iframe) {
              this.iframe.onload = () => {
                this.iframeLoaded = true;
                this.log('🎛️ CanvasResizeController iframe 読み込み完了');
                this.log(`📋 待機中メッセージ処理開始 - キューサイズ: ${this.messageQueue.length}`);
                this.processQueuedMessages();
              };
              
              // 🔧 即座にiframe読み込み状態を確認（既に読み込み済みの場合への対応）
              if (this.iframe.contentDocument && this.iframe.contentDocument.readyState === 'complete') {
                this.log('🎛️ iframe既に読み込み済み - 即座に初期化');
                this.iframeLoaded = true;
                this.processQueuedMessages();
              } else {
                // 🔧 定期的に読み込み状態をチェック（フォールバック）
                let checkCount = 0;
                const checkIframeReady = () => {
                  checkCount++;
                  try {
                    if (this.iframe.contentDocument && this.iframe.contentDocument.readyState === 'complete') {
                      this.log(`🎛️ iframe読み込み検出（${checkCount}回目チェック）`);
                      this.iframeLoaded = true;
                      this.processQueuedMessages();
                      return;
                    }
                  } catch (error) {
                    // CORS等でcontentDocumentにアクセスできない場合もある
                  }
                  
                  if (checkCount < 20) { // 最大10秒間チェック（500ms間隔）
                    setTimeout(checkIframeReady, 500);
                  } else {
                    this.log('⚠️ iframe読み込み確認タイムアウト - 強制処理実行');
                    this.iframeLoaded = true;
                    this.processQueuedMessages();
                  }
                };
                setTimeout(checkIframeReady, 500);
              }
            }
          });

          // postMessage受信ハンドラー
          window.addEventListener('message', (event) => {
            this.handleIframeMessage(event);
          });
        }

        handleIframeMessage(event) {
          // iframe からのメッセージを検証
          if (!this.iframe || event.source !== this.iframe.contentWindow) {
            return;
          }

          const { type, data } = event.data;
          
          if (!window.nezumiIntegration) {
            console.warn('⚠️ NezumiIntegration not ready');
            return;
          }

          this.log(`📨 iframe メッセージ受信: ${type}`);

          switch (type) {
            // Canvas解像度制御
            case 'canvasResize':
              this.handleCanvasResize(data);
              break;
            case 'canvasReset':
              this.handleCanvasReset();
              break;

            // スケール制御
            case 'scaleChanged':
              this.handleScaleChange(data);
              break;
            case 'scaleReset':
              this.handleScaleReset(data);
              break;
            // naturalRatioDetect機能は削除済み

            // 位置制御
            case 'positionChanged':
              this.handlePositionChange(data);
              break;
            // positionReset機能は削除済み（centerCharacterと重複のため）
            case 'centerCharacter':
              this.handleCenterCharacter(data);
              break;

            // 削除済み機能: detectBounds, applyOptimal, testMedium, debugInfo, clearLog

            // UI状態管理
            case 'uiReady':
              this.handleUIReady(data);
              break;
            case 'uiLog':
              this.handleUILog(data);
              break;

            default:
              this.log(`❓ 未知のメッセージタイプ: ${type}`);
              break;
          }
        }

        // Canvas解像度制御（複数キャラクター対応 + SpineSettingsPersistence統合）
        handleCanvasResize(data) {
          const integration = window.nezumiIntegration;
          if (!integration || !integration.selectedCharacter) {
            this.log('⚠️ 選択されたキャラクターがありません');
            return;
          }

          const character = integration.characters[integration.selectedCharacter];
          if (character && character.loaded && character.renderer) {
            // 選択されたキャラクターのCanvas解像度変更を実行
            character.canvas.width = data.size;
            character.canvas.height = data.size;
            
            // WebGLビューポート更新
            const gl = character.canvas.getContext('webgl');
            if (gl) {
              gl.viewport(0, 0, data.size, data.size);
            }
            
            // 💾 SpineSettingsPersistenceで設定保存
            this.saveCanvasSettings(integration.selectedCharacter, data.size);
            
            this.log(`✅ ${integration.selectedCharacter} Canvas解像度変更完了: ${data.size}x${data.size}`);
          } else {
            this.log('⚠️ 選択されたキャラクターが読み込まれていません');
          }
        }

        handleCanvasReset() {
          this.handleCanvasResize({ size: 800 });
          this.log('🔄 Canvas解像度をデフォルトにリセット');
        }

        // スケール制御（複数キャラクター対応 + SpineSettingsPersistence統合）
        handleScaleChange(data) {
          const integration = window.nezumiIntegration;
          if (!integration || !integration.selectedCharacter) {
            this.log('⚠️ 選択されたキャラクターがありません');
            return;
          }

          const character = integration.characters[integration.selectedCharacter];
          if (character && character.loaded && character.renderer && character.renderer.skeleton) {
            character.renderer.setTransform(null, null, data.scaleX, data.scaleY);
            
            // BBフィードバックを送信
            integration.sendBBFeedback('scale');
            
            // 💾 SpineSettingsPersistenceでスケール設定保存
            this.saveScaleSettings(integration.selectedCharacter, data.scaleX, data.scaleY);
            
            this.log(`📏 ${integration.selectedCharacter} スケール変更: X=${data.scaleX}, Y=${data.scaleY}`);
          } else {
            this.log('⚠️ 選択されたキャラクターが読み込まれていません');
          }
        }

        handleScaleReset(data) {
          this.handleScaleChange(data);
          this.log('🔄 スケールを理想比率にリセット');
        }

        // handleNaturalRatio機能は削除済み
        
        // 🎯 SpineSettingsPersistence統合保存メソッド
        
        // Canvas解像度設定を保存
        saveCanvasSettings(characterId, canvasSize) {
          try {
            const integration = window.nezumiIntegration;
            if (!integration || !integration.settingsPersistence) {
              this.log('❌ SpineSettingsPersistenceが利用できません');
              return;
            }
            
            // 現在の設定を取得
            const existingSettings = integration.settingsPersistence.restore(characterId) || {};
            
            // Canvas解像度を更新
            const updatedSettings = {
              ...existingSettings,
              canvasSize: canvasSize
            };
            
            // 保存実行
            const success = integration.settingsPersistence.save(characterId, updatedSettings);
            if (success) {
              this.log(`💾 ${characterId} Canvas設定保存成功: ${canvasSize}x${canvasSize}`);
            } else {
              this.log(`❌ ${characterId} Canvas設定保存失敗`);
            }
          } catch (error) {
            this.log(`❌ Canvas設定保存エラー: ${error.message}`);
          }
        }
        
        // スケール設定を保存
        saveScaleSettings(characterId, scaleX, scaleY) {
          try {
            const integration = window.nezumiIntegration;
            if (!integration || !integration.settingsPersistence) {
              this.log('❌ SpineSettingsPersistenceが利用できません');
              return;
            }
            
            // 現在の設定を取得
            const existingSettings = integration.settingsPersistence.restore(characterId) || {};
            
            // スケール設定を更新
            const updatedSettings = {
              ...existingSettings,
              scaleX: scaleX,
              scaleY: scaleY
            };
            
            // 保存実行
            const success = integration.settingsPersistence.save(characterId, updatedSettings);
            if (success) {
              this.log(`💾 ${characterId} スケール設定保存成功: X=${scaleX}, Y=${scaleY}`);
            } else {
              this.log(`❌ ${characterId} スケール設定保存失敗`);
            }
          } catch (error) {
            this.log(`❌ スケール設定保存エラー: ${error.message}`);
          }
        }

        // 位置設定を保存
        savePositionSettings(characterId, positionX, positionY) {
          try {
            const integration = window.nezumiIntegration;
            if (!integration || !integration.settingsPersistence) {
              this.log('❌ SpineSettingsPersistenceが利用できません');
              return;
            }
            
            // 現在の設定を取得
            const existingSettings = integration.settingsPersistence.restore(characterId) || {};
            
            // 位置設定を更新
            const updatedSettings = {
              ...existingSettings,
              positionX: positionX,
              positionY: positionY
            };
            
            // 保存実行
            const success = integration.settingsPersistence.save(characterId, updatedSettings);
            if (success) {
              this.log(`💾 ${characterId} 位置設定保存成功: X=${positionX}, Y=${positionY}`);
            } else {
              this.log(`❌ ${characterId} 位置設定保存失敗`);
            }
          } catch (error) {
            this.log(`❌ 位置設定保存エラー: ${error.message}`);
          }
        }

        // 位置制御（複数キャラクター対応）
        handlePositionChange(data) {
          const integration = window.nezumiIntegration;
          if (!integration || !integration.selectedCharacter) {
            this.log('⚠️ 選択されたキャラクターがありません');
            return;
          }

          const character = integration.characters[integration.selectedCharacter];
          if (character && character.loaded && character.renderer && character.renderer.skeleton) {
            character.renderer.setTransform(data.x, data.y, null, null);
            
            // BBフィードバックを送信
            integration.sendBBFeedback('position');
            
            // 💾 SpineSettingsPersistenceで位置設定保存
            this.savePositionSettings(integration.selectedCharacter, data.x, data.y);
            
            this.log(`📍 ${integration.selectedCharacter} 位置変更: X=${data.x}, Y=${data.y}`);
          } else {
            this.log('⚠️ 選択されたキャラクターが読み込まれていません');
          }
        }

        // handlePositionReset機能は削除済み（centerCharacterと重複のため）

        handleCenterCharacter(data) {
          this.handlePositionChange(data);
          this.log('🎯 キャラクターを中央に配置');
        }

        // 削除済み機能のハンドラー
        // handleDetectBounds, handleApplyOptimal, handleTestMedium は削除
        
        // 🔧 デバッグ機能をメインHTMLに移動
        handleDebugInfo() {
          const integration = window.nezumiIntegration;
          console.log('🔍 デバッグ情報:');
          console.log('Canvas:', integration.canvas);
          console.log('SpineRenderer:', integration.spineRenderer);
          console.log('Skeleton:', integration.spineRenderer?.skeleton);
          if (integration.spineRenderer?.skeleton) {
            const skeleton = integration.spineRenderer.skeleton;
            console.log(`位置: x=${skeleton.x}, y=${skeleton.y}`);
            console.log(`スケール: scaleX=${skeleton.scaleX}, scaleY=${skeleton.scaleY}`);
          }
          this.log('🔍 デバッグ情報をコンソールに出力');
        }

        handleClearLog() {
          const logPanel = document.getElementById('log-panel');
          if (logPanel) {
            logPanel.innerHTML = '<div style="color: #ffd700; margin-bottom: 10px">📝 システムログ</div>';
          }
          console.clear();
          this.log('🗑️ ログクリア完了');
        }

        // UI管理
        handleUIReady(data) {
          this.log('✅ iframe UI 初期化完了');
          
          // 初期状態を iframe に送信
          this.syncUIState();
        }

        handleUILog(data) {
          // iframe からのログを統合
          this.log(`[iframe] ${data.message}`);
        }

        // iframe に状態を同期
        syncUIState() {
          if (!this.iframeLoaded || !this.iframe) return;

          const integration = window.nezumiIntegration;
          if (!integration) return;

          const state = {
            canvasSize: integration.canvas ? Math.min(integration.canvas.width, integration.canvas.height) : 800,
            scaleX: integration.spineRenderer?.skeleton?.scaleX || 1.35,
            scaleY: integration.spineRenderer?.skeleton?.scaleY || 1.0,
            positionX: integration.spineRenderer?.skeleton?.x || 0,
            positionY: integration.spineRenderer?.skeleton?.y || 0
          };

          this.sendToIframe('updateUIState', state);
        }

        // iframe にメッセージ送信
        sendToIframe(type, data) {
          this.log(`📤 iframe送信試行: ${type} - iframeLoaded: ${this.iframeLoaded}`);
          if (this.iframeLoaded && this.iframe) {
            this.iframe.contentWindow.postMessage({
              type: type,
              data: data,
              timestamp: Date.now(),
              source: 'MainPage'
            }, '*');
            this.log(`📤 iframe送信完了: ${type}`);
          } else {
            // iframe未準備の場合、キューに追加
            this.messageQueue.push({ type: type, data: data });
            this.log(`🔄 iframe送信キュー追加: ${type} - 現在のキューサイズ: ${this.messageQueue.length}`);
          }
        }

        processQueuedMessages() {
          this.log(`🚀 キューに入ったメッセージを処理開始 - キューサイズ: ${this.messageQueue.length}`);
          while (this.messageQueue.length > 0) {
            const message = this.messageQueue.shift();
            this.log(`📤 キューからメッセージ送信: ${message.type}`);
            this.sendToIframe(message.type, message.data);
          }
          this.log('✅ キューに入ったメッセージの処理完了');
        }

        // BBフィードバック送信
        sendBBFeedback(type) {
          this.sendToIframe('showBBFeedback', { type: type });
        }

        log(message) {
          if (window.nezumiIntegration && window.nezumiIntegration.log) {
            window.nezumiIntegration.log(message);
          } else {
            console.log(`[CanvasResizeHandler] ${message}`);
          }
        }
      }

      // グローバルハンドラーを初期化
      window.canvasResizeHandler = new CanvasResizeIframeHandler();

      // 🚀 システム起動
      window.addEventListener("load", async () => {
        // ライブラリ読み込み待機
        await new Promise((resolve) => setTimeout(resolve, 500));

        console.log(
          "🎯 Nezumi + StableSpineRenderer + BoundingBox 統合システム起動"
        );

        // システム初期化
        window.multiCharacterSystem = new MultiCharacterStableSpineBBIntegration();
        
        // 後方互換性のために従来名も設定
        window.nezumiIntegration = window.multiCharacterSystem;

        // デバッグ用グローバル関数
        window.debugNezumiSystem = () => {
          if (window.nezumiIntegration) {
            window.nezumiIntegration.showDebugInfo();
          }
        };

        // 🔧 デバッグボタンのイベントハンドラーを設定
        const debugInfoBtn = document.getElementById('debug-info-btn');
        const clearLogBtn = document.getElementById('clear-log-btn');
        const consoleDebugBtn = document.getElementById('console-debug');

        if (debugInfoBtn) {
          debugInfoBtn.onclick = () => {
            if (window.canvasResizeHandler) {
              window.canvasResizeHandler.handleDebugInfo();
            }
          };
        }

        if (clearLogBtn) {
          clearLogBtn.onclick = () => {
            if (window.canvasResizeHandler) {
              window.canvasResizeHandler.handleClearLog();
            }
          };
        }

        if (consoleDebugBtn) {
          consoleDebugBtn.onclick = () => {
            console.log('🖥️ システム状態:');
            console.log('- nezumiIntegration:', window.nezumiIntegration);
            console.log('- canvasResizeHandler:', window.canvasResizeHandler);
            if (window.nezumiIntegration) {
              const integration = window.nezumiIntegration;
              console.log('- canvas:', integration.canvas);
              console.log('- spineRenderer:', integration.spineRenderer);
              console.log('- boundingBox:', integration.boundingBox);
              if (integration.spineRenderer?.skeleton) {
                console.log('- skeleton position:', {
                  x: integration.spineRenderer.skeleton.x,
                  y: integration.spineRenderer.skeleton.y
                });
                console.log('- skeleton scale:', {
                  x: integration.spineRenderer.skeleton.scaleX,
                  y: integration.spineRenderer.skeleton.scaleY
                });
              }
            }
            if (window.canvasResizeHandler) {
              window.canvasResizeHandler.log('🖥️ コンソールログ出力完了');
            }
          };
        }
      });
    </script>
    
    <!-- 🎯 SpineSettingsPersistence マイクロモジュール統合 -->
    <script src="micromodules/spine-settings-persistence/SpineSettingsPersistence.js"></script>
    
  </body>
</html>
