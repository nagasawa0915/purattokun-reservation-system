<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ§ª ãƒã‚¤ã‚¯ãƒ­ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®Ÿé¨“ç‰ˆ - Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼</title>
    <style>
        /* åŸºæœ¬ãƒªã‚»ãƒƒãƒˆ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #f0f0f0;
            font-family: Arial, sans-serif;
        }

        /* ğŸ”‘ é‡è¦ï¼šã‚·ãƒ¼ãƒ³ã‚³ãƒ³ãƒ†ãƒŠï¼ˆãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–åŸºæº–ï¼‰ */
        .scene-container {
            position: relative;           /* å­è¦ç´ ã®çµ¶å¯¾ä½ç½®åŸºæº– */
            width: 100%;                 /* ç”»é¢å¹…ã«åˆã‚ã›ã‚‹ */
            max-width: 1200px;           /* æœ€å¤§å¹…åˆ¶é™ */
            margin: 0 auto;              /* ä¸­å¤®å¯„ã› */
            background: white;           
            border-radius: 10px;         
            overflow: hidden;            /* ã¯ã¿å‡ºã—é˜²æ­¢ */
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        /* ğŸ¯ é‡è¦ï¼šèƒŒæ™¯ç”»åƒï¼ˆåŸºæº–ã¨ãªã‚‹è¦ç´ ï¼‰ */
        .background-image {
            width: 100%;                 /* ã‚³ãƒ³ãƒ†ãƒŠå¹…ã«åˆã‚ã›ã‚‹ */
            height: auto;                /* ç¸¦æ¨ªæ¯”ç¶­æŒ */
            display: block;              /* inlineè¦ç´ ã®éš™é–“é™¤å» */
        }

        /* ğŸ® é‡è¦ï¼šSpineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”¨Canvasï¼ˆã·ã‚‰ã£ã¨ãã‚“ï¼‰ */
        #purattokun-canvas {
            position: absolute;          /* èƒŒæ™¯ç”»åƒä¸Šã«é‡ã­ã‚‹ */
            left: 35%;                   /* èƒŒæ™¯ç”»åƒåŸºæº–ã®ä½ç½®ï¼ˆèª¿æ•´å¯èƒ½ï¼‰ */
            top: 75%;                    /* èƒŒæ™¯ç”»åƒåŸºæº–ã®ä½ç½®ï¼ˆèª¿æ•´å¯èƒ½ï¼‰ */
            transform: translate(-50%, -50%); /* ä¸­å¤®å¯„ã› */
            width: 25%;                  /* ğŸ”‘ èƒŒæ™¯ç”»åƒã¨åŒã˜æ¯”ä¾‹æ‹¡ç¸® */
            aspect-ratio: 3/2;           /* ğŸ”‘ ç¸¦æ¨ªæ¯”å›ºå®šï¼ˆæ½°ã‚Œé˜²æ­¢ï¼‰ */
            z-index: 10;                 /* å‰é¢è¡¨ç¤º */
            display: none;               /* åˆæœŸã¯éè¡¨ç¤ºï¼ˆJSèª­ã¿è¾¼ã¿å¾Œã«è¡¨ç¤ºï¼‰ */
            cursor: pointer;             /* ã‚¯ãƒªãƒƒã‚¯å¯èƒ½è¡¨ç¤º */
        }

        /* ğŸ® é‡è¦ï¼šSpineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”¨Canvasï¼ˆã­ãšã¿ï¼‰ */
        #nezumi-canvas {
            position: absolute;
            left: 60%;
            top: 45%;
            transform: translate(-50%, -50%);
            width: 20%;
            aspect-ratio: 3/2;
            z-index: 11;
            display: none;
            cursor: pointer;
        }

        /* ğŸ’« ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”»åƒï¼ˆã·ã‚‰ã£ã¨ãã‚“ï¼‰ */
        #purattokun-fallback {
            position: absolute;          /* Canvasä½ç½®ã¨åŒæœŸ */
            left: 35%;                   /* Canvasã¨åŒã˜ä½ç½® */
            top: 75%;                    /* Canvasã¨åŒã˜ä½ç½® */
            transform: translate(-50%, -50%);
            width: 10%;                  /* ğŸ”‘ èƒŒæ™¯ç”»åƒã¨åŒã˜æ¯”ä¾‹æ‹¡ç¸® */
            aspect-ratio: 1/1;           /* æ­£æ–¹å½¢ç¶­æŒ */
            object-fit: contain;         /* ç”»åƒæ¯”ç‡ç¶­æŒ */
            z-index: 10;
            display: block;              /* åˆæœŸè¡¨ç¤ºï¼ˆSpineæˆåŠŸæ™‚ã«éè¡¨ç¤ºåŒ–ï¼‰ */
            cursor: pointer;
        }

        /* ğŸ’« ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”»åƒï¼ˆã­ãšã¿ï¼‰ */
        #nezumi-fallback {
            position: absolute;
            left: 60%;
            top: 45%;
            transform: translate(-50%, -50%);
            width: 8%;
            aspect-ratio: 1/1;
            object-fit: contain;
            z-index: 11;
            display: block;
            cursor: pointer;
        }

        /* ğŸ§ª å®Ÿé¨“ç”¨ãƒ‡ãƒãƒƒã‚°ãƒ‘ãƒãƒ« */
        .debug-panel {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-width: 300px;
            z-index: 1000;
        }

        .debug-panel h3 {
            margin-bottom: 10px;
            color: #4CAF50;
        }

        .debug-panel .status {
            margin: 5px 0;
        }

        .debug-panel .success { color: #4CAF50; }
        .debug-panel .error { color: #f44336; }
        .debug-panel .warning { color: #ff9800; }
    </style>
</head>
<body>
    <div class="scene-container">
        <!-- èƒŒæ™¯ç”»åƒï¼ˆåŸºæº–ã¨ãªã‚‹è¦ç´ ï¼‰ -->
        <img src="assets/images/ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼TOP.png" alt="èƒŒæ™¯" class="background-image">
        
        <!-- Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ï¼ˆã·ã‚‰ã£ã¨ãã‚“ï¼‰ -->
        <canvas id="purattokun-canvas" width="300" height="200" data-spine-character="true" data-character-name="purattokun"></canvas>
        
        <!-- Spineã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ï¼ˆã­ãšã¿ï¼‰ -->
        <canvas id="nezumi-canvas" width="300" height="200" data-spine-character="true" data-character-name="nezumi"></canvas>
        
        <!-- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”»åƒï¼ˆã·ã‚‰ã£ã¨ãã‚“ï¼‰ -->
        <img src="assets/images/purattokunn.png" alt="ã·ã‚‰ã£ã¨ãã‚“" id="purattokun-fallback" data-spine-character="true" data-character-name="purattokun">
        
        <!-- ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”»åƒï¼ˆã­ãšã¿ï¼‰ -->
        <img src="assets/images/nezumi.png" alt="ã­ãšã¿" id="nezumi-fallback" data-spine-character="true" data-character-name="nezumi">
    </div>

    <!-- ğŸ§ª å®Ÿé¨“ç”¨ãƒ‡ãƒãƒƒã‚°ãƒ‘ãƒãƒ« -->
    <div class="debug-panel">
        <h3>ğŸ§ª ãƒã‚¤ã‚¯ãƒ­ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®Ÿé¨“</h3>
        <div id="debug-status"></div>
        <div style="margin-top: 10px; font-size: 10px;">
            F12ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§è©³ç´°ç¢ºèªå¯èƒ½
        </div>
    </div>

    <!-- Spine WebGL Runtime -->
    <script src="https://unpkg.com/@esotericsoftware/spine-webgl@4.1.24/dist/iife/spine-webgl.js"></script>
    
    <!-- ğŸ§ª ãƒã‚¤ã‚¯ãƒ­ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç¾¤ v2.0 -->
    <!-- Type A: åŸºç¤ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« -->
    <script src="micromodules/core/PurePositionManager.js"></script>
    
    <!-- Type B: æ©Ÿèƒ½ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« -->
    <script src="micromodules/features/PureSpineEditor.js"></script>
    
    <!-- v1.0å®Ÿé¨“ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆå‚è€ƒç”¨ï¼‰ -->
    <script src="micromodules/experimental/PureSpineLoader.js"></script>
    <script src="micromodules/experimental/PureBoundingBox.js"></script>
    
    <script>
        // ğŸ¯ ãƒã‚¤ã‚¯ãƒ­ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®Ÿé¨“ã‚·ã‚¹ãƒ†ãƒ 
        const debugStatus = document.getElementById('debug-status');
        const spineCharacters = {};
        
        function updateDebugStatus(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : '';
            
            const statusDiv = document.createElement('div');
            statusDiv.className = `status ${className}`;
            statusDiv.innerHTML = `[${timestamp.split(':').slice(0,2).join(':')}] ${message}`;
            
            debugStatus.appendChild(statusDiv);
            
            // æœ€å¤§10è¡Œã¾ã§è¡¨ç¤º
            while (debugStatus.children.length > 10) {
                debugStatus.removeChild(debugStatus.firstChild);
            }
            
            console.log(`[MICRO] ${message}`);
        }

        // ğŸ¯ å¾“æ¥ã®åˆæœŸåŒ–é–¢æ•°ï¼ˆæ¯”è¼ƒç”¨ï¼‰
        async function initTraditionalCharacter(config) {
            try {
                updateDebugStatus(`ğŸ”„ å¾“æ¥æ–¹å¼: ${config.id} åˆæœŸåŒ–é–‹å§‹`, 'info');
                
                const canvas = document.getElementById(config.canvasId);
                const fallback = document.getElementById(config.fallbackId);
                
                if (!canvas || !fallback) {
                    throw new Error(`è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${config.canvasId} ã¾ãŸã¯ ${config.fallbackId}`);
                }

                const gl = canvas.getContext("webgl", { alpha: true });
                if (!gl) {
                    throw new Error("WebGLæœªå¯¾å¿œ");
                }

                // Spine WebGLã®èª­ã¿è¾¼ã¿å¾…ã¡
                await waitForSpine();

                // ã‚¢ã‚»ãƒƒãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
                const assetManager = new spine.AssetManager(gl, config.basePath);
                assetManager.loadTextureAtlas(config.atlasFile);
                assetManager.loadJson(config.jsonFile);

                await waitForAssets(assetManager);

                // Spineã‚¹ã‚±ãƒ«ãƒˆãƒ³æ§‹ç¯‰
                const atlas = assetManager.get(config.atlasFile);
                const atlasLoader = new spine.AtlasAttachmentLoader(atlas);
                const skeletonJson = new spine.SkeletonJson(atlasLoader);
                const skeletonData = skeletonJson.readSkeletonData(
                    assetManager.get(config.jsonFile)
                );

                const skeleton = new spine.Skeleton(skeletonData);
                
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä½ç½®è¨­å®š
                skeleton.x = 0;
                skeleton.y = config.positionY;
                skeleton.scaleX = skeleton.scaleY = config.scale;

                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
                const animationStateData = new spine.AnimationStateData(skeleton.data);
                const animationState = new spine.AnimationState(animationStateData);

                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
                startDefaultAnimation(animationState, skeleton, config.id);

                // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼
                const renderer = new spine.SceneRenderer(canvas, gl);

                // æç”»ãƒ«ãƒ¼ãƒ—
                let lastTime = Date.now() / 1000;
                function render() {
                    const now = Date.now() / 1000;
                    const delta = now - lastTime;
                    lastTime = now;

                    animationState.update(delta);
                    animationState.apply(skeleton);
                    skeleton.updateWorldTransform();

                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.viewport(0, 0, canvas.width, canvas.height);

                    renderer.begin();
                    renderer.drawSkeleton(skeleton, true);
                    renderer.end();

                    requestAnimationFrame(render);
                }
                render();

                // æˆåŠŸæ™‚ï¼šCanvasè¡¨ç¤ºã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯éè¡¨ç¤º
                canvas.style.display = "block";
                fallback.style.display = "none";

                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æƒ…å ±ã‚’ä¿å­˜
                spineCharacters[config.id] = {
                    canvas, fallback, skeleton, animationState, renderer, config,
                    animations: skeleton.data.animations.map(anim => anim.name),
                    loadMethod: 'traditional'
                };

                updateDebugStatus(`âœ… å¾“æ¥æ–¹å¼: ${config.id} æˆåŠŸ`, 'success');

            } catch (error) {
                updateDebugStatus(`âŒ å¾“æ¥æ–¹å¼: ${config.id} å¤±æ•— - ${error.message}`, 'error');
                console.error(`å¾“æ¥æ–¹å¼ ${config.id} åˆæœŸåŒ–å¤±æ•—:`, error);
            }
        }

        // ğŸ§ª PureSpineLoader ã‚’ä½¿ã£ãŸåˆæœŸåŒ–é–¢æ•°ï¼ˆå®Ÿé¨“ç”¨ãƒ»WebGLçµ±ä¸€å¯¾å¿œï¼‰
        async function initMicroModuleCharacter(config) {
            try {
                updateDebugStatus(`ğŸ§ª ãƒã‚¤ã‚¯ãƒ­æ–¹å¼: ${config.id} åˆæœŸåŒ–é–‹å§‹`, 'info');
                
                const canvas = document.getElementById(config.canvasId);
                const fallback = document.getElementById(config.fallbackId);
                
                if (!canvas || !fallback) {
                    throw new Error(`è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${config.canvasId} ã¾ãŸã¯ ${config.fallbackId}`);
                }

                // ğŸ”— WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å…ˆã«ä½œæˆï¼ˆé‡è¦ï¼šPureSpineLoaderã¨å…±æœ‰ï¼‰
                const gl = canvas.getContext("webgl", { alpha: true });
                if (!gl) {
                    throw new Error("WebGLæœªå¯¾å¿œ");
                }
                updateDebugStatus(`ğŸ”— ${config.id}: WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä½œæˆå®Œäº†`, 'info');

                // ğŸ§ª PureSpineLoader ãƒã‚¤ã‚¯ãƒ­ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ä½¿ç”¨
                const loaderConfig = {
                    basePath: config.basePath,
                    atlasPath: config.atlasFile,
                    jsonPath: config.jsonFile,
                    scale: config.scale
                };

                updateDebugStatus(`ğŸ”§ ${config.id}: PureSpineLoader ä½œæˆ`, 'info');
                const loader = new PureSpineLoader(loaderConfig);
                
                updateDebugStatus(`ğŸ“¥ ${config.id}: execute() with WebGLçµ±ä¸€å®Ÿè¡Œä¸­...`, 'info');
                const loadResult = await loader.execute(gl);  // ğŸ”‘ WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æ¸¡ã™
                
                if (!loadResult.loaded) {
                    throw new Error(`PureSpineLoaderèª­ã¿è¾¼ã¿å¤±æ•—: ${loadResult.error}`);
                }

                updateDebugStatus(`ğŸ“¦ ${config.id}: Spineãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ (WebGL: ${loadResult.spineData.usedExternalGL ? 'çµ±ä¸€' : 'åˆ†é›¢'})`, 'success');
                
                // PureSpineLoaderã‹ã‚‰å–å¾—ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
                const spineData = loadResult.spineData;
                const skeleton = spineData.skeleton;
                const animationState = new spine.AnimationState(spineData.animationStateData);

                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä½ç½®è¨­å®šï¼ˆPureSpineLoaderã§è¨­å®šã•ã‚ŒãŸscaleã¯ä¿æŒï¼‰
                skeleton.x = 0;
                skeleton.y = config.positionY;

                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
                startDefaultAnimation(animationState, skeleton, config.id);

                // WebGLãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ï¼ˆåŒã˜WebGLã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä½¿ç”¨ï¼‰
                const renderer = new spine.SceneRenderer(canvas, gl);

                // æç”»ãƒ«ãƒ¼ãƒ—
                let lastTime = Date.now() / 1000;
                function render() {
                    const now = Date.now() / 1000;
                    const delta = now - lastTime;
                    lastTime = now;

                    animationState.update(delta);
                    animationState.apply(skeleton);
                    skeleton.updateWorldTransform();

                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.viewport(0, 0, canvas.width, canvas.height);

                    renderer.begin();
                    renderer.drawSkeleton(skeleton, true);
                    renderer.end();

                    requestAnimationFrame(render);
                }
                render();

                // æˆåŠŸæ™‚ï¼šCanvasè¡¨ç¤ºã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯éè¡¨ç¤º
                canvas.style.display = "block";
                fallback.style.display = "none";

                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æƒ…å ±ã‚’ä¿å­˜
                spineCharacters[config.id] = {
                    canvas, fallback, skeleton, animationState, renderer, config,
                    animations: spineData.animations,
                    loadMethod: 'micromodule',
                    loader: loader,  // ğŸ§ª å¾Œã§cleanup()ã™ã‚‹ãŸã‚ä¿æŒ
                    loadStats: {
                        animationCount: spineData.animationCount,
                        slotCount: spineData.slotCount
                    }
                };

                updateDebugStatus(`âœ… ãƒã‚¤ã‚¯ãƒ­æ–¹å¼: ${config.id} æˆåŠŸ (${spineData.animationCount}ã‚¢ãƒ‹ãƒ¡)`, 'success');

            } catch (error) {
                updateDebugStatus(`âŒ ãƒã‚¤ã‚¯ãƒ­æ–¹å¼: ${config.id} å¤±æ•— - ${error.message}`, 'error');
                console.error(`ãƒã‚¤ã‚¯ãƒ­æ–¹å¼ ${config.id} åˆæœŸåŒ–å¤±æ•—:`, error);
            }
        }

        // ğŸ¯ ãƒ¡ã‚¤ãƒ³åˆæœŸåŒ–é–¢æ•°
        async function initSpineCharacters() {
            updateDebugStatus('ğŸš€ ãƒã‚¤ã‚¯ãƒ­ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®Ÿé¨“é–‹å§‹', 'success');
            
            // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¨­å®š
            const characterConfigs = [
                {
                    id: 'purattokun',
                    canvasId: 'purattokun-canvas',
                    fallbackId: 'purattokun-fallback',
                    basePath: './assets/spine/characters/purattokun/',
                    atlasFile: 'purattokun.atlas',
                    jsonFile: 'purattokun.json',
                    scale: 0.55,
                    positionY: -100
                },
                {
                    id: 'nezumi',
                    canvasId: 'nezumi-canvas',
                    fallbackId: 'nezumi-fallback',
                    basePath: './assets/spine/characters/nezumi/',
                    atlasFile: 'nezumi.atlas',
                    jsonFile: 'nezumi.json',
                    scale: 0.45,
                    positionY: -80
                }
            ];

            try {
                // ğŸ§ª å®Ÿé¨“ï¼špurattokun ã¯ãƒã‚¤ã‚¯ãƒ­ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã€nezumi ã¯å¾“æ¥æ–¹å¼
                updateDebugStatus('ğŸ“‹ å®Ÿé¨“è¨­å®š: purattokun=ãƒã‚¤ã‚¯ãƒ­, nezumi=å¾“æ¥', 'info');
                
                // ä¸¦åˆ—åˆæœŸåŒ–
                await Promise.all([
                    initMicroModuleCharacter(characterConfigs[0]),    // purattokun
                    initTraditionalCharacter(characterConfigs[1])     // nezumi
                ]);
                
                updateDebugStatus('ğŸ¯ ä¸¡æ–¹å¼æ¯”è¼ƒå®Œäº†', 'success');
                updateDebugStatus(`ğŸ“Š æˆåŠŸã‚­ãƒ£ãƒ©æ•°: ${Object.keys(spineCharacters).length}/2`, 'info');
                
                // çµæœæ¯”è¼ƒ
                for (const [id, character] of Object.entries(spineCharacters)) {
                    const method = character.loadMethod;
                    const stats = character.loadStats || {};
                    updateDebugStatus(`ğŸ“ˆ ${id}: ${method} (${character.animations.length}ã‚¢ãƒ‹ãƒ¡)`, 'info');
                }
                
                // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°è¿½åŠ ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
                window.microExperiment = {
                    characters: spineCharacters,
                    cleanupMicroModule: (characterId) => {
                        const character = spineCharacters[characterId];
                        if (character && character.loader && character.loader.cleanup) {
                            const result = character.loader.cleanup();
                            updateDebugStatus(`ğŸ§¹ ${characterId} cleanup: ${result}`, result ? 'success' : 'error');
                            return result;
                        }
                        return false;
                    },
                    testPureMicroModule: () => {
                        return PureSpineLoader.test();
                    },
                    // ğŸ§ª PurePositionManagerå®Ÿé¨“æ©Ÿèƒ½
                    testPositionManager: () => {
                        updateDebugStatus('ğŸ“ PurePositionManager ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                        return PurePositionManager.test();
                    },
                    createPositionManager: (containerWidth = 800, containerHeight = 600) => {
                        const manager = new PurePositionManager({
                            containerWidth,
                            containerHeight,
                            scale: 1.0,
                            offsetX: 0,
                            offsetY: 0
                        });
                        updateDebugStatus(`ğŸ“ PurePositionManager ä½œæˆ (${containerWidth}x${containerHeight})`, 'success');
                        return manager;
                    },
                    calculatePosition: (x, y, scale = 1.0) => {
                        const manager = window.microExperiment.createPositionManager();
                        const result = manager.execute({ x, y });
                        updateDebugStatus(`ğŸ“Š åº§æ¨™è¨ˆç®—: (${x},${y}) â†’ å®Œäº†`, 'info');
                        console.log('Position calculation result:', result);
                        return result;
                    },
                    // ğŸ§ª PureBoundingBoxå®Ÿé¨“æ©Ÿèƒ½
                    testBoundingBox: (characterId = 'purattokun') => {
                        updateDebugStatus('ğŸ“¦ PureBoundingBox ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                        const character = spineCharacters[characterId];
                        if (!character) {
                            updateDebugStatus(`âŒ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ ${characterId} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`, 'error');
                            return null;
                        }
                        
                        const canvas = character.canvas;
                        const spineData = {
                            skeleton: character.skeleton,
                            bounds: {x: 0, y: 0, width: canvas.width, height: canvas.height}
                        };
                        const position = {
                            x: canvas.offsetLeft,
                            y: canvas.offsetTop,
                            width: canvas.offsetWidth,
                            height: canvas.offsetHeight
                        };
                        
                        try {
                            const boundingBox = new PureBoundingBox({
                                canvasElement: canvas,
                                spineData: spineData,
                                position: position
                            });
                            
                            boundingBox.execute({visible: true}).then(result => {
                                updateDebugStatus(`âœ… PureBoundingBox: ${characterId} è¡¨ç¤ºæˆåŠŸ`, 'success');
                                console.log('PureBoundingBox result:', result);
                                
                                // 10ç§’å¾Œã«è‡ªå‹•ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                                setTimeout(() => {
                                    boundingBox.cleanup();
                                    updateDebugStatus(`ğŸ§¹ PureBoundingBox: ${characterId} è‡ªå‹•ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—`, 'info');
                                }, 10000);
                            });
                            
                            return boundingBox;
                        } catch (error) {
                            updateDebugStatus(`âŒ PureBoundingBox: ${error.message}`, 'error');
                            return null;
                        }
                    },
                    // PureBoundingBoxå˜ç‹¬ãƒ†ã‚¹ãƒˆ
                    testPureBoundingBox: () => {
                        return PureBoundingBox.test();
                    },
                    
                    // ğŸ¯ PureSpineEditorå®Ÿé¨“æ©Ÿèƒ½ï¼ˆv2.0çµ±åˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰
                    testSpineEditor: (characterId = 'purattokun') => {
                        updateDebugStatus('ğŸ¯ PureSpineEditor ãƒ†ã‚¹ãƒˆé–‹å§‹', 'info');
                        
                        const character = spineCharacters[characterId];
                        if (!character) {
                            updateDebugStatus(`âŒ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ ${characterId} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`, 'error');
                            return null;
                        }
                        
                        const config = {
                            basePath: character.config.basePath,
                            atlasPath: character.config.atlasFile,
                            jsonPath: character.config.jsonFile,
                            canvasElement: character.canvas,
                            initialPosition: {x: 0, y: 0}, // ä¸­å¤®åŸºæº–ã§ã®ç›¸å¯¾ä½ç½®
                            initialScale: 0.8,
                            showBoundingBox: true,
                            defaultAnimation: character.config.id === 'purattokun' ? 'taiki' : 'search'
                        };
                        
                        try {
                            const spineEditor = new PureSpineEditor(config);
                            
                            spineEditor.loadSpine().then(result => {
                                if (result.success) {
                                    updateDebugStatus(`âœ… PureSpineEditor: ${characterId} èª­ã¿è¾¼ã¿æˆåŠŸ`, 'success');
                                    
                                    // 2ç§’å¾Œã«ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹è¡¨ç¤º
                                    setTimeout(() => {
                                        if (spineEditor.showBoundingBox()) {
                                            updateDebugStatus(`ğŸ“¦ PureSpineEditor: ${characterId} ç·¨é›†ãƒ¢ãƒ¼ãƒ‰é–‹å§‹`, 'success');
                                        }
                                    }, 2000);
                                    
                                    // 15ç§’å¾Œã«è‡ªå‹•ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                                    setTimeout(() => {
                                        spineEditor.cleanup();
                                        updateDebugStatus(`ğŸ§¹ PureSpineEditor: ${characterId} è‡ªå‹•ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—`, 'info');
                                    }, 15000);
                                    
                                } else {
                                    updateDebugStatus(`âŒ PureSpineEditor: ${result.error}`, 'error');
                                }
                            });
                            
                            return spineEditor;
                            
                        } catch (error) {
                            updateDebugStatus(`âŒ PureSpineEditor: ${error.message}`, 'error');
                            return null;
                        }
                    },
                    
                    // PureSpineEditorå˜ç‹¬ãƒ†ã‚¹ãƒˆ
                    testPureSpineEditor: () => {
                        updateDebugStatus('ğŸ§ª PureSpineEditor å˜ç‹¬ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ', 'info');
                        return PureSpineEditor.test();
                    }
                };

            } catch (error) {
                updateDebugStatus(`âŒ åˆæœŸåŒ–å…¨ä½“å¤±æ•—: ${error.message}`, 'error');
            }
        }

        function startDefaultAnimation(animationState, skeleton, characterId) {
            // ç°¡ç•¥ç‰ˆï¼šåŸºæœ¬çš„ãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
            let defaultAnimation = null;
            
            if (characterId === 'purattokun') {
                if (skeleton.data.findAnimation("taiki")) {
                    defaultAnimation = "taiki";
                }
            } else if (characterId === 'nezumi') {
                if (skeleton.data.findAnimation("search")) {
                    defaultAnimation = "search";
                }
            }
            
            if (defaultAnimation) {
                updateDebugStatus(`ğŸ¬ ${characterId}: ${defaultAnimation} é–‹å§‹`, 'info');
                animationState.setAnimation(0, defaultAnimation, true);
            }
        }

        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        async function waitForSpine() {
            return new Promise((resolve, reject) => {
                let checkCount = 0;
                const maxChecks = 50;

                const checkSpine = () => {
                    checkCount++;
                    if (typeof spine !== "undefined") {
                        resolve();
                    } else if (checkCount >= maxChecks) {
                        reject(new Error("Spine WebGLèª­ã¿è¾¼ã¿ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ"));
                    } else {
                        setTimeout(checkSpine, 100);
                    }
                };

                checkSpine();
            });
        }

        async function waitForAssets(assetManager) {
            return new Promise((resolve, reject) => {
                let checkCount = 0;
                const maxChecks = 50;

                const checkAssets = () => {
                    checkCount++;
                    if (assetManager.isLoadingComplete()) {
                        resolve();
                    } else if (checkCount >= maxChecks) {
                        reject(new Error("ã‚¢ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ"));
                    } else {
                        setTimeout(checkAssets, 100);
                    }
                };

                checkAssets();
            });
        }

        // åˆæœŸåŒ–å®Ÿè¡Œ
        window.addEventListener("load", () => {
            updateDebugStatus('ğŸŒ å®Ÿé¨“ãƒšãƒ¼ã‚¸æº–å‚™å®Œäº†', 'success');
            setTimeout(initSpineCharacters, 500);
        });
    </script>
</body>
</html>