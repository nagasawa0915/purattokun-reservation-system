/**
 * SpineSettingsPersistence „Ç®„É©„Éº„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
 * Phase 3.3Áµ±Âêà„ÉÜ„Çπ„ÉàÁî® - Êßò„ÄÖ„Å™„Ç®„É©„ÉºÁä∂Ê≥Å„ÇíÂÜçÁèæ
 */

class ErrorSimulator {
    
    constructor(options = {}) {
        this.options = {
            debug: options.debug || true,
            restoreOriginals: options.restoreOriginals !== false
        };
        
        this.originalMethods = {};
        this.activeSimulations = new Set();
        
        this.log('üß™ ErrorSimulator initialized');
    }
    
    log(message, level = 'info') {
        if (!this.options.debug) return;
        
        const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
        const prefix = '[ErrorSimulator]';
        
        switch (level) {
            case 'error':
                console.error(`${prefix} ${timestamp} ‚ùå ${message}`);
                break;
            case 'warn':
                console.warn(`${prefix} ${timestamp} ‚ö†Ô∏è ${message}`);
                break;
            default:
                console.log(`${prefix} ${timestamp} üß™ ${message}`);
        }
    }
    
    /**
     * localStorageÂÆπÈáè‰∏çË∂≥„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
     * @param {Object} options „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ë®≠ÂÆö
     * @returns {Function} Âæ©ÂÖÉÈñ¢Êï∞
     */
    simulateStorageQuotaExceeded(options = {}) {
        const {
            triggerOnKey = null, // ÁâπÂÆö„ÅÆ„Ç≠„Éº„Åß„ÅÆ„Åø„Ç®„É©„Éº
            errorMessage = 'QuotaExceededError: DOM Exception 22',
            probability = 1.0 // „Ç®„É©„ÉºÁô∫ÁîüÁ¢∫Áéá
        } = options;
        
        this.log(`Starting localStorage quota exceeded simulation`);
        
        // ÂÖÉ„ÅÆsetItem„Çí‰øùÂ≠ò
        if (!this.originalMethods.setItem) {
            this.originalMethods.setItem = localStorage.setItem.bind(localStorage);
        }
        
        let errorTriggered = false;
        
        localStorage.setItem = (key, value) => {
            // Êù°‰ª∂Âà§ÂÆö
            const shouldTriggerError = 
                (!triggerOnKey || key.includes(triggerOnKey)) &&
                Math.random() <= probability &&
                !errorTriggered;
            
            if (shouldTriggerError) {
                errorTriggered = true;
                this.log(`Triggering quota exceeded error for key: ${key}`, 'warn');
                throw new Error(errorMessage);
            }
            
            return this.originalMethods.setItem(key, value);
        };
        
        this.activeSimulations.add('quotaExceeded');
        
        // Âæ©ÂÖÉÈñ¢Êï∞
        return () => {
            if (this.originalMethods.setItem) {
                localStorage.setItem = this.originalMethods.setItem;
                this.log('localStorage.setItem restored');
            }
            this.activeSimulations.delete('quotaExceeded');
        };
    }
    
    /**
     * localStorageÁÑ°ÂäπÂåñ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºà„Éó„É©„Ç§„Éô„Éº„Éà„É¢„Éº„ÉâÁ≠âÔºâ
     * @returns {Function} Âæ©ÂÖÉÈñ¢Êï∞
     */
    simulateStorageDisabled() {
        this.log('Starting localStorage disabled simulation');
        
        // ÂÖÉ„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„Çí‰øùÂ≠ò
        ['setItem', 'getItem', 'removeItem', 'clear'].forEach(method => {
            if (!this.originalMethods[method]) {
                this.originalMethods[method] = localStorage[method].bind(localStorage);
            }
        });
        
        // ÁÑ°ÂäπÂåñ
        localStorage.setItem = (key, value) => {
            throw new Error('localStorage is not available');
        };
        
        localStorage.getItem = (key) => {
            throw new Error('localStorage is not available');
        };
        
        localStorage.removeItem = (key) => {
            throw new Error('localStorage is not available');
        };
        
        localStorage.clear = () => {
            throw new Error('localStorage is not available');
        };
        
        this.activeSimulations.add('storageDisabled');
        
        // Âæ©ÂÖÉÈñ¢Êï∞
        return () => {
            ['setItem', 'getItem', 'removeItem', 'clear'].forEach(method => {
                if (this.originalMethods[method]) {
                    localStorage[method] = this.originalMethods[method];
                }
            });
            this.log('localStorage methods restored');
            this.activeSimulations.delete('storageDisabled');
        };
    }
    
    /**
     * „Éá„Éº„ÇøÁ†¥Êêç„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
     * @param {string} characterId ÂØæË±°„Ç≠„É£„É©„ÇØ„Çø„ÉºID
     * @param {string} corruptionType Á†¥Êêç„Çø„Ç§„Éó
     * @returns {Object} Á†¥ÊêçÊÉÖÂ†±
     */
    simulateDataCorruption(characterId, corruptionType = 'invalidJson') {
        this.log(`Starting data corruption simulation: ${corruptionType}`);
        
        // „Éö„Éº„Ç∏ID„ÇíÂèñÂæóÔºàSpineSettingsPersistence„Å®ÂêåÊßò„ÅÆÊñπÊ≥ïÔºâ
        let pageId = window.location.pathname;
        if (pageId === '/') pageId = 'index';
        const pathParts = pageId.split('/');
        const fileName = pathParts[pathParts.length - 1];
        pageId = fileName.replace(/\.[^/.]+$/, '') || 'default';
        
        const key = `spineSettings-${pageId}-${characterId}`;
        
        let corruptData;
        switch (corruptionType) {
            case 'invalidJson':
                corruptData = '{invalid-json-data}';
                break;
            case 'emptyString':
                corruptData = '';
                break;
            case 'wrongFormat':
                corruptData = JSON.stringify({ wrongFormat: true });
                break;
            case 'missingFields':
                corruptData = JSON.stringify({
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    characterId: characterId,
                    settings: {} // ÂøÖÈ†à„Éï„Ç£„Éº„É´„Éâ„Å™„Åó
                });
                break;
            case 'nullData':
                corruptData = 'null';
                break;
            case 'arrayInsteadOfObject':
                corruptData = JSON.stringify([1, 2, 3]);
                break;
            default:
                corruptData = '{corrupt}';
        }
        
        // Á†¥Êêç„Éá„Éº„Çø„ÇíË®≠ÂÆö
        localStorage.setItem(key, corruptData);
        
        const corruptionInfo = {
            characterId: characterId,
            key: key,
            corruptionType: corruptionType,
            corruptData: corruptData
        };
        
        this.log(`Data corruption applied: ${key} -> ${corruptionType}`);
        
        return corruptionInfo;
    }
    
    /**
     * JSON.parse/JSON.stringify „Ç®„É©„Éº„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
     * @param {string} method ÂØæË±°„É°„ÇΩ„ÉÉ„Éâ ('parse' or 'stringify')
     * @returns {Function} Âæ©ÂÖÉÈñ¢Êï∞
     */
    simulateJSONError(method = 'parse') {
        this.log(`Starting JSON.${method} error simulation`);
        
        const originalMethod = JSON[method];
        let errorTriggered = false;
        
        JSON[method] = (...args) => {
            // SpineSettingsPersistenceÈñ¢ÈÄ£„ÅÆ„Éá„Éº„Çø„Åß„ÅÆ„Åø„Ç®„É©„Éº„ÇíÁô∫Áîü
            if (method === 'parse' && args[0] && 
                typeof args[0] === 'string' && 
                args[0].includes('spineSettings') && 
                !errorTriggered) {
                errorTriggered = true;
                this.log(`Triggering JSON.${method} error`, 'warn');
                throw new SyntaxError(`Unexpected token in JSON at position 0`);
            }
            
            return originalMethod.apply(JSON, args);
        };
        
        this.activeSimulations.add(`json${method.charAt(0).toUpperCase() + method.slice(1)}`);
        
        // Âæ©ÂÖÉÈñ¢Êï∞
        return () => {
            JSON[method] = originalMethod;
            this.log(`JSON.${method} restored`);
            this.activeSimulations.delete(`json${method.charAt(0).toUpperCase() + method.slice(1)}`);
        };
    }
    
    /**
     * „É©„É≥„ÉÄ„É†„Å™„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÈÅÖÂª∂„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
     * @param {Object} options ÈÅÖÂª∂Ë®≠ÂÆö
     * @returns {Function} Âæ©ÂÖÉÈñ¢Êï∞
     */
    simulateNetworkDelay(options = {}) {
        const {
            minDelay = 100,
            maxDelay = 2000,
            probability = 0.3
        } = options;
        
        this.log(`Starting network delay simulation (${minDelay}-${maxDelay}ms, ${probability * 100}% probability)`);
        
        // localStorageÊìç‰Ωú„ÇíÈùûÂêåÊúüÂåñÔºàÂÆüÈöõ„ÅÆÈÅÖÂª∂„Çí„Ç∑„Éü„É•„É¨„Éº„ÉàÔºâ
        if (!this.originalMethods.getItem) {
            this.originalMethods.getItem = localStorage.getItem.bind(localStorage);
        }
        
        localStorage.getItem = (key) => {
            if (Math.random() <= probability) {
                const delay = minDelay + Math.random() * (maxDelay - minDelay);
                this.log(`Simulating ${delay.toFixed(0)}ms delay for getItem: ${key}`);
                
                // ÂêåÊúüÁöÑ„Å™ÈÅÖÂª∂ÔºàÂÆüÈöõ„ÅÆ„ÉÜ„Çπ„Éà„Åß„ÅØÈùûÊé®Â•®„Å†„Åå„ÄÅ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Áî®Ôºâ
                const start = performance.now();
                while (performance.now() - start < delay) {
                    // Busy wait
                }
            }
            
            return this.originalMethods.getItem(key);
        };
        
        this.activeSimulations.add('networkDelay');
        
        return () => {
            if (this.originalMethods.getItem) {
                localStorage.getItem = this.originalMethods.getItem;
                this.log('localStorage.getItem delay simulation restored');
            }
            this.activeSimulations.delete('networkDelay');
        };
    }
    
    /**
     * „É°„É¢„É™‰∏çË∂≥„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
     * @returns {Function} Âæ©ÂÖÉÈñ¢Êï∞
     */
    simulateMemoryError() {
        this.log('Starting memory error simulation');
        
        if (!this.originalMethods.setItem) {
            this.originalMethods.setItem = localStorage.setItem.bind(localStorage);
        }
        
        let errorTriggered = false;
        
        localStorage.setItem = (key, value) => {
            if (key.includes('spineSettings') && !errorTriggered) {
                errorTriggered = true;
                this.log('Triggering memory error', 'error');
                throw new Error('Cannot allocate memory');
            }
            
            return this.originalMethods.setItem(key, value);
        };
        
        this.activeSimulations.add('memoryError');
        
        return () => {
            if (this.originalMethods.setItem) {
                localStorage.setItem = this.originalMethods.setItem;
                this.log('Memory error simulation restored');
            }
            this.activeSimulations.delete('memoryError');
        };
    }
    
    /**
     * Ë§áÊï∞„ÅÆÈöúÂÆ≥„ÇíÂêåÊôÇ„Å´„Ç∑„Éü„É•„É¨„Éº„Éà
     * @param {string[]} errorTypes „Ç®„É©„Éº„Çø„Ç§„ÉóÈÖçÂàó
     * @returns {Function} ÂÖ®„Å¶Âæ©ÂÖÉ„Åô„ÇãÈñ¢Êï∞
     */
    simulateMultipleErrors(errorTypes = ['quotaExceeded', 'dataCorruption']) {
        this.log(`Starting multiple error simulation: ${errorTypes.join(', ')}`);
        
        const restoreFunctions = [];
        
        errorTypes.forEach(errorType => {
            switch (errorType) {
                case 'quotaExceeded':
                    restoreFunctions.push(this.simulateStorageQuotaExceeded());
                    break;
                case 'dataCorruption':
                    this.simulateDataCorruption('multi-error-test', 'invalidJson');
                    break;
                case 'jsonError':
                    restoreFunctions.push(this.simulateJSONError());
                    break;
                case 'networkDelay':
                    restoreFunctions.push(this.simulateNetworkDelay());
                    break;
                case 'memoryError':
                    restoreFunctions.push(this.simulateMemoryError());
                    break;
                default:
                    this.log(`Unknown error type: ${errorType}`, 'warn');
            }
        });
        
        // ÂÖ®Âæ©ÂÖÉÈñ¢Êï∞
        return () => {
            restoreFunctions.forEach((restoreFn, index) => {
                try {
                    restoreFn();
                } catch (error) {
                    this.log(`Error restoring simulation ${index}: ${error.message}`, 'error');
                }
            });
            this.log('Multiple error simulation restored');
        };
    }
    
    /**
     * „Çπ„Éà„É¨„Çπ„ÉÜ„Çπ„ÉàÁî®„ÅÆÈÄ£Á∂ö„Ç®„É©„Éº
     * @param {number} errorCount „Ç®„É©„ÉºÁô∫ÁîüÂõûÊï∞
     * @param {string} errorType „Ç®„É©„Éº„Çø„Ç§„Éó
     * @returns {Function} Âæ©ÂÖÉÈñ¢Êï∞
     */
    simulateStressErrors(errorCount = 10, errorType = 'quotaExceeded') {
        this.log(`Starting stress error simulation: ${errorCount} errors of type ${errorType}`);
        
        let currentErrorCount = 0;
        let restoreFunction = null;
        
        switch (errorType) {
            case 'quotaExceeded':
                if (!this.originalMethods.setItem) {
                    this.originalMethods.setItem = localStorage.setItem.bind(localStorage);
                }
                
                localStorage.setItem = (key, value) => {
                    if (key.includes('spineSettings') && currentErrorCount < errorCount) {
                        currentErrorCount++;
                        this.log(`Stress error ${currentErrorCount}/${errorCount}`, 'warn');
                        throw new Error('QuotaExceededError: Stress test');
                    }
                    
                    return this.originalMethods.setItem(key, value);
                };
                
                restoreFunction = () => {
                    if (this.originalMethods.setItem) {
                        localStorage.setItem = this.originalMethods.setItem;
                    }
                };
                break;
                
            default:
                this.log(`Unsupported stress error type: ${errorType}`, 'error');
                return () => {};
        }
        
        this.activeSimulations.add(`stress-${errorType}`);
        
        return () => {
            if (restoreFunction) {
                restoreFunction();
            }
            this.activeSimulations.delete(`stress-${errorType}`);
            this.log(`Stress error simulation completed: ${currentErrorCount}/${errorCount} errors triggered`);
        };
    }
    
    /**
     * ÁèæÂú®„ÅÆ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Áä∂ÊÖã„ÇíÂèñÂæó
     * @returns {Object} „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Áä∂ÊÖã
     */
    getSimulationStatus() {
        return {
            activeSimulations: Array.from(this.activeSimulations),
            originalMethodsBackup: Object.keys(this.originalMethods),
            isSimulating: this.activeSimulations.size > 0
        };
    }
    
    /**
     * ÂÖ®„Å¶„ÅÆ„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥„ÇíÂÅúÊ≠¢„ÉªÂæ©ÂÖÉ
     */
    restoreAll() {
        this.log('Restoring all simulations');
        
        // localStorage methods restore
        Object.entries(this.originalMethods).forEach(([method, original]) => {
            if (localStorage[method] !== original) {
                localStorage[method] = original;
                this.log(`Restored localStorage.${method}`);
            }
        });
        
        // JSON methods restore (if modified)
        if (this.activeSimulations.has('jsonParse')) {
            // JSON.parse would have been restored by individual restore functions
        }
        
        this.originalMethods = {};
        this.activeSimulations.clear();
        
        this.log('All simulations restored');
    }
    
    /**
     * „ÉÜ„Çπ„ÉàÁµêÊûúÁîüÊàê
     * @param {Function} testFunction „ÉÜ„Çπ„ÉàÂØæË±°Èñ¢Êï∞
     * @param {string} errorType „Ç®„É©„Éº„Çø„Ç§„Éó
     * @returns {Object} „ÉÜ„Çπ„ÉàÁµêÊûú
     */
    async testErrorHandling(testFunction, errorType = 'quotaExceeded') {
        const testResult = {
            errorType: errorType,
            startTime: Date.now(),
            endTime: null,
            errors: [],
            gracefulHandling: false,
            resultData: null
        };
        
        let restoreFunction;
        
        try {
            // „Ç®„É©„Éº„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥ÈñãÂßã
            switch (errorType) {
                case 'quotaExceeded':
                    restoreFunction = this.simulateStorageQuotaExceeded();
                    break;
                case 'dataCorruption':
                    this.simulateDataCorruption('test-error-handling', 'invalidJson');
                    break;
                default:
                    throw new Error(`Unsupported error type: ${errorType}`);
            }
            
            // „ÉÜ„Çπ„ÉàÂÆüË°å
            const result = testFunction();
            testResult.resultData = result;
            testResult.gracefulHandling = true; // „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Å™„Åã„Å£„Åü„ÄÅ„Åæ„Åü„ÅØÈÅ©Âàá„Å´Âá¶ÁêÜ„Åï„Çå„Åü
            
        } catch (error) {
            testResult.errors.push(error.message);
            testResult.gracefulHandling = false; // „Ç®„É©„Éº„ÅåÈÅ©Âàá„Å´Âá¶ÁêÜ„Åï„Çå„Å™„Åã„Å£„Åü
        } finally {
            // Âæ©ÂÖÉ
            if (restoreFunction) {
                restoreFunction();
            }
            
            testResult.endTime = Date.now();
        }
        
        return testResult;
    }
}

// „Ç∞„É≠„Éº„Éê„É´Âà©Áî®ÂèØËÉΩ
if (typeof window !== 'undefined') {
    window.ErrorSimulator = ErrorSimulator;
}

// Node.jsÁí∞Â¢ÉÂØæÂøú
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ErrorSimulator;
}