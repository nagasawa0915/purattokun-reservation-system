<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>📦 ファイルがアーカイブされました</title>
    <style>
        body {
            font-family: 'Hiragino Sans', sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            line-height: 1.8;
            background: #f5f5f5;
        }
        .notice {
            background: #fff;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
        }
        h1 { color: #667eea; margin-bottom: 20px; }
        .info { background: #e8f4f8; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .path { font-family: monospace; background: #f0f0f0; padding: 2px 6px; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="notice">
        <h1>📦 ファイルがアーカイブされました</h1>
        
        <div class="info">
            <p><strong>タイムライン制御システム実験環境</strong>は以下の場所に移動されました：</p>
            <p class="path">archive/timeline-system-phase1-2025-08-08/experiment/timeline-experiment.html</p>
        </div>
        
        <p><strong>移動日時</strong>: 2025-08-08</p>
        <p><strong>移動理由</strong>: Phase 1タイムライン制御システム開発完了によるアーカイブ整理</p>
        
        <div class="info">
            <p><strong>アーカイブされたコンテンツ</strong>:</p>
            <ul style="text-align: left; display: inline-block;">
                <li>仕様書: キャラクタータイムライン制御システム仕様書.md</li>
                <li>実験環境: timeline-experiment.html</li>
                <li>assets/spine/: 22個timeline-*.jsファイル</li>
                <li>ルート: 8個timeline-*.jsファイル</li>
            </ul>
        </div>
        
        <p><strong>Phase 1実装状況</strong>: 95%完了・基本機能統合テスト完了</p>
        <p><strong>Phase 1.5</strong>: リファクタリング・品質保証作業待機中</p>
    </div>
</body>
</html>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', 'Noto Sans JP', sans-serif;
            line-height: 1.8;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px 20px;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            color: #667eea;
            font-size: 2.2rem;
            margin-bottom: 8px;
        }

        .header .subtitle {
            color: #666;
            font-size: 1.1rem;
        }

        .experiment-area {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            margin-bottom: 30px;
        }

        .spine-display {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            min-height: 600px;
            position: relative;
            backdrop-filter: blur(10px);
        }

        .timeline-controls {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .timeline-controls h3 {
            color: #667eea;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .control-section:last-child {
            border-bottom: none;
        }

        .control-section h4 {
            color: #555;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            margin: 3px;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #48bb78;
        }

        .btn-secondary:hover {
            background: #38a169;
        }

        .btn-danger {
            background: #e53e3e;
        }

        .btn-danger:hover {
            background: #c53030;
        }

        .timeline-display {
            background: #f8f9ff;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .status-info {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            backdrop-filter: blur(10px);
        }

        .status-item {
            text-align: center;
            padding: 15px;
            background: #f8f9ff;
            border-radius: 10px;
        }

        .status-item .label {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 5px;
        }

        .status-item .value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
        }

        @media (max-width: 1024px) {
            .experiment-area {
                grid-template-columns: 1fr;
            }
            
            .timeline-controls {
                order: -1;
            }
        }

        /* Spineキャラクター表示エリア */
        #spine-character-area {
            position: relative;
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            overflow: hidden;
        }

        /* デバッグ情報 */
        .debug-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 0.8rem;
            z-index: 1000;
        }

        /* Phase 2: 視覚的タイムライン編集UI */
        .btn.active {
            background: #48bb78;
            transform: translateY(-1px);
        }

        .timeline-track-container {
            background: #f8f9ff;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            border: 2px solid #e2e8f0;
        }

        .timeline-ruler {
            position: relative;
            height: 30px;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 5px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .ruler-marks {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                rgba(255,255,255,0.3) 0px,
                rgba(255,255,255,0.3) 1px,
                transparent 1px,
                transparent 20px
            );
        }

        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 3px;
            background: #e53e3e;
            left: 0%;
            transition: left 0.1s ease;
            box-shadow: 0 0 10px rgba(229, 62, 62, 0.5);
        }

        .playhead::before {
            content: '▼';
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            color: #e53e3e;
            font-size: 12px;
        }

        .character-tracks {
            min-height: 100px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            padding: 10px;
            border: 1px dashed #cbd5e0;
        }

        .character-track {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            border-left: 4px solid #667eea;
        }

        .track-label {
            width: 80px;
            font-size: 0.8rem;
            font-weight: bold;
            color: #667eea;
        }

        .track-timeline {
            flex: 1;
            height: 20px;
            position: relative;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 3px;
        }

        .keyframe {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #48bb78;
            border-radius: 50%;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }

        .keyframe:hover {
            transform: translateY(-50%) scale(1.2);
            background: #38a169;
        }

        .keyframe.selected {
            background: #e53e3e;
            transform: translateY(-50%) scale(1.3);
        }

        .keyframe-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e2e8f0;
        }

        .timeline-scrubber {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            cursor: pointer;
        }

        .timeline-scrubber::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .timeline-scrubber::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        #current-time-display {
            font-family: monospace;
            font-weight: bold;
            color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            padding: 3px 8px;
            border-radius: 4px;
        }

        .animation-selector {
            padding: 5px 10px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            background: white;
            color: #667eea;
            font-size: 0.9rem;
            cursor: pointer;
            outline: none;
            transition: all 0.2s;
        }

        .animation-selector:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .keyframe-details {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid #e2e8f0;
        }

        .details-header {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .details-content {
            font-size: 0.85rem;
            color: #555;
            line-height: 1.5;
        }

        .keyframe-property {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px solid #f1f5f9;
        }

        .keyframe-property:last-child {
            border-bottom: none;
        }

        .property-label {
            font-weight: 500;
            color: #4a5568;
        }

        .property-value {
            font-family: monospace;
            color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
        }

        /* モード切り替え表示制御 */
        .mode-hidden {
            display: none;
        }

        /* レスポンシブ対応 */
        @media (max-width: 768px) {
            .timeline-track-container {
                padding: 10px;
            }
            
            .keyframe-controls {
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .timeline-scrubber {
                min-width: 200px;
            }
            
            .character-track {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .track-label {
                width: 100%;
                margin-bottom: 5px;
            }
            
            .track-timeline {
                width: 100%;
                height: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ヘッダー -->
        <div class="header">
            <h1>🎬 タイムライン制御システム実験環境</h1>
            <p class="subtitle">Phase 1: 基本タイムライン制御エンジン開発・テスト環境</p>
        </div>

        <!-- ステータス情報 -->
        <div class="status-info">
            <div class="status-item">
                <div class="label">システム状態</div>
                <div class="value" id="system-status">初期化中...</div>
            </div>
            <div class="status-item">
                <div class="label">アクティブキャラクター</div>
                <div class="value" id="active-characters">0</div>
            </div>
            <div class="status-item">
                <div class="label">実行中タイムライン</div>
                <div class="value" id="running-timelines">0</div>
            </div>
            <div class="status-item">
                <div class="label">FPS / フレーム</div>
                <div class="value" id="current-frame">0fps</div>
            </div>
            <div class="status-item">
                <div class="label">メモリ使用量</div>
                <div class="value" id="memory-usage">0MB</div>
            </div>
            <div class="status-item">
                <div class="label">CPU負荷</div>
                <div class="value" id="cpu-usage">0%</div>
            </div>
        </div>

        <!-- 実験エリア -->
        <div class="experiment-area">
            <!-- Spine表示エリア -->
            <div class="spine-display">
                <h3>🎭 キャラクター表示エリア</h3>
                <div id="spine-character-area">
                    <!-- デバッグ情報オーバーレイ -->
                    <div class="debug-overlay" id="debug-info">
                        <div>Time: <span id="debug-time">0.00s</span></div>
                        <div>Timeline: <span id="debug-timeline">未実行</span></div>
                        <div>Animation: <span id="debug-animation">未設定</span></div>
                    </div>
                    
                    <!-- Spineキャラクターがここに表示される -->
                </div>
            </div>

            <!-- Phase 2: 視覚的タイムライン編集パネル -->
            <div class="timeline-controls">
                <h3>🎬 タイムライン編集</h3>
                
                <!-- モード切り替え -->
                <div class="control-section">
                    <h4>編集モード</h4>
                    <button class="btn" id="mode-basic">⏱️ 基本制御</button>
                    <button class="btn btn-secondary active" id="mode-visual">🎨 ビジュアル編集</button>
                </div>
                
                <!-- 基本制御 -->
                <div class="control-section" id="basic-controls">
                    <h4>基本制御</h4>
                    <button class="btn" id="play-timeline">▶️ 再生</button>
                    <button class="btn" id="pause-timeline">⏸️ 一時停止</button>
                    <button class="btn" id="stop-timeline">⏹️ 停止</button>
                    <button class="btn btn-secondary" id="reset-timeline">🔄 リセット</button>
                </div>
                
                <!-- 視覚的タイムライン編集エリア -->
                <div class="control-section" id="visual-timeline-editor">
                    <h4>🎯 タイムライントラック</h4>
                    <div class="timeline-track-container">
                        <!-- タイムルーラー -->
                        <div class="timeline-ruler">
                            <div class="ruler-marks"></div>
                            <div class="playhead" id="timeline-playhead"></div>
                        </div>
                        
                        <!-- キャラクター別トラック -->
                        <div class="character-tracks" id="character-tracks">
                            <!-- 動的に生成されるトラック -->
                        </div>
                    </div>
                    
                    <!-- キーフレーム編集コントロール -->
                    <div class="keyframe-controls">
                        <button class="btn btn-secondary" id="add-keyframe">➕ キーフレーム</button>
                        <button class="btn" id="delete-keyframe">🗑️ 削除</button>
                        <select id="animation-selector" class="animation-selector">
                            <option value="idle">待機</option>
                            <option value="walk">歩行</option>
                            <option value="jump">ジャンプ</option>
                            <option value="wave">手振り</option>
                            <option value="dance">ダンス</option>
                        </select>
                        <input type="range" id="timeline-scrubber" min="0" max="10" step="0.1" value="0" class="timeline-scrubber">
                        <span id="current-time-display">0.0s</span>
                    </div>
                    
                    <!-- キーフレーム詳細情報 -->
                    <div class="keyframe-details" id="keyframe-details">
                        <div class="details-header">🎯 キーフレーム詳細</div>
                        <div class="details-content" id="details-content">
                            キーフレームを選択してください
                        </div>
                    </div>
                </div>

                <!-- サンプルタイムライン -->
                <div class="control-section">
                    <h4>サンプル実行</h4>
                    <button class="btn btn-secondary" id="sample-basic">基本演出</button>
                    <button class="btn btn-secondary" id="sample-complex">複雑演出</button>
                    <button class="btn btn-secondary" id="sample-sync">同期演出</button>
                </div>

                <!-- キャラクター制御 -->
                <div class="control-section">
                    <h4>キャラクター</h4>
                    <button class="btn" id="load-purattokun">🐱 ぷらっとくん</button>
                    <button class="btn" id="load-nezumi">🐭 ねずみ</button>
                    <button class="btn btn-danger" id="clear-characters">❌ 全削除</button>
                </div>

                <!-- タイムライン表示 -->
                <div class="control-section">
                    <h4>タイムライン詳細</h4>
                    <div class="timeline-display" id="timeline-display">
                        タイムライン情報がここに表示されます
                    </div>
                </div>

                <!-- 🎯 境界ボックス高度連携テスト -->
                <div class="control-section">
                    <h4>🎯 境界ボックス高度連携</h4>
                    <div class="bounds-advanced-controls">
                        <button class="btn btn-secondary" onclick="testPrecisionClick()">精密クリック判定</button>
                        <button class="btn btn-secondary" onclick="testZonePerformances()">ゾーン別演出</button>
                        <button class="btn btn-secondary" onclick="testSynergyPerformances()">連携演出</button>
                        <button class="btn btn-info" onclick="testInteractionHistory()">履歴システム</button>
                        <button class="btn btn-info" onclick="visualizeBoundingZones()">境界ゾーン可視化</button>
                        <button class="btn" onclick="debugBoundsIntegration()">統合状態確認</button>
                    </div>
                    <div class="bounds-test-results" id="bounds-test-results" style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px; min-height: 60px;">
                        <small>テスト結果がここに表示されます</small>
                    </div>
                </div>

                <!-- 🚀 パフォーマンス最適化制御 -->
                <div class="control-section">
                    <h4>🚀 パフォーマンス最適化</h4>
                    <div class="performance-controls">
                        <button class="btn btn-secondary" id="start-optimization" onclick="startPerformanceOptimization()">⚡ 最適化開始</button>
                        <button class="btn btn-danger" id="stop-optimization" onclick="stopPerformanceOptimization()">⏹️ 最適化停止</button>
                        <button class="btn" onclick="showPerformanceReport()">📊 レポート表示</button>
                        <button class="btn" onclick="executeMemoryCleanup()">🧹 メモリ清理</button>
                    </div>
                    <div class="performance-results" id="performance-results" style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px; min-height: 60px;">
                        <small>パフォーマンス情報がここに表示されます</small>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- タイムライン設定データ（HTML設定制御システム） -->
    <div id="timeline-config" style="display: none;">
        <!-- サンプル設定 -->
        <div class="sample-basic" 
             data-timeline="0:appear,2:idle,5:wave,8:idle"
             data-character="purattokun">
        </div>
        
        <div class="sample-complex" 
             data-timeline="0:appear,1:walk,3:jump,4:wave,6:dance,8:bow,10:idle"
             data-character="purattokun">
        </div>
        
        <div class="sample-sync"
             data-timeline="0:appear,2:walk,4:wave"
             data-character="purattokun,nezumi"
             data-sync="true">
        </div>
    </div>

    <!-- 既存Spineシステム読み込み -->
    <script src="https://unpkg.com/@esotericsoftware/spine-webgl@4.1.*/dist/iife/spine-webgl.js"></script>
    
    <!-- 既存システムファイル -->
    <script src="assets/spine/spine-coordinate-utils.js"></script>
    <script src="assets/spine/spine-integration-v2.js"></script>
    <script src="assets/spine/spine-character-manager.js"></script>
    
    <!-- タイムライン制御システム（Phase 2.5 リファクタリング後） -->
    <script src="assets/spine/timeline-control-engine.js"></script>
    
    <!-- 🆕 Phase 2.5: 分割後モジュール（依存順序重要） -->
    <!-- タイムライン編集UI：コア → 拡張機能 → 統合 の順序で読み込み -->
    <script src="assets/spine/timeline-editor-core.js"></script>
    <script src="assets/spine/timeline-keyframe-ui.js"></script>
    <script src="assets/spine/timeline-responsive-ui.js"></script>
    <script src="assets/spine/timeline-visual-effects.js"></script>
    
    <!-- タイムライン編集統合：コア → 互換性 の順序で読み込み -->
    <script src="assets/spine/timeline-edit-core.js"></script>
    <script src="assets/spine/timeline-edit-compatibility.js"></script>
    
    <!-- コア機能（必須・順序重要） -->
    <script src="assets/spine/timeline-error-core.js"></script>
    <script src="assets/spine/timeline-diagnostics.js"></script>
    <script src="assets/spine/timeline-data-core.js"></script>
    <script src="assets/spine/timeline-compatibility.js"></script>
    <script src="assets/spine/timeline-sequence-manager.js"></script>
    
    <!-- 🎭 高度キャラクター同期制御システム -->
    <script src="timeline-character-sync.js"></script>
    
    <!-- 🎬 動的演出制御・条件分岐システム -->
    <script src="timeline-dynamic-performance.js"></script>
    
    <!-- 🎭 複雑シーケンス管理・ネスト対応システム -->
    <script src="timeline-complex-sequences.js"></script>
    
    <!-- 拡張機能（オプション） -->
    <script src="assets/spine/timeline-sequence-tests.js"></script>
    
    <!-- 検証・テスト機能 -->
    <script src="assets/spine/timeline-refactoring-validation.js"></script>
    
    <!-- 🎯 境界ボックス高度連携システム -->
    <script src="spine-bounds-integration.js"></script>
    <script src="timeline-bounds-advanced.js"></script>
    
    <!-- 🚀 パフォーマンス最適化システム -->
    <script src="timeline-performance-optimizer.js"></script>
    
    <!-- レガシー互換性：旧ファイルは非推奨・新モジュールで代替 -->
    <!-- 旧timeline-editor-ui.js → 4つのモジュールに分割済み -->
    <!-- 旧timeline-edit-integration.js → 2つのモジュールに分割済み -->
    
    <!-- 実験環境制御スクリプト -->
    <script>
        // Phase 2: 視覚的タイムライン編集システム
        class VisualTimelineEditor {
            constructor() {
                this.currentTime = 0;
                this.maxTime = 10;
                this.isPlaying = false;
                this.playbackSpeed = 1;
                this.selectedKeyframe = null;
                this.characterTracks = new Map();
                this.keyframes = new Map();
                this.mode = 'visual'; // 'basic' or 'visual'
                
                console.log('🎨 Visual Timeline Editor 初期化');
            }
            
            init() {
                this.setupModeToggle();
                this.setupTimelineControls();
                this.setupKeyframeEditing();
                this.createSampleTracks();
                this.startUpdateLoop();
                
                console.log('✅ Visual Timeline Editor 準備完了');
            }
            
            setupModeToggle() {
                const basicModeBtn = document.getElementById('mode-basic');
                const visualModeBtn = document.getElementById('mode-visual');
                const basicControls = document.getElementById('basic-controls');
                const visualEditor = document.getElementById('visual-timeline-editor');
                
                basicModeBtn.addEventListener('click', () => {
                    this.mode = 'basic';
                    basicModeBtn.classList.add('active');
                    visualModeBtn.classList.remove('active');
                    basicControls.classList.remove('mode-hidden');
                    visualEditor.classList.add('mode-hidden');
                    console.log('⏱️ 基本制御モードに切り替え');
                });
                
                visualModeBtn.addEventListener('click', () => {
                    this.mode = 'visual';
                    visualModeBtn.classList.add('active');
                    basicModeBtn.classList.remove('active');
                    basicControls.classList.add('mode-hidden');
                    visualEditor.classList.remove('mode-hidden');
                    console.log('🎨 ビジュアル編集モードに切り替え');
                });
                
                // 初期状態設定
                visualModeBtn.click();
            }
            
            setupTimelineControls() {
                const scrubber = document.getElementById('timeline-scrubber');
                const timeDisplay = document.getElementById('current-time-display');
                
                scrubber.addEventListener('input', (e) => {
                    this.currentTime = parseFloat(e.target.value);
                    this.updateTimeDisplay();
                    this.updatePlayhead();
                });
                
                scrubber.addEventListener('change', (e) => {
                    console.log(`⏰ タイムライン位置変更: ${this.currentTime.toFixed(1)}s`);
                });
            }
            
            setupKeyframeEditing() {
                const addKeyframeBtn = document.getElementById('add-keyframe');
                const deleteKeyframeBtn = document.getElementById('delete-keyframe');
                
                addKeyframeBtn.addEventListener('click', () => {
                    this.addKeyframe();
                });
                
                deleteKeyframeBtn.addEventListener('click', () => {
                    this.deleteSelectedKeyframe();
                });
            }
            
            createSampleTracks() {
                const tracksContainer = document.getElementById('character-tracks');
                const sampleTracks = [
                    { id: 'purattokun', label: '🐱 ぷらっとくん', keyframes: [0, 2, 5, 8] },
                    { id: 'nezumi', label: '🐭 ねずみ', keyframes: [1, 3, 6, 9] }
                ];
                
                sampleTracks.forEach(trackData => {
                    const track = this.createCharacterTrack(trackData);
                    tracksContainer.appendChild(track);
                });
            }
            
            createCharacterTrack(trackData) {
                const track = document.createElement('div');
                track.className = 'character-track';
                track.dataset.characterId = trackData.id;
                
                const label = document.createElement('div');
                label.className = 'track-label';
                label.textContent = trackData.label;
                
                const timeline = document.createElement('div');
                timeline.className = 'track-timeline';
                
                // キーフレーム追加
                trackData.keyframes.forEach(time => {
                    const keyframe = this.createKeyframe(time, trackData.id);
                    timeline.appendChild(keyframe);
                });
                
                track.appendChild(label);
                track.appendChild(timeline);
                
                this.characterTracks.set(trackData.id, {
                    element: track,
                    keyframes: trackData.keyframes
                });
                
                return track;
            }
            
            createKeyframe(time, characterId, animation = 'idle') {
                const keyframe = document.createElement('div');
                keyframe.className = 'keyframe';
                keyframe.style.left = `${(time / this.maxTime) * 100}%`;
                keyframe.dataset.time = time;
                keyframe.dataset.characterId = characterId;
                keyframe.dataset.animation = animation;
                keyframe.title = `${time}s - ${animation}`;
                
                keyframe.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectKeyframe(keyframe);
                });
                
                keyframe.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.startKeyframeDrag(keyframe, e);
                });
                
                // ダブルクリックでアニメーション変更
                keyframe.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    this.editKeyframeAnimation(keyframe);
                });
                
                const keyframeId = `${characterId}-${time}`;
                this.keyframes.set(keyframeId, {
                    element: keyframe,
                    time: time,
                    characterId: characterId,
                    animation: animation
                });
                
                return keyframe;
            }
            
            selectKeyframe(keyframe) {
                // 前の選択を解除
                if (this.selectedKeyframe) {
                    this.selectedKeyframe.classList.remove('selected');
                }
                
                // 新しいキーフレーム選択
                this.selectedKeyframe = keyframe;
                keyframe.classList.add('selected');
                
                const time = parseFloat(keyframe.dataset.time);
                const characterId = keyframe.dataset.characterId;
                const animation = keyframe.dataset.animation || 'idle';
                
                // 詳細情報表示更新
                this.updateKeyframeDetails(time, characterId, animation);
                
                console.log(`🎯 キーフレーム選択: ${characterId} at ${time}s (${animation})`);
            }
            
            updateKeyframeDetails(time, characterId, animation) {
                const detailsContent = document.getElementById('details-content');
                
                detailsContent.innerHTML = `
                    <div class="keyframe-property">
                        <span class="property-label">キャラクター:</span>
                        <span class="property-value">${characterId}</span>
                    </div>
                    <div class="keyframe-property">
                        <span class="property-label">時間:</span>
                        <span class="property-value">${time.toFixed(1)}s</span>
                    </div>
                    <div class="keyframe-property">
                        <span class="property-label">アニメーション:</span>
                        <span class="property-value">${animation}</span>
                    </div>
                    <div class="keyframe-property">
                        <span class="property-label">操作:</span>
                        <span class="property-value">ダブルクリックで編集</span>
                    </div>
                `;
            }
            
            editKeyframeAnimation(keyframe) {
                const currentAnimation = keyframe.dataset.animation || 'idle';
                const selector = document.getElementById('animation-selector');
                
                // アニメーション選択ダイアログ（簡易版）
                const newAnimation = prompt(`アニメーション変更 (現在: ${currentAnimation})`, currentAnimation);
                
                if (newAnimation && newAnimation !== currentAnimation) {
                    keyframe.dataset.animation = newAnimation;
                    keyframe.title = `${keyframe.dataset.time}s - ${newAnimation}`;
                    
                    // キーフレームデータ更新
                    const keyframeId = `${keyframe.dataset.characterId}-${keyframe.dataset.time}`;
                    const keyframeData = this.keyframes.get(keyframeId);
                    if (keyframeData) {
                        keyframeData.animation = newAnimation;
                    }
                    
                    // 詳細表示更新
                    if (this.selectedKeyframe === keyframe) {
                        this.updateKeyframeDetails(
                            parseFloat(keyframe.dataset.time),
                            keyframe.dataset.characterId,
                            newAnimation
                        );
                    }
                    
                    console.log(`🎨 アニメーション変更: ${keyframe.dataset.characterId} -> ${newAnimation}`);
                }
            }
            
            startKeyframeDrag(keyframe, startEvent) {
                const timeline = keyframe.parentElement;
                const timelineRect = timeline.getBoundingClientRect();
                
                const onMouseMove = (e) => {
                    const x = e.clientX - timelineRect.left;
                    const percentage = Math.max(0, Math.min(100, (x / timelineRect.width) * 100));
                    const newTime = (percentage / 100) * this.maxTime;
                    
                    keyframe.style.left = `${percentage}%`;
                    keyframe.dataset.time = newTime.toFixed(1);
                    keyframe.title = `${newTime.toFixed(1)}s`;
                };
                
                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    
                    const newTime = parseFloat(keyframe.dataset.time);
                    const characterId = keyframe.dataset.characterId;
                    console.log(`✅ キーフレーム移動完了: ${characterId} to ${newTime}s`);
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }
            
            addKeyframe() {
                const activeTrack = Array.from(this.characterTracks.keys())[0]; // 最初のトラック
                if (!activeTrack) return;
                
                // アニメーション選択
                const animationSelector = document.getElementById('animation-selector');
                const selectedAnimation = animationSelector.value;
                
                const trackData = this.characterTracks.get(activeTrack);
                const timeline = trackData.element.querySelector('.track-timeline');
                
                const keyframe = this.createKeyframe(this.currentTime, activeTrack, selectedAnimation);
                timeline.appendChild(keyframe);
                
                // 追加したキーフレームを自動選択
                this.selectKeyframe(keyframe);
                
                console.log(`➕ キーフレーム追加: ${activeTrack} at ${this.currentTime}s (${selectedAnimation})`);
            }
            
            deleteSelectedKeyframe() {
                if (!this.selectedKeyframe) {
                    console.log('⚠️ 削除するキーフレームが選択されていません');
                    return;
                }
                
                const time = this.selectedKeyframe.dataset.time;
                const characterId = this.selectedKeyframe.dataset.characterId;
                
                this.selectedKeyframe.remove();
                this.keyframes.delete(`${characterId}-${time}`);
                this.selectedKeyframe = null;
                
                console.log(`🗑️ キーフレーム削除: ${characterId} at ${time}s`);
            }
            
            updateTimeDisplay() {
                const timeDisplay = document.getElementById('current-time-display');
                timeDisplay.textContent = `${this.currentTime.toFixed(1)}s`;
            }
            
            updatePlayhead() {
                const playhead = document.getElementById('timeline-playhead');
                const percentage = (this.currentTime / this.maxTime) * 100;
                playhead.style.left = `${Math.max(0, Math.min(100, percentage))}%`;
            }
            
            startUpdateLoop() {
                const update = () => {
                    if (this.isPlaying) {
                        this.currentTime += 0.016 * this.playbackSpeed; // 60fps
                        if (this.currentTime >= this.maxTime) {
                            this.currentTime = this.maxTime;
                            this.isPlaying = false;
                        }
                        
                        // UI更新
                        const scrubber = document.getElementById('timeline-scrubber');
                        scrubber.value = this.currentTime;
                        this.updateTimeDisplay();
                        this.updatePlayhead();
                        
                        // リアルタイムプレビュー更新
                        this.updateRealtimePreview();
                    }
                    
                    requestAnimationFrame(update);
                };
                
                update();
            }
            
            // リアルタイムプレビュー機能
            updateRealtimePreview() {
                // 現在時間でアクティブなキーフレームを検索
                const activeAnimations = this.getActiveAnimations(this.currentTime);
                
                // デバッグ情報更新
                this.updateDebugInfo(activeAnimations);
                
                // 実験環境の表示更新
                this.updateCharacterPreview(activeAnimations);
            }
            
            getActiveAnimations(currentTime) {
                const activeAnimations = new Map();
                
                // 全キャラクターのタイムラインをスキャン
                for (const [characterId, trackData] of this.characterTracks) {
                    const keyframeElements = trackData.element.querySelectorAll('.keyframe');
                    let activeAnimation = 'idle'; // デフォルト
                    let closestTime = -1;
                    
                    // 現在時間より前の最も近いキーフレームを検索
                    keyframeElements.forEach(keyframeEl => {
                        const keyframeTime = parseFloat(keyframeEl.dataset.time);
                        const animation = keyframeEl.dataset.animation || 'idle';
                        
                        if (keyframeTime <= currentTime && keyframeTime > closestTime) {
                            closestTime = keyframeTime;
                            activeAnimation = animation;
                        }
                    });
                    
                    activeAnimations.set(characterId, {
                        animation: activeAnimation,
                        keyframeTime: closestTime,
                        isActive: closestTime >= 0
                    });
                }
                
                return activeAnimations;
            }
            
            updateDebugInfo(activeAnimations) {
                const debugTimeline = document.getElementById('debug-timeline');
                const debugAnimation = document.getElementById('debug-animation');
                
                if (debugTimeline) {
                    debugTimeline.textContent = this.isPlaying ? '再生中' : '停止中';
                }
                
                if (debugAnimation) {
                    const animationList = [];
                    for (const [characterId, data] of activeAnimations) {
                        if (data.isActive) {
                            animationList.push(`${characterId}:${data.animation}`);
                        }
                    }
                    debugAnimation.textContent = animationList.length > 0 ? animationList.join(', ') : '未設定';
                }
            }
            
            updateCharacterPreview(activeAnimations) {
                // キャラクター表示エリアにアクティブな状態を反映
                const characterArea = document.getElementById('spine-character-area');
                
                // 現在のアニメーション状態を視覚的に表示
                let statusText = '';
                for (const [characterId, data] of activeAnimations) {
                    if (data.isActive) {
                        const emoji = characterId === 'purattokun' ? '🐱' : '🐭';
                        statusText += `${emoji} ${data.animation} `;
                    }
                }
                
                // ステータス表示の更新
                const existingStatus = characterArea.querySelector('.animation-status');
                if (existingStatus) {
                    existingStatus.textContent = statusText || 'アニメーション待機中';
                } else {
                    const statusDiv = document.createElement('div');
                    statusDiv.className = 'animation-status';
                    statusDiv.style.cssText = `
                        position: absolute;
                        bottom: 20px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(0,0,0,0.8);
                        color: white;
                        padding: 10px 20px;
                        border-radius: 20px;
                        font-size: 1.1rem;
                        font-weight: bold;
                        z-index: 100;
                    `;
                    statusDiv.textContent = statusText || 'アニメーション待機中';
                    characterArea.appendChild(statusDiv);
                }
            }
            
            // タイムライン実行制御の改良
            play() {
                this.isPlaying = true;
                console.log('▶️ タイムライン再生開始');
            }
            
            pause() {
                this.isPlaying = false;
                console.log('⏸️ タイムライン一時停止');
            }
            
            stop() {
                this.isPlaying = false;
                this.currentTime = 0;
                
                const scrubber = document.getElementById('timeline-scrubber');
                if (scrubber) scrubber.value = 0;
                
                this.updateTimeDisplay();
                this.updatePlayhead();
                this.updateRealtimePreview();
                
                console.log('⏹️ タイムライン停止・リセット');
            }
            
            reset() {
                this.stop();
                console.log('🔄 タイムライン完全リセット');
            }
        }

        // 実験環境初期化
        class TimelineExperimentEnvironment {
            constructor() {
                this.isInitialized = false;
                this.activeTimelines = new Map();
                this.frameCount = 0;
                this.startTime = Date.now();
                this.visualEditor = null; // Phase 2 追加
                
                this.init();
            }
            
            async init() {
                try {
                    // 既存システム初期化待機
                    await this.waitForSpineSystem();
                    
                    // UI初期化
                    this.setupUI();
                    
                    // Phase 2: Visual Timeline Editor 初期化
                    this.visualEditor = new VisualTimelineEditor();
                    this.visualEditor.init();
                    
                    // フレーム更新開始
                    this.startFrameUpdate();
                    
                    this.updateStatus('システム準備完了', 'success');
                    this.isInitialized = true;
                    
                } catch (error) {
                    console.error('❌ Timeline実験環境初期化エラー:', error);
                    this.updateStatus('初期化エラー', 'error');
                }
            }
            
            async waitForSpineSystem() {
                // 既存Spineシステムの初期化待機
                return new Promise((resolve, reject) => {
                    let attempts = 0;
                    const maxAttempts = 50;
                    
                    const checkSystem = () => {
                        // より柔軟な初期化確認（段階的チェック）
                        const hasSpine = window.spine || window.SpineWebGL;
                        const hasCharacterManager = window.SpineCharacterManager || window.spineCharacterManager;
                        const hasTimelineEngine = window.TimelineControlEngine;
                        
                        console.log('🔍 システム確認:', {
                            spine: !!hasSpine,
                            characterManager: !!hasCharacterManager,
                            timelineEngine: !!hasTimelineEngine,
                            attempt: attempts
                        });
                        
                        if (hasSpine && (hasCharacterManager || attempts > 30)) {
                            console.log('✅ Spineシステム確認完了（柔軟モード）');
                            resolve();
                        } else if (attempts >= maxAttempts) {
                            console.log('⚠️ タイムアウト - 部分初期化で継続');
                            resolve(); // タイムアウト時もresolveして継続
                        } else {
                            attempts++;
                            setTimeout(checkSystem, 100);
                        }
                    };
                    
                    checkSystem();
                });
            }
            
            setupUI() {
                // 基本制御ボタン（Visual Editor統合・改良版）
                document.getElementById('play-timeline').addEventListener('click', () => {
                    if (this.visualEditor) {
                        this.visualEditor.play();
                    }
                    this.updateTimelineDisplay('再生開始');
                });
                
                document.getElementById('pause-timeline').addEventListener('click', () => {
                    if (this.visualEditor) {
                        this.visualEditor.pause();
                    }
                    this.updateTimelineDisplay('一時停止');
                });
                
                document.getElementById('stop-timeline').addEventListener('click', () => {
                    this.frameCount = 0;
                    if (this.visualEditor) {
                        this.visualEditor.stop();
                    }
                    this.updateTimelineDisplay('停止・リセット');
                });
                
                document.getElementById('reset-timeline').addEventListener('click', () => {
                    this.frameCount = 0;
                    this.startTime = Date.now();
                    if (this.visualEditor) {
                        this.visualEditor.reset();
                    }
                    this.updateTimelineDisplay('完全リセット完了');
                });
                
                // サンプル実行ボタン
                document.getElementById('sample-basic').addEventListener('click', () => {
                    this.runSampleTimeline('basic');
                });
                
                document.getElementById('sample-complex').addEventListener('click', () => {
                    this.runSampleTimeline('complex');
                });
                
                document.getElementById('sample-sync').addEventListener('click', () => {
                    this.runSampleTimeline('sync');
                });
                
                // キャラクター制御
                document.getElementById('load-purattokun').addEventListener('click', () => {
                    console.log('🐱 ぷらっとくん読み込み');
                    this.updateTimelineDisplay('ぷらっとくん読み込み実行');
                });
                
                document.getElementById('load-nezumi').addEventListener('click', () => {
                    console.log('🐭 ねずみ読み込み');
                    this.updateTimelineDisplay('ねずみ読み込み実行');
                });
                
                document.getElementById('clear-characters').addEventListener('click', () => {
                    console.log('❌ 全キャラクター削除');
                    this.updateTimelineDisplay('全キャラクター削除');
                });
            }
            
            startFrameUpdate() {
                const updateFrame = () => {
                    this.frameCount++;
                    const currentTime = (Date.now() - this.startTime) / 1000;
                    
                    // デバッグ情報更新
                    const currentFrameEl = document.getElementById('current-frame');
                    const debugTimeEl = document.getElementById('debug-time');
                    
                    if (currentFrameEl) currentFrameEl.textContent = this.frameCount;
                    if (debugTimeEl) debugTimeEl.textContent = currentTime.toFixed(2) + 's';
                    
                    requestAnimationFrame(updateFrame);
                };
                
                updateFrame();
            }
            
            runSampleTimeline(type) {
                const sampleData = {
                    'basic': '基本演出: 出現→待機→手振り→待機',
                    'complex': '複雑演出: 出現→歩行→ジャンプ→手振り→ダンス→お辞儀→待機',
                    'sync': '同期演出: 複数キャラクターの連携動作'
                };
                
                console.log(`🎬 ${sampleData[type]} 実行`);
                this.updateTimelineDisplay(`実行: ${sampleData[type]}`);
                
                // 実際のタイムライン実行はPhase 1完了後に実装
            }
            
            updateStatus(message, type = 'info') {
                document.getElementById('system-status').textContent = message;
                
                // 色分け
                const statusElement = document.getElementById('system-status');
                statusElement.style.color = {
                    'success': '#48bb78',
                    'error': '#e53e3e',
                    'warning': '#ed8936',
                    'info': '#667eea'
                }[type] || '#667eea';
            }
            
            updateTimelineDisplay(message) {
                const display = document.getElementById('timeline-display');
                const timestamp = new Date().toLocaleTimeString();
                display.innerHTML += `<div>[${timestamp}] ${message}</div>`;
                display.scrollTop = display.scrollHeight;
            }
        }

        // ========== 🎯 境界ボックス高度連携テスト関数群 ========== //

        /**
         * 精密クリック判定テスト
         */
        function testPrecisionClick() {
            const resultsDiv = document.getElementById('bounds-test-results');
            
            try {
                if (window.timelineBoundsAdvanced) {
                    // 模擬精密クリックイベント生成
                    const mockEvent = {
                        characterId: 'purattokun',
                        position: { x: 150, y: 100 },
                        clickType: 'precise_click',
                        boundingData: window.timelineBoundsAdvanced.getMockBoundingData('purattokun')
                    };
                    
                    window.timelineBoundsAdvanced.handlePreciseClick(mockEvent);
                    resultsDiv.innerHTML = `✅ 精密クリック判定テスト実行<br><small>位置: (${mockEvent.position.x}, ${mockEvent.position.y}), キャラ: ${mockEvent.characterId}</small>`;
                    console.log('🎯 精密クリック判定テスト実行完了');
                    
                } else {
                    resultsDiv.innerHTML = '❌ timelineBoundsAdvanced が見つかりません';
                }
            } catch (error) {
                resultsDiv.innerHTML = `❌ エラー: ${error.message}`;
                console.error('精密クリック判定テストエラー:', error);
            }
        }

        /**
         * ゾーン別演出テスト
         */
        function testZonePerformances() {
            const resultsDiv = document.getElementById('bounds-test-results');
            
            try {
                if (window.timelineBoundsAdvanced) {
                    const zones = ['head', 'body', 'tail', 'paws'];
                    const testZone = zones[Math.floor(Math.random() * zones.length)];
                    
                    // ゾーン演出テスト実行
                    const testResult = window.timelineBoundsAdvanced.getZonePerformances('purattokun', testZone);
                    
                    if (testResult) {
                        resultsDiv.innerHTML = `✅ ゾーン演出テスト: ${testZone}<br><small>演出: ${testResult.performances.join(', ')}</small>`;
                        console.log(`🎭 ゾーン演出テスト完了: ${testZone}`, testResult);
                        
                        // 実際の演出実行もテスト
                        window.timelineBoundsAdvanced.executeZonePerformance('purattokun', testZone, {
                            name: testResult.performances[0],
                            sequence: testResult.performances[0]
                        });
                        
                    } else {
                        resultsDiv.innerHTML = `⚠️ ゾーン演出データなし: ${testZone}`;
                    }
                } else {
                    resultsDiv.innerHTML = '❌ timelineBoundsAdvanced が見つかりません';
                }
            } catch (error) {
                resultsDiv.innerHTML = `❌ エラー: ${error.message}`;
                console.error('ゾーン別演出テストエラー:', error);
            }
        }

        /**
         * 連携演出テスト
         */
        function testSynergyPerformances() {
            const resultsDiv = document.getElementById('bounds-test-results');
            
            try {
                if (window.timelineBoundsAdvanced) {
                    // purattokun → nezumi 連携演出テスト
                    window.timelineBoundsAdvanced.executeSynergyPerformance('purattokun', 'head', ['nezumi_attention']);
                    
                    resultsDiv.innerHTML = '✅ 連携演出テスト実行<br><small>purattokun[head] → nezumi[attention]</small>';
                    console.log('🤝 連携演出テスト実行完了');
                    
                } else {
                    resultsDiv.innerHTML = '❌ timelineBoundsAdvanced が見つかりません';
                }
            } catch (error) {
                resultsDiv.innerHTML = `❌ エラー: ${error.message}`;
                console.error('連携演出テストエラー:', error);
            }
        }

        /**
         * インタラクション履歴システムテスト
         */
        function testInteractionHistory() {
            const resultsDiv = document.getElementById('bounds-test-results');
            
            try {
                if (window.timelineBoundsAdvanced) {
                    // 履歴データ更新テスト
                    window.timelineBoundsAdvanced.updateInteractionHistory('purattokun', {
                        zone: 'head',
                        clickType: 'gentle_click',
                        timestamp: Date.now(),
                        position: { x: 120, y: 80 }
                    });
                    
                    // 履歴データ取得・表示
                    const context = window.timelineBoundsAdvanced.getInteractionContext('purattokun');
                    
                    resultsDiv.innerHTML = `✅ 履歴システムテスト完了<br><small>総インタラクション数: ${context.totalInteractions}, 最新: ${context.lastInteraction ? context.lastInteraction.zone : 'なし'}</small>`;
                    console.log('📚 履歴システムテスト完了', context);
                    
                } else {
                    resultsDiv.innerHTML = '❌ timelineBoundsAdvanced が見つかりません';
                }
            } catch (error) {
                resultsDiv.innerHTML = `❌ エラー: ${error.message}`;
                console.error('履歴システムテストエラー:', error);
            }
        }

        /**
         * 境界ゾーン可視化
         */
        function visualizeBoundingZones() {
            const resultsDiv = document.getElementById('bounds-test-results');
            
            try {
                // 簡易可視化情報表示
                const zoneInfo = {
                    purattokun: ['head', 'body', 'tail', 'paws'],
                    nezumi: ['head', 'whiskers', 'tail']
                };
                
                let visualizationHtml = '✅ 境界ゾーン情報:<br>';
                Object.entries(zoneInfo).forEach(([char, zones]) => {
                    visualizationHtml += `<small>${char}: ${zones.join(', ')}</small><br>`;
                });
                
                resultsDiv.innerHTML = visualizationHtml;
                console.log('🎯 境界ゾーン可視化完了', zoneInfo);
                
                // 実際のCanvas上に境界を描画する機能は将来実装
                
            } catch (error) {
                resultsDiv.innerHTML = `❌ エラー: ${error.message}`;
                console.error('境界ゾーン可視化エラー:', error);
            }
        }

        /**
         * 統合状態確認
         */
        function debugBoundsIntegration() {
            const resultsDiv = document.getElementById('bounds-test-results');
            
            try {
                const integrationStatus = {
                    timelineBoundsAdvanced: !!window.timelineBoundsAdvanced,
                    indexBoundsManager: !!window.indexBoundsManager,
                    timelineControlEngine: !!window.timelineControlEngine,
                    complexSequenceManager: !!window.complexSequenceManager,
                    advancedCharacterSyncController: !!window.advancedCharacterSyncController
                };
                
                let statusHtml = '🔍 統合状態確認:<br>';
                Object.entries(integrationStatus).forEach(([system, status]) => {
                    const statusIcon = status ? '✅' : '❌';
                    statusHtml += `<small>${statusIcon} ${system}</small><br>`;
                });
                
                // 統合システムの詳細情報
                if (window.timelineBoundsAdvanced) {
                    const zoneCount = window.timelineBoundsAdvanced.zonePerformanceMap.size;
                    statusHtml += `<small>📊 登録ゾーン数: ${zoneCount}</small><br>`;
                }
                
                resultsDiv.innerHTML = statusHtml;
                console.log('🔍 境界ボックス統合状態確認完了', integrationStatus);
                
                // デバッグコンソールにもステータス出力
                if (window.timelineBoundsAdvanced) {
                    console.log('🎯 TimelineBoundsAdvanced:', window.timelineBoundsAdvanced);
                    console.log('🗺️ Zone Performance Map:', window.timelineBoundsAdvanced.zonePerformanceMap);
                }
                
            } catch (error) {
                resultsDiv.innerHTML = `❌ エラー: ${error.message}`;
                console.error('統合状態確認エラー:', error);
            }
        }
        
        // ========== 🚀 パフォーマンス最適化制御関数群 ========== //
        
        /**
         * パフォーマンス最適化開始
         */
        function startPerformanceOptimization() {
            const resultsDiv = document.getElementById('performance-results');
            
            try {
                if (window.timelinePerformanceOptimizer) {
                    window.timelinePerformanceOptimizer.startOptimization();
                    resultsDiv.innerHTML = '✅ パフォーマンス最適化開始<br><small>FPS・メモリ・CPU負荷を監視中</small>';
                    
                    // UI更新を開始
                    startPerformanceUIUpdate();
                    
                    console.log('🚀 パフォーマンス最適化開始');
                } else {
                    resultsDiv.innerHTML = '❌ パフォーマンス最適化システムが見つかりません';
                }
            } catch (error) {
                resultsDiv.innerHTML = `❌ エラー: ${error.message}`;
                console.error('パフォーマンス最適化開始エラー:', error);
            }
        }
        
        /**
         * パフォーマンス最適化停止
         */
        function stopPerformanceOptimization() {
            const resultsDiv = document.getElementById('performance-results');
            
            try {
                if (window.timelinePerformanceOptimizer) {
                    window.timelinePerformanceOptimizer.stopOptimization();
                    resultsDiv.innerHTML = '⏹️ パフォーマンス最適化停止<br><small>監視を停止しました</small>';
                    console.log('⏹️ パフォーマンス最適化停止');
                } else {
                    resultsDiv.innerHTML = '❌ パフォーマンス最適化システムが見つかりません';
                }
            } catch (error) {
                resultsDiv.innerHTML = `❌ エラー: ${error.message}`;
                console.error('パフォーマンス最適化停止エラー:', error);
            }
        }
        
        /**
         * パフォーマンスレポート表示
         */
        function showPerformanceReport() {
            const resultsDiv = document.getElementById('performance-results');
            
            try {
                const report = window.getPerformanceReport ? window.getPerformanceReport() : null;
                
                if (report) {
                    const current = report.current;
                    resultsDiv.innerHTML = `
                        📊 パフォーマンスレポート<br>
                        <small>
                        FPS: ${current.fps} | メモリ: ${(current.memoryUsage / 1024 / 1024).toFixed(1)}MB<br>
                        CPU: ${current.cpuUsage.toFixed(1)}% | フレーム時間: ${current.frameTime.toFixed(2)}ms
                        </small>
                    `;
                    console.log('📊 パフォーマンスレポート表示', report);
                } else {
                    resultsDiv.innerHTML = '❌ パフォーマンスデータが取得できません';
                }
            } catch (error) {
                resultsDiv.innerHTML = `❌ エラー: ${error.message}`;
                console.error('パフォーマンスレポート表示エラー:', error);
            }
        }
        
        /**
         * メモリクリーンアップ実行
         */
        function executeMemoryCleanup() {
            const resultsDiv = document.getElementById('performance-results');
            
            try {
                if (window.timelinePerformanceOptimizer) {
                    window.timelinePerformanceOptimizer.executeMemoryCleanup();
                    resultsDiv.innerHTML = '🧹 メモリクリーンアップ実行<br><small>メモリプール整理・ガベージコレクション実行</small>';
                    console.log('🧹 メモリクリーンアップ実行');
                } else {
                    resultsDiv.innerHTML = '❌ パフォーマンス最適化システムが見つかりません';
                }
            } catch (error) {
                resultsDiv.innerHTML = `❌ エラー: ${error.message}`;
                console.error('メモリクリーンアップエラー:', error);
            }
        }
        
        /**
         * パフォーマンスUI更新開始
         */
        function startPerformanceUIUpdate() {
            const updateInterval = setInterval(() => {
                if (!window.timelinePerformanceOptimizer || !window.timelinePerformanceOptimizer.isMonitoring) {
                    clearInterval(updateInterval);
                    return;
                }
                
                const metrics = window.timelinePerformanceOptimizer.performanceMetrics;
                
                // メモリ使用量表示更新
                const memoryElement = document.getElementById('memory-usage');
                if (memoryElement && metrics.memoryUsage) {
                    memoryElement.textContent = `${(metrics.memoryUsage / 1024 / 1024).toFixed(1)}MB`;
                }
                
                // CPU負荷表示更新
                const cpuElement = document.getElementById('cpu-usage');
                if (cpuElement) {
                    cpuElement.textContent = `${metrics.cpuUsage.toFixed(1)}%`;
                }
                
            }, 2000); // 2秒間隔で更新
        }
        
        // 実験環境初期化
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🎬 タイムライン制御システム実験環境 初期化開始');
            window.timelineExperiment = new TimelineExperimentEnvironment();
        });
    </script>
</body>
</html>